import xh, { useState as as, useRef as Zh, useEffect as ou } from "react";
function vh(r) {
  if (Object.prototype.hasOwnProperty.call(r, "__esModule")) return r;
  var t = r.default;
  if (typeof t == "function") {
    var i = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(i, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), i;
}
var us = { exports: {} }, mn = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nu;
function Wh() {
  if (Nu) return mn;
  Nu = 1;
  var r = xh, t = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function e(l, a, u) {
    var f, m = {}, g = null, A = null;
    u !== void 0 && (g = "" + u), a.key !== void 0 && (g = "" + a.key), a.ref !== void 0 && (A = a.ref);
    for (f in a) n.call(a, f) && !o.hasOwnProperty(f) && (m[f] = a[f]);
    if (l && l.defaultProps) for (f in a = l.defaultProps, a) m[f] === void 0 && (m[f] = a[f]);
    return { $$typeof: t, type: l, key: g, ref: A, props: m, _owner: s.current };
  }
  return mn.Fragment = i, mn.jsx = e, mn.jsxs = e, mn;
}
var hn = {}, Gu;
function Jh() {
  if (Gu) return hn;
  Gu = 1;
  var r = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return r.NODE_ENV !== "production" && function() {
    var t = xh, i = Symbol.for("react.element"), n = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), e = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), a = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), m = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), R = Symbol.iterator, E = "@@iterator";
    function h(P) {
      if (P === null || typeof P != "object")
        return null;
      var G = R && P[R] || P[E];
      return typeof G == "function" ? G : null;
    }
    var C = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function K(P) {
      {
        for (var G = arguments.length, W = new Array(G > 1 ? G - 1 : 0), de = 1; de < G; de++)
          W[de - 1] = arguments[de];
        k("error", P, W);
      }
    }
    function k(P, G, W) {
      {
        var de = C.ReactDebugCurrentFrame, ge = de.getStackAddendum();
        ge !== "" && (G += "%s", W = W.concat([ge]));
        var ve = W.map(function(ye) {
          return String(ye);
        });
        ve.unshift("Warning: " + G), Function.prototype.apply.call(console[P], console, ve);
      }
    }
    var F = !1, Z = !1, q = !1, J = !1, xe = !1, oe;
    oe = Symbol.for("react.module.reference");
    function Y(P) {
      return !!(typeof P == "string" || typeof P == "function" || P === s || P === e || xe || P === o || P === f || P === m || J || P === v || F || Z || q || typeof P == "object" && P !== null && (P.$$typeof === A || P.$$typeof === g || P.$$typeof === l || P.$$typeof === a || P.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      P.$$typeof === oe || P.getModuleId !== void 0));
    }
    function T(P, G, W) {
      var de = P.displayName;
      if (de)
        return de;
      var ge = G.displayName || G.name || "";
      return ge !== "" ? W + "(" + ge + ")" : W;
    }
    function V(P) {
      return P.displayName || "Context";
    }
    function U(P) {
      if (P == null)
        return null;
      if (typeof P.tag == "number" && K("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof P == "function")
        return P.displayName || P.name || null;
      if (typeof P == "string")
        return P;
      switch (P) {
        case s:
          return "Fragment";
        case n:
          return "Portal";
        case e:
          return "Profiler";
        case o:
          return "StrictMode";
        case f:
          return "Suspense";
        case m:
          return "SuspenseList";
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case a:
            var G = P;
            return V(G) + ".Consumer";
          case l:
            var W = P;
            return V(W._context) + ".Provider";
          case u:
            return T(P, P.render, "ForwardRef");
          case g:
            var de = P.displayName || null;
            return de !== null ? de : U(P.type) || "Memo";
          case A: {
            var ge = P, ve = ge._payload, ye = ge._init;
            try {
              return U(ye(ve));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var D = Object.assign, N = 0, ae, le, he, ze, Ce, Be, Ie;
    function je() {
    }
    je.__reactDisabledLog = !0;
    function qe() {
      {
        if (N === 0) {
          ae = console.log, le = console.info, he = console.warn, ze = console.error, Ce = console.group, Be = console.groupCollapsed, Ie = console.groupEnd;
          var P = {
            configurable: !0,
            enumerable: !0,
            value: je,
            writable: !0
          };
          Object.defineProperties(console, {
            info: P,
            log: P,
            warn: P,
            error: P,
            group: P,
            groupCollapsed: P,
            groupEnd: P
          });
        }
        N++;
      }
    }
    function Xe() {
      {
        if (N--, N === 0) {
          var P = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: D({}, P, {
              value: ae
            }),
            info: D({}, P, {
              value: le
            }),
            warn: D({}, P, {
              value: he
            }),
            error: D({}, P, {
              value: ze
            }),
            group: D({}, P, {
              value: Ce
            }),
            groupCollapsed: D({}, P, {
              value: Be
            }),
            groupEnd: D({}, P, {
              value: Ie
            })
          });
        }
        N < 0 && K("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Je = C.ReactCurrentDispatcher, ke;
    function Ge(P, G, W) {
      {
        if (ke === void 0)
          try {
            throw Error();
          } catch (ge) {
            var de = ge.stack.trim().match(/\n( *(at )?)/);
            ke = de && de[1] || "";
          }
        return `
` + ke + P;
      }
    }
    var Fe = !1, Se;
    {
      var Oe = typeof WeakMap == "function" ? WeakMap : Map;
      Se = new Oe();
    }
    function it(P, G) {
      if (!P || Fe)
        return "";
      {
        var W = Se.get(P);
        if (W !== void 0)
          return W;
      }
      var de;
      Fe = !0;
      var ge = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ve;
      ve = Je.current, Je.current = null, qe();
      try {
        if (G) {
          var ye = function() {
            throw Error();
          };
          if (Object.defineProperty(ye.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ye, []);
            } catch (Ne) {
              de = Ne;
            }
            Reflect.construct(P, [], ye);
          } else {
            try {
              ye.call();
            } catch (Ne) {
              de = Ne;
            }
            P.call(ye.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            de = Ne;
          }
          P();
        }
      } catch (Ne) {
        if (Ne && de && typeof Ne.stack == "string") {
          for (var fe = Ne.stack.split(`
`), Ke = de.stack.split(`
`), Ae = fe.length - 1, _e = Ke.length - 1; Ae >= 1 && _e >= 0 && fe[Ae] !== Ke[_e]; )
            _e--;
          for (; Ae >= 1 && _e >= 0; Ae--, _e--)
            if (fe[Ae] !== Ke[_e]) {
              if (Ae !== 1 || _e !== 1)
                do
                  if (Ae--, _e--, _e < 0 || fe[Ae] !== Ke[_e]) {
                    var We = `
` + fe[Ae].replace(" at new ", " at ");
                    return P.displayName && We.includes("<anonymous>") && (We = We.replace("<anonymous>", P.displayName)), typeof P == "function" && Se.set(P, We), We;
                  }
                while (Ae >= 1 && _e >= 0);
              break;
            }
        }
      } finally {
        Fe = !1, Je.current = ve, Xe(), Error.prepareStackTrace = ge;
      }
      var It = P ? P.displayName || P.name : "", bt = It ? Ge(It) : "";
      return typeof P == "function" && Se.set(P, bt), bt;
    }
    function Te(P, G, W) {
      return it(P, !1);
    }
    function Qe(P) {
      var G = P.prototype;
      return !!(G && G.isReactComponent);
    }
    function be(P, G, W) {
      if (P == null)
        return "";
      if (typeof P == "function")
        return it(P, Qe(P));
      if (typeof P == "string")
        return Ge(P);
      switch (P) {
        case f:
          return Ge("Suspense");
        case m:
          return Ge("SuspenseList");
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case u:
            return Te(P.render);
          case g:
            return be(P.type, G, W);
          case A: {
            var de = P, ge = de._payload, ve = de._init;
            try {
              return be(ve(ge), G, W);
            } catch {
            }
          }
        }
      return "";
    }
    var we = Object.prototype.hasOwnProperty, Pe = {}, nt = C.ReactDebugCurrentFrame;
    function Ue(P) {
      if (P) {
        var G = P._owner, W = be(P.type, P._source, G ? G.type : null);
        nt.setExtraStackFrame(W);
      } else
        nt.setExtraStackFrame(null);
    }
    function st(P, G, W, de, ge) {
      {
        var ve = Function.call.bind(we);
        for (var ye in P)
          if (ve(P, ye)) {
            var fe = void 0;
            try {
              if (typeof P[ye] != "function") {
                var Ke = Error((de || "React class") + ": " + W + " type `" + ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof P[ye] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ke.name = "Invariant Violation", Ke;
              }
              fe = P[ye](G, ye, de, W, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ae) {
              fe = Ae;
            }
            fe && !(fe instanceof Error) && (Ue(ge), K("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", de || "React class", W, ye, typeof fe), Ue(null)), fe instanceof Error && !(fe.message in Pe) && (Pe[fe.message] = !0, Ue(ge), K("Failed %s type: %s", W, fe.message), Ue(null));
          }
      }
    }
    var Ve = Array.isArray;
    function X(P) {
      return Ve(P);
    }
    function dt(P) {
      {
        var G = typeof Symbol == "function" && Symbol.toStringTag, W = G && P[Symbol.toStringTag] || P.constructor.name || "Object";
        return W;
      }
    }
    function Ye(P) {
      try {
        return z(P), !1;
      } catch {
        return !0;
      }
    }
    function z(P) {
      return "" + P;
    }
    function pt(P) {
      if (Ye(P))
        return K("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", dt(P)), z(P);
    }
    var ft = C.ReactCurrentOwner, Bt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, et, yt;
    function ot(P) {
      if (we.call(P, "ref")) {
        var G = Object.getOwnPropertyDescriptor(P, "ref").get;
        if (G && G.isReactWarning)
          return !1;
      }
      return P.ref !== void 0;
    }
    function $e(P) {
      if (we.call(P, "key")) {
        var G = Object.getOwnPropertyDescriptor(P, "key").get;
        if (G && G.isReactWarning)
          return !1;
      }
      return P.key !== void 0;
    }
    function He(P, G) {
      typeof P.ref == "string" && ft.current;
    }
    function Ze(P, G) {
      {
        var W = function() {
          et || (et = !0, K("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", G));
        };
        W.isReactWarning = !0, Object.defineProperty(P, "key", {
          get: W,
          configurable: !0
        });
      }
    }
    function _t(P, G) {
      {
        var W = function() {
          yt || (yt = !0, K("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", G));
        };
        W.isReactWarning = !0, Object.defineProperty(P, "ref", {
          get: W,
          configurable: !0
        });
      }
    }
    var Ct = function(P, G, W, de, ge, ve, ye) {
      var fe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: i,
        // Built-in properties that belong on the element
        type: P,
        key: G,
        ref: W,
        props: ye,
        // Record the component responsible for creating this element.
        _owner: ve
      };
      return fe._store = {}, Object.defineProperty(fe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(fe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: de
      }), Object.defineProperty(fe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.freeze && (Object.freeze(fe.props), Object.freeze(fe)), fe;
    };
    function mt(P, G, W, de, ge) {
      {
        var ve, ye = {}, fe = null, Ke = null;
        W !== void 0 && (pt(W), fe = "" + W), $e(G) && (pt(G.key), fe = "" + G.key), ot(G) && (Ke = G.ref, He(G, ge));
        for (ve in G)
          we.call(G, ve) && !Bt.hasOwnProperty(ve) && (ye[ve] = G[ve]);
        if (P && P.defaultProps) {
          var Ae = P.defaultProps;
          for (ve in Ae)
            ye[ve] === void 0 && (ye[ve] = Ae[ve]);
        }
        if (fe || Ke) {
          var _e = typeof P == "function" ? P.displayName || P.name || "Unknown" : P;
          fe && Ze(ye, _e), Ke && _t(ye, _e);
        }
        return Ct(P, fe, Ke, ge, de, ft.current, ye);
      }
    }
    var Tt = C.ReactCurrentOwner, ht = C.ReactDebugCurrentFrame;
    function Me(P) {
      if (P) {
        var G = P._owner, W = be(P.type, P._source, G ? G.type : null);
        ht.setExtraStackFrame(W);
      } else
        ht.setExtraStackFrame(null);
    }
    var Pt;
    Pt = !1;
    function Ut(P) {
      return typeof P == "object" && P !== null && P.$$typeof === i;
    }
    function se() {
      {
        if (Tt.current) {
          var P = U(Tt.current.type);
          if (P)
            return `

Check the render method of \`` + P + "`.";
        }
        return "";
      }
    }
    function or(P) {
      return "";
    }
    var Nt = {};
    function Vt(P) {
      {
        var G = se();
        if (!G) {
          var W = typeof P == "string" ? P : P.displayName || P.name;
          W && (G = `

Check the top-level render call using <` + W + ">.");
        }
        return G;
      }
    }
    function Xt(P, G) {
      {
        if (!P._store || P._store.validated || P.key != null)
          return;
        P._store.validated = !0;
        var W = Vt(G);
        if (Nt[W])
          return;
        Nt[W] = !0;
        var de = "";
        P && P._owner && P._owner !== Tt.current && (de = " It was passed a child from " + U(P._owner.type) + "."), Me(P), K('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', W, de), Me(null);
      }
    }
    function Ht(P, G) {
      {
        if (typeof P != "object")
          return;
        if (X(P))
          for (var W = 0; W < P.length; W++) {
            var de = P[W];
            Ut(de) && Xt(de, G);
          }
        else if (Ut(P))
          P._store && (P._store.validated = !0);
        else if (P) {
          var ge = h(P);
          if (typeof ge == "function" && ge !== P.entries)
            for (var ve = ge.call(P), ye; !(ye = ve.next()).done; )
              Ut(ye.value) && Xt(ye.value, G);
        }
      }
    }
    function Kt(P) {
      {
        var G = P.type;
        if (G == null || typeof G == "string")
          return;
        var W;
        if (typeof G == "function")
          W = G.propTypes;
        else if (typeof G == "object" && (G.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        G.$$typeof === g))
          W = G.propTypes;
        else
          return;
        if (W) {
          var de = U(G);
          st(W, P.props, "prop", de, P);
        } else if (G.PropTypes !== void 0 && !Pt) {
          Pt = !0;
          var ge = U(G);
          K("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ge || "Unknown");
        }
        typeof G.getDefaultProps == "function" && !G.getDefaultProps.isReactClassApproved && K("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ar(P) {
      {
        for (var G = Object.keys(P.props), W = 0; W < G.length; W++) {
          var de = G[W];
          if (de !== "children" && de !== "key") {
            Me(P), K("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", de), Me(null);
            break;
          }
        }
        P.ref !== null && (Me(P), K("Invalid attribute `ref` supplied to `React.Fragment`."), Me(null));
      }
    }
    var Zt = {};
    function O(P, G, W, de, ge, ve) {
      {
        var ye = Y(P);
        if (!ye) {
          var fe = "";
          (P === void 0 || typeof P == "object" && P !== null && Object.keys(P).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ke = or();
          Ke ? fe += Ke : fe += se();
          var Ae;
          P === null ? Ae = "null" : X(P) ? Ae = "array" : P !== void 0 && P.$$typeof === i ? (Ae = "<" + (U(P.type) || "Unknown") + " />", fe = " Did you accidentally export a JSX literal instead of a component?") : Ae = typeof P, K("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ae, fe);
        }
        var _e = mt(P, G, W, ge, ve);
        if (_e == null)
          return _e;
        if (ye) {
          var We = G.children;
          if (We !== void 0)
            if (de)
              if (X(We)) {
                for (var It = 0; It < We.length; It++)
                  Ht(We[It], P);
                Object.freeze && Object.freeze(We);
              } else
                K("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ht(We, P);
        }
        if (we.call(G, "key")) {
          var bt = U(P), Ne = Object.keys(G).filter(function(br) {
            return br !== "key";
          }), ur = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Zt[bt + ur]) {
            var hr = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            K(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ur, bt, hr, bt), Zt[bt + ur] = !0;
          }
        }
        return P === s ? ar(_e) : Kt(_e), _e;
      }
    }
    function Cr(P, G, W) {
      return O(P, G, W, !0);
    }
    function Tr(P, G, W) {
      return O(P, G, W, !1);
    }
    var mr = Tr, Sr = Cr;
    hn.Fragment = s, hn.jsx = mr, hn.jsxs = Sr;
  }(), hn;
}
var Fu;
function Qh() {
  if (Fu) return us.exports;
  Fu = 1;
  var r = {};
  return r.NODE_ENV === "production" ? us.exports = Wh() : us.exports = Jh(), us.exports;
}
var ne = Qh(), Xr = {}, Hr = {}, au = {}, Wt = {}, Zr = {}, Jt = {}, cs = {}, uu = {}, $u;
function tu() {
  return $u || ($u = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.getParsedType = r.ZodParsedType = r.objectUtil = r.util = void 0;
    var t;
    (function(s) {
      s.assertEqual = (a) => a;
      function o(a) {
      }
      s.assertIs = o;
      function e(a) {
        throw new Error();
      }
      s.assertNever = e, s.arrayToEnum = (a) => {
        const u = {};
        for (const f of a)
          u[f] = f;
        return u;
      }, s.getValidEnumValues = (a) => {
        const u = s.objectKeys(a).filter((m) => typeof a[a[m]] != "number"), f = {};
        for (const m of u)
          f[m] = a[m];
        return s.objectValues(f);
      }, s.objectValues = (a) => s.objectKeys(a).map(function(u) {
        return a[u];
      }), s.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
        const u = [];
        for (const f in a)
          Object.prototype.hasOwnProperty.call(a, f) && u.push(f);
        return u;
      }, s.find = (a, u) => {
        for (const f of a)
          if (u(f))
            return f;
      }, s.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
      function l(a, u = " | ") {
        return a.map((f) => typeof f == "string" ? `'${f}'` : f).join(u);
      }
      s.joinValues = l, s.jsonStringifyReplacer = (a, u) => typeof u == "bigint" ? u.toString() : u;
    })(t || (r.util = t = {}));
    var i;
    (function(s) {
      s.mergeShapes = (o, e) => ({
        ...o,
        ...e
        // second overwrites first
      });
    })(i || (r.objectUtil = i = {})), r.ZodParsedType = t.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    const n = (s) => {
      switch (typeof s) {
        case "undefined":
          return r.ZodParsedType.undefined;
        case "string":
          return r.ZodParsedType.string;
        case "number":
          return isNaN(s) ? r.ZodParsedType.nan : r.ZodParsedType.number;
        case "boolean":
          return r.ZodParsedType.boolean;
        case "function":
          return r.ZodParsedType.function;
        case "bigint":
          return r.ZodParsedType.bigint;
        case "symbol":
          return r.ZodParsedType.symbol;
        case "object":
          return Array.isArray(s) ? r.ZodParsedType.array : s === null ? r.ZodParsedType.null : s.then && typeof s.then == "function" && s.catch && typeof s.catch == "function" ? r.ZodParsedType.promise : typeof Map < "u" && s instanceof Map ? r.ZodParsedType.map : typeof Set < "u" && s instanceof Set ? r.ZodParsedType.set : typeof Date < "u" && s instanceof Date ? r.ZodParsedType.date : r.ZodParsedType.object;
        default:
          return r.ZodParsedType.unknown;
      }
    };
    r.getParsedType = n;
  }(uu)), uu;
}
var gr = {}, zu;
function Bu() {
  if (zu) return gr;
  zu = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.ZodError = gr.quotelessJson = gr.ZodIssueCode = void 0;
  const r = /* @__PURE__ */ tu();
  gr.ZodIssueCode = r.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const t = (n) => JSON.stringify(n, null, 2).replace(/"([^"]+)":/g, "$1:");
  gr.quotelessJson = t;
  let i = class Rh extends Error {
    get errors() {
      return this.issues;
    }
    constructor(s) {
      super(), this.issues = [], this.addIssue = (e) => {
        this.issues = [...this.issues, e];
      }, this.addIssues = (e = []) => {
        this.issues = [...this.issues, ...e];
      };
      const o = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, o) : this.__proto__ = o, this.name = "ZodError", this.issues = s;
    }
    format(s) {
      const o = s || function(a) {
        return a.message;
      }, e = { _errors: [] }, l = (a) => {
        for (const u of a.issues)
          if (u.code === "invalid_union")
            u.unionErrors.map(l);
          else if (u.code === "invalid_return_type")
            l(u.returnTypeError);
          else if (u.code === "invalid_arguments")
            l(u.argumentsError);
          else if (u.path.length === 0)
            e._errors.push(o(u));
          else {
            let f = e, m = 0;
            for (; m < u.path.length; ) {
              const g = u.path[m];
              m === u.path.length - 1 ? (f[g] = f[g] || { _errors: [] }, f[g]._errors.push(o(u))) : f[g] = f[g] || { _errors: [] }, f = f[g], m++;
            }
          }
      };
      return l(this), e;
    }
    static assert(s) {
      if (!(s instanceof Rh))
        throw new Error(`Not a ZodError: ${s}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, r.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(s = (o) => o.message) {
      const o = {}, e = [];
      for (const l of this.issues)
        l.path.length > 0 ? (o[l.path[0]] = o[l.path[0]] || [], o[l.path[0]].push(s(l))) : e.push(s(l));
      return { formErrors: e, fieldErrors: o };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  return gr.ZodError = i, i.create = (n) => new i(n), gr;
}
var Xu;
function Ah() {
  if (Xu) return cs;
  Xu = 1, Object.defineProperty(cs, "__esModule", { value: !0 });
  const r = /* @__PURE__ */ tu(), t = /* @__PURE__ */ Bu(), i = (n, s) => {
    let o;
    switch (n.code) {
      case t.ZodIssueCode.invalid_type:
        n.received === r.ZodParsedType.undefined ? o = "Required" : o = `Expected ${n.expected}, received ${n.received}`;
        break;
      case t.ZodIssueCode.invalid_literal:
        o = `Invalid literal value, expected ${JSON.stringify(n.expected, r.util.jsonStringifyReplacer)}`;
        break;
      case t.ZodIssueCode.unrecognized_keys:
        o = `Unrecognized key(s) in object: ${r.util.joinValues(n.keys, ", ")}`;
        break;
      case t.ZodIssueCode.invalid_union:
        o = "Invalid input";
        break;
      case t.ZodIssueCode.invalid_union_discriminator:
        o = `Invalid discriminator value. Expected ${r.util.joinValues(n.options)}`;
        break;
      case t.ZodIssueCode.invalid_enum_value:
        o = `Invalid enum value. Expected ${r.util.joinValues(n.options)}, received '${n.received}'`;
        break;
      case t.ZodIssueCode.invalid_arguments:
        o = "Invalid function arguments";
        break;
      case t.ZodIssueCode.invalid_return_type:
        o = "Invalid function return type";
        break;
      case t.ZodIssueCode.invalid_date:
        o = "Invalid date";
        break;
      case t.ZodIssueCode.invalid_string:
        typeof n.validation == "object" ? "includes" in n.validation ? (o = `Invalid input: must include "${n.validation.includes}"`, typeof n.validation.position == "number" && (o = `${o} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith" in n.validation ? o = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith" in n.validation ? o = `Invalid input: must end with "${n.validation.endsWith}"` : r.util.assertNever(n.validation) : n.validation !== "regex" ? o = `Invalid ${n.validation}` : o = "Invalid";
        break;
      case t.ZodIssueCode.too_small:
        n.type === "array" ? o = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? o = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? o = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? o = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : o = "Invalid input";
        break;
      case t.ZodIssueCode.too_big:
        n.type === "array" ? o = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? o = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? o = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? o = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? o = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : o = "Invalid input";
        break;
      case t.ZodIssueCode.custom:
        o = "Invalid input";
        break;
      case t.ZodIssueCode.invalid_intersection_types:
        o = "Intersection results could not be merged";
        break;
      case t.ZodIssueCode.not_multiple_of:
        o = `Number must be a multiple of ${n.multipleOf}`;
        break;
      case t.ZodIssueCode.not_finite:
        o = "Number must be finite";
        break;
      default:
        o = s.defaultError, r.util.assertNever(n);
    }
    return { message: o };
  };
  return cs.default = i, cs;
}
var Hu;
function Pu() {
  if (Hu) return Jt;
  Hu = 1;
  var r = Jt && Jt.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.getErrorMap = Jt.setErrorMap = Jt.defaultErrorMap = void 0;
  const t = r(/* @__PURE__ */ Ah());
  Jt.defaultErrorMap = t.default;
  let i = t.default;
  function n(o) {
    i = o;
  }
  Jt.setErrorMap = n;
  function s() {
    return i;
  }
  return Jt.getErrorMap = s, Jt;
}
var bn = {}, Zu;
function _h() {
  return Zu || (Zu = 1, function(r) {
    var t = bn && bn.__importDefault || function(A) {
      return A && A.__esModule ? A : { default: A };
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.isAsync = r.isValid = r.isDirty = r.isAborted = r.OK = r.DIRTY = r.INVALID = r.ParseStatus = r.addIssueToContext = r.EMPTY_PATH = r.makeIssue = void 0;
    const i = /* @__PURE__ */ Pu(), n = t(/* @__PURE__ */ Ah()), s = (A) => {
      const { data: v, path: R, errorMaps: E, issueData: h } = A, C = [...R, ...h.path || []], K = {
        ...h,
        path: C
      };
      if (h.message !== void 0)
        return {
          ...h,
          path: C,
          message: h.message
        };
      let k = "";
      const F = E.filter((Z) => !!Z).slice().reverse();
      for (const Z of F)
        k = Z(K, { data: v, defaultError: k }).message;
      return {
        ...h,
        path: C,
        message: k
      };
    };
    r.makeIssue = s, r.EMPTY_PATH = [];
    function o(A, v) {
      const R = (0, i.getErrorMap)(), E = (0, r.makeIssue)({
        issueData: v,
        data: A.data,
        path: A.path,
        errorMaps: [
          A.common.contextualErrorMap,
          // contextual error map is first priority
          A.schemaErrorMap,
          // then schema-bound map if available
          R,
          // then global override map
          R === n.default ? void 0 : n.default
          // then global default map
        ].filter((h) => !!h)
      });
      A.common.issues.push(E);
    }
    r.addIssueToContext = o;
    class e {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        this.value === "valid" && (this.value = "dirty");
      }
      abort() {
        this.value !== "aborted" && (this.value = "aborted");
      }
      static mergeArray(v, R) {
        const E = [];
        for (const h of R) {
          if (h.status === "aborted")
            return r.INVALID;
          h.status === "dirty" && v.dirty(), E.push(h.value);
        }
        return { status: v.value, value: E };
      }
      static async mergeObjectAsync(v, R) {
        const E = [];
        for (const h of R) {
          const C = await h.key, K = await h.value;
          E.push({
            key: C,
            value: K
          });
        }
        return e.mergeObjectSync(v, E);
      }
      static mergeObjectSync(v, R) {
        const E = {};
        for (const h of R) {
          const { key: C, value: K } = h;
          if (C.status === "aborted" || K.status === "aborted")
            return r.INVALID;
          C.status === "dirty" && v.dirty(), K.status === "dirty" && v.dirty(), C.value !== "__proto__" && (typeof K.value < "u" || h.alwaysSet) && (E[C.value] = K.value);
        }
        return { status: v.value, value: E };
      }
    }
    r.ParseStatus = e, r.INVALID = Object.freeze({
      status: "aborted"
    });
    const l = (A) => ({ status: "dirty", value: A });
    r.DIRTY = l;
    const a = (A) => ({ status: "valid", value: A });
    r.OK = a;
    const u = (A) => A.status === "aborted";
    r.isAborted = u;
    const f = (A) => A.status === "dirty";
    r.isDirty = f;
    const m = (A) => A.status === "valid";
    r.isValid = m;
    const g = (A) => typeof Promise < "u" && A instanceof Promise;
    r.isAsync = g;
  }(bn)), bn;
}
var cu = {}, Wu;
function Yh() {
  return Wu || (Wu = 1, Object.defineProperty(cu, "__esModule", { value: !0 })), cu;
}
var I = {}, gn = {}, Ju;
function eb() {
  if (Ju) return gn;
  Ju = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.errorUtil = void 0;
  var r;
  return function(t) {
    t.errToObj = (i) => typeof i == "string" ? { message: i } : i || {}, t.toString = (i) => typeof i == "string" ? i : i == null ? void 0 : i.message;
  }(r || (gn.errorUtil = r = {})), gn;
}
var Qu;
function tb() {
  if (Qu) return I;
  Qu = 1;
  var r = I && I.__classPrivateFieldGet || function(_, p, x, b) {
    if (x === "a" && !b) throw new TypeError("Private accessor was defined without a getter");
    if (typeof p == "function" ? _ !== p || !b : !p.has(_)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return x === "m" ? b : x === "a" ? b.call(_) : b ? b.value : p.get(_);
  }, t = I && I.__classPrivateFieldSet || function(_, p, x, b, L) {
    if (b === "m") throw new TypeError("Private method is not writable");
    if (b === "a" && !L) throw new TypeError("Private accessor was defined without a setter");
    if (typeof p == "function" ? _ !== p || !L : !p.has(_)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return b === "a" ? L.call(_, x) : L ? L.value = x : p.set(_, x), x;
  }, i, n;
  Object.defineProperty(I, "__esModule", { value: !0 }), I.boolean = I.bigint = I.array = I.any = I.coerce = I.ZodFirstPartyTypeKind = I.late = I.ZodSchema = I.Schema = I.custom = I.ZodReadonly = I.ZodPipeline = I.ZodBranded = I.BRAND = I.ZodNaN = I.ZodCatch = I.ZodDefault = I.ZodNullable = I.ZodOptional = I.ZodTransformer = I.ZodEffects = I.ZodPromise = I.ZodNativeEnum = I.ZodEnum = I.ZodLiteral = I.ZodLazy = I.ZodFunction = I.ZodSet = I.ZodMap = I.ZodRecord = I.ZodTuple = I.ZodIntersection = I.ZodDiscriminatedUnion = I.ZodUnion = I.ZodObject = I.ZodArray = I.ZodVoid = I.ZodNever = I.ZodUnknown = I.ZodAny = I.ZodNull = I.ZodUndefined = I.ZodSymbol = I.ZodDate = I.ZodBoolean = I.ZodBigInt = I.ZodNumber = I.ZodString = I.datetimeRegex = I.ZodType = void 0, I.NEVER = I.void = I.unknown = I.union = I.undefined = I.tuple = I.transformer = I.symbol = I.string = I.strictObject = I.set = I.record = I.promise = I.preprocess = I.pipeline = I.ostring = I.optional = I.onumber = I.oboolean = I.object = I.number = I.nullable = I.null = I.never = I.nativeEnum = I.nan = I.map = I.literal = I.lazy = I.intersection = I.instanceof = I.function = I.enum = I.effect = I.discriminatedUnion = I.date = void 0;
  const s = /* @__PURE__ */ Pu(), o = /* @__PURE__ */ eb(), e = /* @__PURE__ */ _h(), l = /* @__PURE__ */ tu(), a = /* @__PURE__ */ Bu();
  class u {
    constructor(p, x, b, L) {
      this._cachedPath = [], this.parent = p, this.data = x, this._path = b, this._key = L;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const f = (_, p) => {
    if ((0, e.isValid)(p))
      return { success: !0, data: p.value };
    if (!_.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const x = new a.ZodError(_.common.issues);
        return this._error = x, this._error;
      }
    };
  };
  function m(_) {
    if (!_)
      return {};
    const { errorMap: p, invalid_type_error: x, required_error: b, description: L } = _;
    if (p && (x || b))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return p ? { errorMap: p, description: L } : { errorMap: ($, M) => {
      var ie, re;
      const { message: pe } = _;
      return $.code === "invalid_enum_value" ? { message: pe ?? M.defaultError } : typeof M.data > "u" ? { message: (ie = pe ?? b) !== null && ie !== void 0 ? ie : M.defaultError } : $.code !== "invalid_type" ? { message: M.defaultError } : { message: (re = pe ?? x) !== null && re !== void 0 ? re : M.defaultError };
    }, description: L };
  }
  class g {
    get description() {
      return this._def.description;
    }
    _getType(p) {
      return (0, l.getParsedType)(p.data);
    }
    _getOrReturnCtx(p, x) {
      return x || {
        common: p.parent.common,
        data: p.data,
        parsedType: (0, l.getParsedType)(p.data),
        schemaErrorMap: this._def.errorMap,
        path: p.path,
        parent: p.parent
      };
    }
    _processInputParams(p) {
      return {
        status: new e.ParseStatus(),
        ctx: {
          common: p.parent.common,
          data: p.data,
          parsedType: (0, l.getParsedType)(p.data),
          schemaErrorMap: this._def.errorMap,
          path: p.path,
          parent: p.parent
        }
      };
    }
    _parseSync(p) {
      const x = this._parse(p);
      if ((0, e.isAsync)(x))
        throw new Error("Synchronous parse encountered promise.");
      return x;
    }
    _parseAsync(p) {
      const x = this._parse(p);
      return Promise.resolve(x);
    }
    parse(p, x) {
      const b = this.safeParse(p, x);
      if (b.success)
        return b.data;
      throw b.error;
    }
    safeParse(p, x) {
      var b;
      const L = {
        common: {
          issues: [],
          async: (b = x == null ? void 0 : x.async) !== null && b !== void 0 ? b : !1,
          contextualErrorMap: x == null ? void 0 : x.errorMap
        },
        path: (x == null ? void 0 : x.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: p,
        parsedType: (0, l.getParsedType)(p)
      }, B = this._parseSync({ data: p, path: L.path, parent: L });
      return f(L, B);
    }
    "~validate"(p) {
      var x, b;
      const L = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: p,
        parsedType: (0, l.getParsedType)(p)
      };
      if (!this["~standard"].async)
        try {
          const B = this._parseSync({ data: p, path: [], parent: L });
          return (0, e.isValid)(B) ? {
            value: B.value
          } : {
            issues: L.common.issues
          };
        } catch (B) {
          !((b = (x = B == null ? void 0 : B.message) === null || x === void 0 ? void 0 : x.toLowerCase()) === null || b === void 0) && b.includes("encountered") && (this["~standard"].async = !0), L.common = {
            issues: [],
            async: !0
          };
        }
      return this._parseAsync({ data: p, path: [], parent: L }).then((B) => (0, e.isValid)(B) ? {
        value: B.value
      } : {
        issues: L.common.issues
      });
    }
    async parseAsync(p, x) {
      const b = await this.safeParseAsync(p, x);
      if (b.success)
        return b.data;
      throw b.error;
    }
    async safeParseAsync(p, x) {
      const b = {
        common: {
          issues: [],
          contextualErrorMap: x == null ? void 0 : x.errorMap,
          async: !0
        },
        path: (x == null ? void 0 : x.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: p,
        parsedType: (0, l.getParsedType)(p)
      }, L = this._parse({ data: p, path: b.path, parent: b }), B = await ((0, e.isAsync)(L) ? L : Promise.resolve(L));
      return f(b, B);
    }
    refine(p, x) {
      const b = (L) => typeof x == "string" || typeof x > "u" ? { message: x } : typeof x == "function" ? x(L) : x;
      return this._refinement((L, B) => {
        const $ = p(L), M = () => B.addIssue({
          code: a.ZodIssueCode.custom,
          ...b(L)
        });
        return typeof Promise < "u" && $ instanceof Promise ? $.then((ie) => ie ? !0 : (M(), !1)) : $ ? !0 : (M(), !1);
      });
    }
    refinement(p, x) {
      return this._refinement((b, L) => p(b) ? !0 : (L.addIssue(typeof x == "function" ? x(b, L) : x), !1));
    }
    _refinement(p) {
      return new $e({
        schema: this,
        typeName: se.ZodEffects,
        effect: { type: "refinement", refinement: p }
      });
    }
    superRefine(p) {
      return this._refinement(p);
    }
    constructor(p) {
      this.spa = this.safeParseAsync, this._def = p, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (x) => this["~validate"](x)
      };
    }
    optional() {
      return He.create(this, this._def);
    }
    nullable() {
      return Ze.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return Te.create(this);
    }
    promise() {
      return ot.create(this, this._def);
    }
    or(p) {
      return we.create([this, p], this._def);
    }
    and(p) {
      return st.create(this, p, this._def);
    }
    transform(p) {
      return new $e({
        ...m(this._def),
        schema: this,
        typeName: se.ZodEffects,
        effect: { type: "transform", transform: p }
      });
    }
    default(p) {
      const x = typeof p == "function" ? p : () => p;
      return new _t({
        ...m(this._def),
        innerType: this,
        defaultValue: x,
        typeName: se.ZodDefault
      });
    }
    brand() {
      return new Tt({
        typeName: se.ZodBranded,
        type: this,
        ...m(this._def)
      });
    }
    catch(p) {
      const x = typeof p == "function" ? p : () => p;
      return new Ct({
        ...m(this._def),
        innerType: this,
        catchValue: x,
        typeName: se.ZodCatch
      });
    }
    describe(p) {
      const x = this.constructor;
      return new x({
        ...this._def,
        description: p
      });
    }
    pipe(p) {
      return ht.create(this, p);
    }
    readonly() {
      return Me.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  I.ZodType = g, I.Schema = g, I.ZodSchema = g;
  const A = /^c[^\s-]{8,}$/i, v = /^[0-9a-z]+$/, R = /^[0-9A-HJKMNP-TV-Z]{26}$/i, E = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, h = /^[a-z0-9_-]{21}$/i, C = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, K = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, k = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, F = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let Z;
  const q = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, J = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, xe = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, oe = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Y = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, T = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, V = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", U = new RegExp(`^${V}$`);
  function D(_) {
    let p = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return _.precision ? p = `${p}\\.\\d{${_.precision}}` : _.precision == null && (p = `${p}(\\.\\d+)?`), p;
  }
  function N(_) {
    return new RegExp(`^${D(_)}$`);
  }
  function ae(_) {
    let p = `${V}T${D(_)}`;
    const x = [];
    return x.push(_.local ? "Z?" : "Z"), _.offset && x.push("([+-]\\d{2}:?\\d{2})"), p = `${p}(${x.join("|")})`, new RegExp(`^${p}$`);
  }
  I.datetimeRegex = ae;
  function le(_, p) {
    return !!((p === "v4" || !p) && q.test(_) || (p === "v6" || !p) && xe.test(_));
  }
  function he(_, p) {
    if (!C.test(_))
      return !1;
    try {
      const [x] = _.split("."), b = x.replace(/-/g, "+").replace(/_/g, "/").padEnd(x.length + (4 - x.length % 4) % 4, "="), L = JSON.parse(atob(b));
      return !(typeof L != "object" || L === null || !L.typ || !L.alg || p && L.alg !== p);
    } catch {
      return !1;
    }
  }
  function ze(_, p) {
    return !!((p === "v4" || !p) && J.test(_) || (p === "v6" || !p) && oe.test(_));
  }
  class Ce extends g {
    _parse(p) {
      if (this._def.coerce && (p.data = String(p.data)), this._getType(p) !== l.ZodParsedType.string) {
        const B = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(B, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.string,
          received: B.parsedType
        }), e.INVALID;
      }
      const b = new e.ParseStatus();
      let L;
      for (const B of this._def.checks)
        if (B.kind === "min")
          p.data.length < B.value && (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            code: a.ZodIssueCode.too_small,
            minimum: B.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: B.message
          }), b.dirty());
        else if (B.kind === "max")
          p.data.length > B.value && (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            code: a.ZodIssueCode.too_big,
            maximum: B.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: B.message
          }), b.dirty());
        else if (B.kind === "length") {
          const $ = p.data.length > B.value, M = p.data.length < B.value;
          ($ || M) && (L = this._getOrReturnCtx(p, L), $ ? (0, e.addIssueToContext)(L, {
            code: a.ZodIssueCode.too_big,
            maximum: B.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: B.message
          }) : M && (0, e.addIssueToContext)(L, {
            code: a.ZodIssueCode.too_small,
            minimum: B.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: B.message
          }), b.dirty());
        } else if (B.kind === "email")
          k.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "email",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "emoji")
          Z || (Z = new RegExp(F, "u")), Z.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "emoji",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "uuid")
          E.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "uuid",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "nanoid")
          h.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "nanoid",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "cuid")
          A.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "cuid",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "cuid2")
          v.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "cuid2",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "ulid")
          R.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
            validation: "ulid",
            code: a.ZodIssueCode.invalid_string,
            message: B.message
          }), b.dirty());
        else if (B.kind === "url")
          try {
            new URL(p.data);
          } catch {
            L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
              validation: "url",
              code: a.ZodIssueCode.invalid_string,
              message: B.message
            }), b.dirty();
          }
        else B.kind === "regex" ? (B.regex.lastIndex = 0, B.regex.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "regex",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty())) : B.kind === "trim" ? p.data = p.data.trim() : B.kind === "includes" ? p.data.includes(B.value, B.position) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.invalid_string,
          validation: { includes: B.value, position: B.position },
          message: B.message
        }), b.dirty()) : B.kind === "toLowerCase" ? p.data = p.data.toLowerCase() : B.kind === "toUpperCase" ? p.data = p.data.toUpperCase() : B.kind === "startsWith" ? p.data.startsWith(B.value) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.invalid_string,
          validation: { startsWith: B.value },
          message: B.message
        }), b.dirty()) : B.kind === "endsWith" ? p.data.endsWith(B.value) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.invalid_string,
          validation: { endsWith: B.value },
          message: B.message
        }), b.dirty()) : B.kind === "datetime" ? ae(B).test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: B.message
        }), b.dirty()) : B.kind === "date" ? U.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.invalid_string,
          validation: "date",
          message: B.message
        }), b.dirty()) : B.kind === "time" ? N(B).test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.invalid_string,
          validation: "time",
          message: B.message
        }), b.dirty()) : B.kind === "duration" ? K.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "duration",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty()) : B.kind === "ip" ? le(p.data, B.version) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "ip",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty()) : B.kind === "jwt" ? he(p.data, B.alg) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "jwt",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty()) : B.kind === "cidr" ? ze(p.data, B.version) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "cidr",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty()) : B.kind === "base64" ? Y.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "base64",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty()) : B.kind === "base64url" ? T.test(p.data) || (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          validation: "base64url",
          code: a.ZodIssueCode.invalid_string,
          message: B.message
        }), b.dirty()) : l.util.assertNever(B);
      return { status: b.value, value: p.data };
    }
    _regex(p, x, b) {
      return this.refinement((L) => p.test(L), {
        validation: x,
        code: a.ZodIssueCode.invalid_string,
        ...o.errorUtil.errToObj(b)
      });
    }
    _addCheck(p) {
      return new Ce({
        ...this._def,
        checks: [...this._def.checks, p]
      });
    }
    email(p) {
      return this._addCheck({ kind: "email", ...o.errorUtil.errToObj(p) });
    }
    url(p) {
      return this._addCheck({ kind: "url", ...o.errorUtil.errToObj(p) });
    }
    emoji(p) {
      return this._addCheck({ kind: "emoji", ...o.errorUtil.errToObj(p) });
    }
    uuid(p) {
      return this._addCheck({ kind: "uuid", ...o.errorUtil.errToObj(p) });
    }
    nanoid(p) {
      return this._addCheck({ kind: "nanoid", ...o.errorUtil.errToObj(p) });
    }
    cuid(p) {
      return this._addCheck({ kind: "cuid", ...o.errorUtil.errToObj(p) });
    }
    cuid2(p) {
      return this._addCheck({ kind: "cuid2", ...o.errorUtil.errToObj(p) });
    }
    ulid(p) {
      return this._addCheck({ kind: "ulid", ...o.errorUtil.errToObj(p) });
    }
    base64(p) {
      return this._addCheck({ kind: "base64", ...o.errorUtil.errToObj(p) });
    }
    base64url(p) {
      return this._addCheck({
        kind: "base64url",
        ...o.errorUtil.errToObj(p)
      });
    }
    jwt(p) {
      return this._addCheck({ kind: "jwt", ...o.errorUtil.errToObj(p) });
    }
    ip(p) {
      return this._addCheck({ kind: "ip", ...o.errorUtil.errToObj(p) });
    }
    cidr(p) {
      return this._addCheck({ kind: "cidr", ...o.errorUtil.errToObj(p) });
    }
    datetime(p) {
      var x, b;
      return typeof p == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: p
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof (p == null ? void 0 : p.precision) > "u" ? null : p == null ? void 0 : p.precision,
        offset: (x = p == null ? void 0 : p.offset) !== null && x !== void 0 ? x : !1,
        local: (b = p == null ? void 0 : p.local) !== null && b !== void 0 ? b : !1,
        ...o.errorUtil.errToObj(p == null ? void 0 : p.message)
      });
    }
    date(p) {
      return this._addCheck({ kind: "date", message: p });
    }
    time(p) {
      return typeof p == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: p
      }) : this._addCheck({
        kind: "time",
        precision: typeof (p == null ? void 0 : p.precision) > "u" ? null : p == null ? void 0 : p.precision,
        ...o.errorUtil.errToObj(p == null ? void 0 : p.message)
      });
    }
    duration(p) {
      return this._addCheck({ kind: "duration", ...o.errorUtil.errToObj(p) });
    }
    regex(p, x) {
      return this._addCheck({
        kind: "regex",
        regex: p,
        ...o.errorUtil.errToObj(x)
      });
    }
    includes(p, x) {
      return this._addCheck({
        kind: "includes",
        value: p,
        position: x == null ? void 0 : x.position,
        ...o.errorUtil.errToObj(x == null ? void 0 : x.message)
      });
    }
    startsWith(p, x) {
      return this._addCheck({
        kind: "startsWith",
        value: p,
        ...o.errorUtil.errToObj(x)
      });
    }
    endsWith(p, x) {
      return this._addCheck({
        kind: "endsWith",
        value: p,
        ...o.errorUtil.errToObj(x)
      });
    }
    min(p, x) {
      return this._addCheck({
        kind: "min",
        value: p,
        ...o.errorUtil.errToObj(x)
      });
    }
    max(p, x) {
      return this._addCheck({
        kind: "max",
        value: p,
        ...o.errorUtil.errToObj(x)
      });
    }
    length(p, x) {
      return this._addCheck({
        kind: "length",
        value: p,
        ...o.errorUtil.errToObj(x)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(p) {
      return this.min(1, o.errorUtil.errToObj(p));
    }
    trim() {
      return new Ce({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new Ce({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new Ce({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((p) => p.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((p) => p.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((p) => p.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((p) => p.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((p) => p.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((p) => p.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((p) => p.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((p) => p.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((p) => p.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((p) => p.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((p) => p.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((p) => p.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((p) => p.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((p) => p.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((p) => p.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((p) => p.kind === "base64url");
    }
    get minLength() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "min" && (p === null || x.value > p) && (p = x.value);
      return p;
    }
    get maxLength() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "max" && (p === null || x.value < p) && (p = x.value);
      return p;
    }
  }
  I.ZodString = Ce, Ce.create = (_) => {
    var p;
    return new Ce({
      checks: [],
      typeName: se.ZodString,
      coerce: (p = _ == null ? void 0 : _.coerce) !== null && p !== void 0 ? p : !1,
      ...m(_)
    });
  };
  function Be(_, p) {
    const x = (_.toString().split(".")[1] || "").length, b = (p.toString().split(".")[1] || "").length, L = x > b ? x : b, B = parseInt(_.toFixed(L).replace(".", "")), $ = parseInt(p.toFixed(L).replace(".", ""));
    return B % $ / Math.pow(10, L);
  }
  class Ie extends g {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(p) {
      if (this._def.coerce && (p.data = Number(p.data)), this._getType(p) !== l.ZodParsedType.number) {
        const B = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(B, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.number,
          received: B.parsedType
        }), e.INVALID;
      }
      let b;
      const L = new e.ParseStatus();
      for (const B of this._def.checks)
        B.kind === "int" ? l.util.isInteger(p.data) || (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: B.message
        }), L.dirty()) : B.kind === "min" ? (B.inclusive ? p.data < B.value : p.data <= B.value) && (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.too_small,
          minimum: B.value,
          type: "number",
          inclusive: B.inclusive,
          exact: !1,
          message: B.message
        }), L.dirty()) : B.kind === "max" ? (B.inclusive ? p.data > B.value : p.data >= B.value) && (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.too_big,
          maximum: B.value,
          type: "number",
          inclusive: B.inclusive,
          exact: !1,
          message: B.message
        }), L.dirty()) : B.kind === "multipleOf" ? Be(p.data, B.value) !== 0 && (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.not_multiple_of,
          multipleOf: B.value,
          message: B.message
        }), L.dirty()) : B.kind === "finite" ? Number.isFinite(p.data) || (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.not_finite,
          message: B.message
        }), L.dirty()) : l.util.assertNever(B);
      return { status: L.value, value: p.data };
    }
    gte(p, x) {
      return this.setLimit("min", p, !0, o.errorUtil.toString(x));
    }
    gt(p, x) {
      return this.setLimit("min", p, !1, o.errorUtil.toString(x));
    }
    lte(p, x) {
      return this.setLimit("max", p, !0, o.errorUtil.toString(x));
    }
    lt(p, x) {
      return this.setLimit("max", p, !1, o.errorUtil.toString(x));
    }
    setLimit(p, x, b, L) {
      return new Ie({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: p,
            value: x,
            inclusive: b,
            message: o.errorUtil.toString(L)
          }
        ]
      });
    }
    _addCheck(p) {
      return new Ie({
        ...this._def,
        checks: [...this._def.checks, p]
      });
    }
    int(p) {
      return this._addCheck({
        kind: "int",
        message: o.errorUtil.toString(p)
      });
    }
    positive(p) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: o.errorUtil.toString(p)
      });
    }
    negative(p) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: o.errorUtil.toString(p)
      });
    }
    nonpositive(p) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: o.errorUtil.toString(p)
      });
    }
    nonnegative(p) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: o.errorUtil.toString(p)
      });
    }
    multipleOf(p, x) {
      return this._addCheck({
        kind: "multipleOf",
        value: p,
        message: o.errorUtil.toString(x)
      });
    }
    finite(p) {
      return this._addCheck({
        kind: "finite",
        message: o.errorUtil.toString(p)
      });
    }
    safe(p) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: o.errorUtil.toString(p)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: o.errorUtil.toString(p)
      });
    }
    get minValue() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "min" && (p === null || x.value > p) && (p = x.value);
      return p;
    }
    get maxValue() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "max" && (p === null || x.value < p) && (p = x.value);
      return p;
    }
    get isInt() {
      return !!this._def.checks.find((p) => p.kind === "int" || p.kind === "multipleOf" && l.util.isInteger(p.value));
    }
    get isFinite() {
      let p = null, x = null;
      for (const b of this._def.checks) {
        if (b.kind === "finite" || b.kind === "int" || b.kind === "multipleOf")
          return !0;
        b.kind === "min" ? (x === null || b.value > x) && (x = b.value) : b.kind === "max" && (p === null || b.value < p) && (p = b.value);
      }
      return Number.isFinite(x) && Number.isFinite(p);
    }
  }
  I.ZodNumber = Ie, Ie.create = (_) => new Ie({
    checks: [],
    typeName: se.ZodNumber,
    coerce: (_ == null ? void 0 : _.coerce) || !1,
    ...m(_)
  });
  class je extends g {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(p) {
      if (this._def.coerce)
        try {
          p.data = BigInt(p.data);
        } catch {
          return this._getInvalidInput(p);
        }
      if (this._getType(p) !== l.ZodParsedType.bigint)
        return this._getInvalidInput(p);
      let b;
      const L = new e.ParseStatus();
      for (const B of this._def.checks)
        B.kind === "min" ? (B.inclusive ? p.data < B.value : p.data <= B.value) && (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.too_small,
          type: "bigint",
          minimum: B.value,
          inclusive: B.inclusive,
          message: B.message
        }), L.dirty()) : B.kind === "max" ? (B.inclusive ? p.data > B.value : p.data >= B.value) && (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.too_big,
          type: "bigint",
          maximum: B.value,
          inclusive: B.inclusive,
          message: B.message
        }), L.dirty()) : B.kind === "multipleOf" ? p.data % B.value !== BigInt(0) && (b = this._getOrReturnCtx(p, b), (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.not_multiple_of,
          multipleOf: B.value,
          message: B.message
        }), L.dirty()) : l.util.assertNever(B);
      return { status: L.value, value: p.data };
    }
    _getInvalidInput(p) {
      const x = this._getOrReturnCtx(p);
      return (0, e.addIssueToContext)(x, {
        code: a.ZodIssueCode.invalid_type,
        expected: l.ZodParsedType.bigint,
        received: x.parsedType
      }), e.INVALID;
    }
    gte(p, x) {
      return this.setLimit("min", p, !0, o.errorUtil.toString(x));
    }
    gt(p, x) {
      return this.setLimit("min", p, !1, o.errorUtil.toString(x));
    }
    lte(p, x) {
      return this.setLimit("max", p, !0, o.errorUtil.toString(x));
    }
    lt(p, x) {
      return this.setLimit("max", p, !1, o.errorUtil.toString(x));
    }
    setLimit(p, x, b, L) {
      return new je({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: p,
            value: x,
            inclusive: b,
            message: o.errorUtil.toString(L)
          }
        ]
      });
    }
    _addCheck(p) {
      return new je({
        ...this._def,
        checks: [...this._def.checks, p]
      });
    }
    positive(p) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: o.errorUtil.toString(p)
      });
    }
    negative(p) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: o.errorUtil.toString(p)
      });
    }
    nonpositive(p) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: o.errorUtil.toString(p)
      });
    }
    nonnegative(p) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: o.errorUtil.toString(p)
      });
    }
    multipleOf(p, x) {
      return this._addCheck({
        kind: "multipleOf",
        value: p,
        message: o.errorUtil.toString(x)
      });
    }
    get minValue() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "min" && (p === null || x.value > p) && (p = x.value);
      return p;
    }
    get maxValue() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "max" && (p === null || x.value < p) && (p = x.value);
      return p;
    }
  }
  I.ZodBigInt = je, je.create = (_) => {
    var p;
    return new je({
      checks: [],
      typeName: se.ZodBigInt,
      coerce: (p = _ == null ? void 0 : _.coerce) !== null && p !== void 0 ? p : !1,
      ...m(_)
    });
  };
  class qe extends g {
    _parse(p) {
      if (this._def.coerce && (p.data = !!p.data), this._getType(p) !== l.ZodParsedType.boolean) {
        const b = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.boolean,
          received: b.parsedType
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
  }
  I.ZodBoolean = qe, qe.create = (_) => new qe({
    typeName: se.ZodBoolean,
    coerce: (_ == null ? void 0 : _.coerce) || !1,
    ...m(_)
  });
  class Xe extends g {
    _parse(p) {
      if (this._def.coerce && (p.data = new Date(p.data)), this._getType(p) !== l.ZodParsedType.date) {
        const B = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(B, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.date,
          received: B.parsedType
        }), e.INVALID;
      }
      if (isNaN(p.data.getTime())) {
        const B = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(B, {
          code: a.ZodIssueCode.invalid_date
        }), e.INVALID;
      }
      const b = new e.ParseStatus();
      let L;
      for (const B of this._def.checks)
        B.kind === "min" ? p.data.getTime() < B.value && (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.too_small,
          message: B.message,
          inclusive: !0,
          exact: !1,
          minimum: B.value,
          type: "date"
        }), b.dirty()) : B.kind === "max" ? p.data.getTime() > B.value && (L = this._getOrReturnCtx(p, L), (0, e.addIssueToContext)(L, {
          code: a.ZodIssueCode.too_big,
          message: B.message,
          inclusive: !0,
          exact: !1,
          maximum: B.value,
          type: "date"
        }), b.dirty()) : l.util.assertNever(B);
      return {
        status: b.value,
        value: new Date(p.data.getTime())
      };
    }
    _addCheck(p) {
      return new Xe({
        ...this._def,
        checks: [...this._def.checks, p]
      });
    }
    min(p, x) {
      return this._addCheck({
        kind: "min",
        value: p.getTime(),
        message: o.errorUtil.toString(x)
      });
    }
    max(p, x) {
      return this._addCheck({
        kind: "max",
        value: p.getTime(),
        message: o.errorUtil.toString(x)
      });
    }
    get minDate() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "min" && (p === null || x.value > p) && (p = x.value);
      return p != null ? new Date(p) : null;
    }
    get maxDate() {
      let p = null;
      for (const x of this._def.checks)
        x.kind === "max" && (p === null || x.value < p) && (p = x.value);
      return p != null ? new Date(p) : null;
    }
  }
  I.ZodDate = Xe, Xe.create = (_) => new Xe({
    checks: [],
    coerce: (_ == null ? void 0 : _.coerce) || !1,
    typeName: se.ZodDate,
    ...m(_)
  });
  class Je extends g {
    _parse(p) {
      if (this._getType(p) !== l.ZodParsedType.symbol) {
        const b = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.symbol,
          received: b.parsedType
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
  }
  I.ZodSymbol = Je, Je.create = (_) => new Je({
    typeName: se.ZodSymbol,
    ...m(_)
  });
  class ke extends g {
    _parse(p) {
      if (this._getType(p) !== l.ZodParsedType.undefined) {
        const b = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.undefined,
          received: b.parsedType
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
  }
  I.ZodUndefined = ke, ke.create = (_) => new ke({
    typeName: se.ZodUndefined,
    ...m(_)
  });
  class Ge extends g {
    _parse(p) {
      if (this._getType(p) !== l.ZodParsedType.null) {
        const b = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.null,
          received: b.parsedType
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
  }
  I.ZodNull = Ge, Ge.create = (_) => new Ge({
    typeName: se.ZodNull,
    ...m(_)
  });
  class Fe extends g {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(p) {
      return (0, e.OK)(p.data);
    }
  }
  I.ZodAny = Fe, Fe.create = (_) => new Fe({
    typeName: se.ZodAny,
    ...m(_)
  });
  class Se extends g {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(p) {
      return (0, e.OK)(p.data);
    }
  }
  I.ZodUnknown = Se, Se.create = (_) => new Se({
    typeName: se.ZodUnknown,
    ...m(_)
  });
  class Oe extends g {
    _parse(p) {
      const x = this._getOrReturnCtx(p);
      return (0, e.addIssueToContext)(x, {
        code: a.ZodIssueCode.invalid_type,
        expected: l.ZodParsedType.never,
        received: x.parsedType
      }), e.INVALID;
    }
  }
  I.ZodNever = Oe, Oe.create = (_) => new Oe({
    typeName: se.ZodNever,
    ...m(_)
  });
  class it extends g {
    _parse(p) {
      if (this._getType(p) !== l.ZodParsedType.undefined) {
        const b = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.void,
          received: b.parsedType
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
  }
  I.ZodVoid = it, it.create = (_) => new it({
    typeName: se.ZodVoid,
    ...m(_)
  });
  class Te extends g {
    _parse(p) {
      const { ctx: x, status: b } = this._processInputParams(p), L = this._def;
      if (x.parsedType !== l.ZodParsedType.array)
        return (0, e.addIssueToContext)(x, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.array,
          received: x.parsedType
        }), e.INVALID;
      if (L.exactLength !== null) {
        const $ = x.data.length > L.exactLength.value, M = x.data.length < L.exactLength.value;
        ($ || M) && ((0, e.addIssueToContext)(x, {
          code: $ ? a.ZodIssueCode.too_big : a.ZodIssueCode.too_small,
          minimum: M ? L.exactLength.value : void 0,
          maximum: $ ? L.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: L.exactLength.message
        }), b.dirty());
      }
      if (L.minLength !== null && x.data.length < L.minLength.value && ((0, e.addIssueToContext)(x, {
        code: a.ZodIssueCode.too_small,
        minimum: L.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: L.minLength.message
      }), b.dirty()), L.maxLength !== null && x.data.length > L.maxLength.value && ((0, e.addIssueToContext)(x, {
        code: a.ZodIssueCode.too_big,
        maximum: L.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: L.maxLength.message
      }), b.dirty()), x.common.async)
        return Promise.all([...x.data].map(($, M) => L.type._parseAsync(new u(x, $, x.path, M)))).then(($) => e.ParseStatus.mergeArray(b, $));
      const B = [...x.data].map(($, M) => L.type._parseSync(new u(x, $, x.path, M)));
      return e.ParseStatus.mergeArray(b, B);
    }
    get element() {
      return this._def.type;
    }
    min(p, x) {
      return new Te({
        ...this._def,
        minLength: { value: p, message: o.errorUtil.toString(x) }
      });
    }
    max(p, x) {
      return new Te({
        ...this._def,
        maxLength: { value: p, message: o.errorUtil.toString(x) }
      });
    }
    length(p, x) {
      return new Te({
        ...this._def,
        exactLength: { value: p, message: o.errorUtil.toString(x) }
      });
    }
    nonempty(p) {
      return this.min(1, p);
    }
  }
  I.ZodArray = Te, Te.create = (_, p) => new Te({
    type: _,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: se.ZodArray,
    ...m(p)
  });
  function Qe(_) {
    if (_ instanceof be) {
      const p = {};
      for (const x in _.shape) {
        const b = _.shape[x];
        p[x] = He.create(Qe(b));
      }
      return new be({
        ..._._def,
        shape: () => p
      });
    } else return _ instanceof Te ? new Te({
      ..._._def,
      type: Qe(_.element)
    }) : _ instanceof He ? He.create(Qe(_.unwrap())) : _ instanceof Ze ? Ze.create(Qe(_.unwrap())) : _ instanceof Ve ? Ve.create(_.items.map((p) => Qe(p))) : _;
  }
  class be extends g {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const p = this._def.shape(), x = l.util.objectKeys(p);
      return this._cached = { shape: p, keys: x };
    }
    _parse(p) {
      if (this._getType(p) !== l.ZodParsedType.object) {
        const re = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(re, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.object,
          received: re.parsedType
        }), e.INVALID;
      }
      const { status: b, ctx: L } = this._processInputParams(p), { shape: B, keys: $ } = this._getCached(), M = [];
      if (!(this._def.catchall instanceof Oe && this._def.unknownKeys === "strip"))
        for (const re in L.data)
          $.includes(re) || M.push(re);
      const ie = [];
      for (const re of $) {
        const pe = B[re], gt = L.data[re];
        ie.push({
          key: { status: "valid", value: re },
          value: pe._parse(new u(L, gt, L.path, re)),
          alwaysSet: re in L.data
        });
      }
      if (this._def.catchall instanceof Oe) {
        const re = this._def.unknownKeys;
        if (re === "passthrough")
          for (const pe of M)
            ie.push({
              key: { status: "valid", value: pe },
              value: { status: "valid", value: L.data[pe] }
            });
        else if (re === "strict")
          M.length > 0 && ((0, e.addIssueToContext)(L, {
            code: a.ZodIssueCode.unrecognized_keys,
            keys: M
          }), b.dirty());
        else if (re !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const re = this._def.catchall;
        for (const pe of M) {
          const gt = L.data[pe];
          ie.push({
            key: { status: "valid", value: pe },
            value: re._parse(
              new u(L, gt, L.path, pe)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: pe in L.data
          });
        }
      }
      return L.common.async ? Promise.resolve().then(async () => {
        const re = [];
        for (const pe of ie) {
          const gt = await pe.key, os = await pe.value;
          re.push({
            key: gt,
            value: os,
            alwaysSet: pe.alwaysSet
          });
        }
        return re;
      }).then((re) => e.ParseStatus.mergeObjectSync(b, re)) : e.ParseStatus.mergeObjectSync(b, ie);
    }
    get shape() {
      return this._def.shape();
    }
    strict(p) {
      return o.errorUtil.errToObj, new be({
        ...this._def,
        unknownKeys: "strict",
        ...p !== void 0 ? {
          errorMap: (x, b) => {
            var L, B, $, M;
            const ie = ($ = (B = (L = this._def).errorMap) === null || B === void 0 ? void 0 : B.call(L, x, b).message) !== null && $ !== void 0 ? $ : b.defaultError;
            return x.code === "unrecognized_keys" ? {
              message: (M = o.errorUtil.errToObj(p).message) !== null && M !== void 0 ? M : ie
            } : {
              message: ie
            };
          }
        } : {}
      });
    }
    strip() {
      return new be({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new be({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(p) {
      return new be({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...p
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(p) {
      return new be({
        unknownKeys: p._def.unknownKeys,
        catchall: p._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...p._def.shape()
        }),
        typeName: se.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(p, x) {
      return this.augment({ [p]: x });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(p) {
      return new be({
        ...this._def,
        catchall: p
      });
    }
    pick(p) {
      const x = {};
      return l.util.objectKeys(p).forEach((b) => {
        p[b] && this.shape[b] && (x[b] = this.shape[b]);
      }), new be({
        ...this._def,
        shape: () => x
      });
    }
    omit(p) {
      const x = {};
      return l.util.objectKeys(this.shape).forEach((b) => {
        p[b] || (x[b] = this.shape[b]);
      }), new be({
        ...this._def,
        shape: () => x
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return Qe(this);
    }
    partial(p) {
      const x = {};
      return l.util.objectKeys(this.shape).forEach((b) => {
        const L = this.shape[b];
        p && !p[b] ? x[b] = L : x[b] = L.optional();
      }), new be({
        ...this._def,
        shape: () => x
      });
    }
    required(p) {
      const x = {};
      return l.util.objectKeys(this.shape).forEach((b) => {
        if (p && !p[b])
          x[b] = this.shape[b];
        else {
          let B = this.shape[b];
          for (; B instanceof He; )
            B = B._def.innerType;
          x[b] = B;
        }
      }), new be({
        ...this._def,
        shape: () => x
      });
    }
    keyof() {
      return Bt(l.util.objectKeys(this.shape));
    }
  }
  I.ZodObject = be, be.create = (_, p) => new be({
    shape: () => _,
    unknownKeys: "strip",
    catchall: Oe.create(),
    typeName: se.ZodObject,
    ...m(p)
  }), be.strictCreate = (_, p) => new be({
    shape: () => _,
    unknownKeys: "strict",
    catchall: Oe.create(),
    typeName: se.ZodObject,
    ...m(p)
  }), be.lazycreate = (_, p) => new be({
    shape: _,
    unknownKeys: "strip",
    catchall: Oe.create(),
    typeName: se.ZodObject,
    ...m(p)
  });
  class we extends g {
    _parse(p) {
      const { ctx: x } = this._processInputParams(p), b = this._def.options;
      function L(B) {
        for (const M of B)
          if (M.result.status === "valid")
            return M.result;
        for (const M of B)
          if (M.result.status === "dirty")
            return x.common.issues.push(...M.ctx.common.issues), M.result;
        const $ = B.map((M) => new a.ZodError(M.ctx.common.issues));
        return (0, e.addIssueToContext)(x, {
          code: a.ZodIssueCode.invalid_union,
          unionErrors: $
        }), e.INVALID;
      }
      if (x.common.async)
        return Promise.all(b.map(async (B) => {
          const $ = {
            ...x,
            common: {
              ...x.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await B._parseAsync({
              data: x.data,
              path: x.path,
              parent: $
            }),
            ctx: $
          };
        })).then(L);
      {
        let B;
        const $ = [];
        for (const ie of b) {
          const re = {
            ...x,
            common: {
              ...x.common,
              issues: []
            },
            parent: null
          }, pe = ie._parseSync({
            data: x.data,
            path: x.path,
            parent: re
          });
          if (pe.status === "valid")
            return pe;
          pe.status === "dirty" && !B && (B = { result: pe, ctx: re }), re.common.issues.length && $.push(re.common.issues);
        }
        if (B)
          return x.common.issues.push(...B.ctx.common.issues), B.result;
        const M = $.map((ie) => new a.ZodError(ie));
        return (0, e.addIssueToContext)(x, {
          code: a.ZodIssueCode.invalid_union,
          unionErrors: M
        }), e.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  I.ZodUnion = we, we.create = (_, p) => new we({
    options: _,
    typeName: se.ZodUnion,
    ...m(p)
  });
  const Pe = (_) => _ instanceof pt ? Pe(_.schema) : _ instanceof $e ? Pe(_.innerType()) : _ instanceof ft ? [_.value] : _ instanceof et ? _.options : _ instanceof yt ? l.util.objectValues(_.enum) : _ instanceof _t ? Pe(_._def.innerType) : _ instanceof ke ? [void 0] : _ instanceof Ge ? [null] : _ instanceof He ? [void 0, ...Pe(_.unwrap())] : _ instanceof Ze ? [null, ...Pe(_.unwrap())] : _ instanceof Tt || _ instanceof Me ? Pe(_.unwrap()) : _ instanceof Ct ? Pe(_._def.innerType) : [];
  class nt extends g {
    _parse(p) {
      const { ctx: x } = this._processInputParams(p);
      if (x.parsedType !== l.ZodParsedType.object)
        return (0, e.addIssueToContext)(x, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.object,
          received: x.parsedType
        }), e.INVALID;
      const b = this.discriminator, L = x.data[b], B = this.optionsMap.get(L);
      return B ? x.common.async ? B._parseAsync({
        data: x.data,
        path: x.path,
        parent: x
      }) : B._parseSync({
        data: x.data,
        path: x.path,
        parent: x
      }) : ((0, e.addIssueToContext)(x, {
        code: a.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [b]
      }), e.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(p, x, b) {
      const L = /* @__PURE__ */ new Map();
      for (const B of x) {
        const $ = Pe(B.shape[p]);
        if (!$.length)
          throw new Error(`A discriminator value for key \`${p}\` could not be extracted from all schema options`);
        for (const M of $) {
          if (L.has(M))
            throw new Error(`Discriminator property ${String(p)} has duplicate value ${String(M)}`);
          L.set(M, B);
        }
      }
      return new nt({
        typeName: se.ZodDiscriminatedUnion,
        discriminator: p,
        options: x,
        optionsMap: L,
        ...m(b)
      });
    }
  }
  I.ZodDiscriminatedUnion = nt;
  function Ue(_, p) {
    const x = (0, l.getParsedType)(_), b = (0, l.getParsedType)(p);
    if (_ === p)
      return { valid: !0, data: _ };
    if (x === l.ZodParsedType.object && b === l.ZodParsedType.object) {
      const L = l.util.objectKeys(p), B = l.util.objectKeys(_).filter((M) => L.indexOf(M) !== -1), $ = { ..._, ...p };
      for (const M of B) {
        const ie = Ue(_[M], p[M]);
        if (!ie.valid)
          return { valid: !1 };
        $[M] = ie.data;
      }
      return { valid: !0, data: $ };
    } else if (x === l.ZodParsedType.array && b === l.ZodParsedType.array) {
      if (_.length !== p.length)
        return { valid: !1 };
      const L = [];
      for (let B = 0; B < _.length; B++) {
        const $ = _[B], M = p[B], ie = Ue($, M);
        if (!ie.valid)
          return { valid: !1 };
        L.push(ie.data);
      }
      return { valid: !0, data: L };
    } else return x === l.ZodParsedType.date && b === l.ZodParsedType.date && +_ == +p ? { valid: !0, data: _ } : { valid: !1 };
  }
  class st extends g {
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p), L = (B, $) => {
        if ((0, e.isAborted)(B) || (0, e.isAborted)($))
          return e.INVALID;
        const M = Ue(B.value, $.value);
        return M.valid ? (((0, e.isDirty)(B) || (0, e.isDirty)($)) && x.dirty(), { status: x.value, value: M.data }) : ((0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_intersection_types
        }), e.INVALID);
      };
      return b.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: b.data,
          path: b.path,
          parent: b
        }),
        this._def.right._parseAsync({
          data: b.data,
          path: b.path,
          parent: b
        })
      ]).then(([B, $]) => L(B, $)) : L(this._def.left._parseSync({
        data: b.data,
        path: b.path,
        parent: b
      }), this._def.right._parseSync({
        data: b.data,
        path: b.path,
        parent: b
      }));
    }
  }
  I.ZodIntersection = st, st.create = (_, p, x) => new st({
    left: _,
    right: p,
    typeName: se.ZodIntersection,
    ...m(x)
  });
  class Ve extends g {
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p);
      if (b.parsedType !== l.ZodParsedType.array)
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.array,
          received: b.parsedType
        }), e.INVALID;
      if (b.data.length < this._def.items.length)
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), e.INVALID;
      !this._def.rest && b.data.length > this._def.items.length && ((0, e.addIssueToContext)(b, {
        code: a.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), x.dirty());
      const B = [...b.data].map(($, M) => {
        const ie = this._def.items[M] || this._def.rest;
        return ie ? ie._parse(new u(b, $, b.path, M)) : null;
      }).filter(($) => !!$);
      return b.common.async ? Promise.all(B).then(($) => e.ParseStatus.mergeArray(x, $)) : e.ParseStatus.mergeArray(x, B);
    }
    get items() {
      return this._def.items;
    }
    rest(p) {
      return new Ve({
        ...this._def,
        rest: p
      });
    }
  }
  I.ZodTuple = Ve, Ve.create = (_, p) => {
    if (!Array.isArray(_))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Ve({
      items: _,
      typeName: se.ZodTuple,
      rest: null,
      ...m(p)
    });
  };
  class X extends g {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p);
      if (b.parsedType !== l.ZodParsedType.object)
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.object,
          received: b.parsedType
        }), e.INVALID;
      const L = [], B = this._def.keyType, $ = this._def.valueType;
      for (const M in b.data)
        L.push({
          key: B._parse(new u(b, M, b.path, M)),
          value: $._parse(new u(b, b.data[M], b.path, M)),
          alwaysSet: M in b.data
        });
      return b.common.async ? e.ParseStatus.mergeObjectAsync(x, L) : e.ParseStatus.mergeObjectSync(x, L);
    }
    get element() {
      return this._def.valueType;
    }
    static create(p, x, b) {
      return x instanceof g ? new X({
        keyType: p,
        valueType: x,
        typeName: se.ZodRecord,
        ...m(b)
      }) : new X({
        keyType: Ce.create(),
        valueType: p,
        typeName: se.ZodRecord,
        ...m(x)
      });
    }
  }
  I.ZodRecord = X;
  class dt extends g {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p);
      if (b.parsedType !== l.ZodParsedType.map)
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.map,
          received: b.parsedType
        }), e.INVALID;
      const L = this._def.keyType, B = this._def.valueType, $ = [...b.data.entries()].map(([M, ie], re) => ({
        key: L._parse(new u(b, M, b.path, [re, "key"])),
        value: B._parse(new u(b, ie, b.path, [re, "value"]))
      }));
      if (b.common.async) {
        const M = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const ie of $) {
            const re = await ie.key, pe = await ie.value;
            if (re.status === "aborted" || pe.status === "aborted")
              return e.INVALID;
            (re.status === "dirty" || pe.status === "dirty") && x.dirty(), M.set(re.value, pe.value);
          }
          return { status: x.value, value: M };
        });
      } else {
        const M = /* @__PURE__ */ new Map();
        for (const ie of $) {
          const re = ie.key, pe = ie.value;
          if (re.status === "aborted" || pe.status === "aborted")
            return e.INVALID;
          (re.status === "dirty" || pe.status === "dirty") && x.dirty(), M.set(re.value, pe.value);
        }
        return { status: x.value, value: M };
      }
    }
  }
  I.ZodMap = dt, dt.create = (_, p, x) => new dt({
    valueType: p,
    keyType: _,
    typeName: se.ZodMap,
    ...m(x)
  });
  class Ye extends g {
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p);
      if (b.parsedType !== l.ZodParsedType.set)
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.set,
          received: b.parsedType
        }), e.INVALID;
      const L = this._def;
      L.minSize !== null && b.data.size < L.minSize.value && ((0, e.addIssueToContext)(b, {
        code: a.ZodIssueCode.too_small,
        minimum: L.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: L.minSize.message
      }), x.dirty()), L.maxSize !== null && b.data.size > L.maxSize.value && ((0, e.addIssueToContext)(b, {
        code: a.ZodIssueCode.too_big,
        maximum: L.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: L.maxSize.message
      }), x.dirty());
      const B = this._def.valueType;
      function $(ie) {
        const re = /* @__PURE__ */ new Set();
        for (const pe of ie) {
          if (pe.status === "aborted")
            return e.INVALID;
          pe.status === "dirty" && x.dirty(), re.add(pe.value);
        }
        return { status: x.value, value: re };
      }
      const M = [...b.data.values()].map((ie, re) => B._parse(new u(b, ie, b.path, re)));
      return b.common.async ? Promise.all(M).then((ie) => $(ie)) : $(M);
    }
    min(p, x) {
      return new Ye({
        ...this._def,
        minSize: { value: p, message: o.errorUtil.toString(x) }
      });
    }
    max(p, x) {
      return new Ye({
        ...this._def,
        maxSize: { value: p, message: o.errorUtil.toString(x) }
      });
    }
    size(p, x) {
      return this.min(p, x).max(p, x);
    }
    nonempty(p) {
      return this.min(1, p);
    }
  }
  I.ZodSet = Ye, Ye.create = (_, p) => new Ye({
    valueType: _,
    minSize: null,
    maxSize: null,
    typeName: se.ZodSet,
    ...m(p)
  });
  class z extends g {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(p) {
      const { ctx: x } = this._processInputParams(p);
      if (x.parsedType !== l.ZodParsedType.function)
        return (0, e.addIssueToContext)(x, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.function,
          received: x.parsedType
        }), e.INVALID;
      function b(M, ie) {
        return (0, e.makeIssue)({
          data: M,
          path: x.path,
          errorMaps: [
            x.common.contextualErrorMap,
            x.schemaErrorMap,
            (0, s.getErrorMap)(),
            s.defaultErrorMap
          ].filter((re) => !!re),
          issueData: {
            code: a.ZodIssueCode.invalid_arguments,
            argumentsError: ie
          }
        });
      }
      function L(M, ie) {
        return (0, e.makeIssue)({
          data: M,
          path: x.path,
          errorMaps: [
            x.common.contextualErrorMap,
            x.schemaErrorMap,
            (0, s.getErrorMap)(),
            s.defaultErrorMap
          ].filter((re) => !!re),
          issueData: {
            code: a.ZodIssueCode.invalid_return_type,
            returnTypeError: ie
          }
        });
      }
      const B = { errorMap: x.common.contextualErrorMap }, $ = x.data;
      if (this._def.returns instanceof ot) {
        const M = this;
        return (0, e.OK)(async function(...ie) {
          const re = new a.ZodError([]), pe = await M._def.args.parseAsync(ie, B).catch((su) => {
            throw re.addIssue(b(ie, su)), re;
          }), gt = await Reflect.apply($, this, pe);
          return await M._def.returns._def.type.parseAsync(gt, B).catch((su) => {
            throw re.addIssue(L(gt, su)), re;
          });
        });
      } else {
        const M = this;
        return (0, e.OK)(function(...ie) {
          const re = M._def.args.safeParse(ie, B);
          if (!re.success)
            throw new a.ZodError([b(ie, re.error)]);
          const pe = Reflect.apply($, this, re.data), gt = M._def.returns.safeParse(pe, B);
          if (!gt.success)
            throw new a.ZodError([L(pe, gt.error)]);
          return gt.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...p) {
      return new z({
        ...this._def,
        args: Ve.create(p).rest(Se.create())
      });
    }
    returns(p) {
      return new z({
        ...this._def,
        returns: p
      });
    }
    implement(p) {
      return this.parse(p);
    }
    strictImplement(p) {
      return this.parse(p);
    }
    static create(p, x, b) {
      return new z({
        args: p || Ve.create([]).rest(Se.create()),
        returns: x || Se.create(),
        typeName: se.ZodFunction,
        ...m(b)
      });
    }
  }
  I.ZodFunction = z;
  class pt extends g {
    get schema() {
      return this._def.getter();
    }
    _parse(p) {
      const { ctx: x } = this._processInputParams(p);
      return this._def.getter()._parse({ data: x.data, path: x.path, parent: x });
    }
  }
  I.ZodLazy = pt, pt.create = (_, p) => new pt({
    getter: _,
    typeName: se.ZodLazy,
    ...m(p)
  });
  class ft extends g {
    _parse(p) {
      if (p.data !== this._def.value) {
        const x = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(x, {
          received: x.data,
          code: a.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), e.INVALID;
      }
      return { status: "valid", value: p.data };
    }
    get value() {
      return this._def.value;
    }
  }
  I.ZodLiteral = ft, ft.create = (_, p) => new ft({
    value: _,
    typeName: se.ZodLiteral,
    ...m(p)
  });
  function Bt(_, p) {
    return new et({
      values: _,
      typeName: se.ZodEnum,
      ...m(p)
    });
  }
  class et extends g {
    constructor() {
      super(...arguments), i.set(this, void 0);
    }
    _parse(p) {
      if (typeof p.data != "string") {
        const x = this._getOrReturnCtx(p), b = this._def.values;
        return (0, e.addIssueToContext)(x, {
          expected: l.util.joinValues(b),
          received: x.parsedType,
          code: a.ZodIssueCode.invalid_type
        }), e.INVALID;
      }
      if (r(this, i, "f") || t(this, i, new Set(this._def.values), "f"), !r(this, i, "f").has(p.data)) {
        const x = this._getOrReturnCtx(p), b = this._def.values;
        return (0, e.addIssueToContext)(x, {
          received: x.data,
          code: a.ZodIssueCode.invalid_enum_value,
          options: b
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const p = {};
      for (const x of this._def.values)
        p[x] = x;
      return p;
    }
    get Values() {
      const p = {};
      for (const x of this._def.values)
        p[x] = x;
      return p;
    }
    get Enum() {
      const p = {};
      for (const x of this._def.values)
        p[x] = x;
      return p;
    }
    extract(p, x = this._def) {
      return et.create(p, {
        ...this._def,
        ...x
      });
    }
    exclude(p, x = this._def) {
      return et.create(this.options.filter((b) => !p.includes(b)), {
        ...this._def,
        ...x
      });
    }
  }
  I.ZodEnum = et, i = /* @__PURE__ */ new WeakMap(), et.create = Bt;
  class yt extends g {
    constructor() {
      super(...arguments), n.set(this, void 0);
    }
    _parse(p) {
      const x = l.util.getValidEnumValues(this._def.values), b = this._getOrReturnCtx(p);
      if (b.parsedType !== l.ZodParsedType.string && b.parsedType !== l.ZodParsedType.number) {
        const L = l.util.objectValues(x);
        return (0, e.addIssueToContext)(b, {
          expected: l.util.joinValues(L),
          received: b.parsedType,
          code: a.ZodIssueCode.invalid_type
        }), e.INVALID;
      }
      if (r(this, n, "f") || t(this, n, new Set(l.util.getValidEnumValues(this._def.values)), "f"), !r(this, n, "f").has(p.data)) {
        const L = l.util.objectValues(x);
        return (0, e.addIssueToContext)(b, {
          received: b.data,
          code: a.ZodIssueCode.invalid_enum_value,
          options: L
        }), e.INVALID;
      }
      return (0, e.OK)(p.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  I.ZodNativeEnum = yt, n = /* @__PURE__ */ new WeakMap(), yt.create = (_, p) => new yt({
    values: _,
    typeName: se.ZodNativeEnum,
    ...m(p)
  });
  class ot extends g {
    unwrap() {
      return this._def.type;
    }
    _parse(p) {
      const { ctx: x } = this._processInputParams(p);
      if (x.parsedType !== l.ZodParsedType.promise && x.common.async === !1)
        return (0, e.addIssueToContext)(x, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.promise,
          received: x.parsedType
        }), e.INVALID;
      const b = x.parsedType === l.ZodParsedType.promise ? x.data : Promise.resolve(x.data);
      return (0, e.OK)(b.then((L) => this._def.type.parseAsync(L, {
        path: x.path,
        errorMap: x.common.contextualErrorMap
      })));
    }
  }
  I.ZodPromise = ot, ot.create = (_, p) => new ot({
    type: _,
    typeName: se.ZodPromise,
    ...m(p)
  });
  class $e extends g {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === se.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p), L = this._def.effect || null, B = {
        addIssue: ($) => {
          (0, e.addIssueToContext)(b, $), $.fatal ? x.abort() : x.dirty();
        },
        get path() {
          return b.path;
        }
      };
      if (B.addIssue = B.addIssue.bind(B), L.type === "preprocess") {
        const $ = L.transform(b.data, B);
        if (b.common.async)
          return Promise.resolve($).then(async (M) => {
            if (x.value === "aborted")
              return e.INVALID;
            const ie = await this._def.schema._parseAsync({
              data: M,
              path: b.path,
              parent: b
            });
            return ie.status === "aborted" ? e.INVALID : ie.status === "dirty" || x.value === "dirty" ? (0, e.DIRTY)(ie.value) : ie;
          });
        {
          if (x.value === "aborted")
            return e.INVALID;
          const M = this._def.schema._parseSync({
            data: $,
            path: b.path,
            parent: b
          });
          return M.status === "aborted" ? e.INVALID : M.status === "dirty" || x.value === "dirty" ? (0, e.DIRTY)(M.value) : M;
        }
      }
      if (L.type === "refinement") {
        const $ = (M) => {
          const ie = L.refinement(M, B);
          if (b.common.async)
            return Promise.resolve(ie);
          if (ie instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return M;
        };
        if (b.common.async === !1) {
          const M = this._def.schema._parseSync({
            data: b.data,
            path: b.path,
            parent: b
          });
          return M.status === "aborted" ? e.INVALID : (M.status === "dirty" && x.dirty(), $(M.value), { status: x.value, value: M.value });
        } else
          return this._def.schema._parseAsync({ data: b.data, path: b.path, parent: b }).then((M) => M.status === "aborted" ? e.INVALID : (M.status === "dirty" && x.dirty(), $(M.value).then(() => ({ status: x.value, value: M.value }))));
      }
      if (L.type === "transform")
        if (b.common.async === !1) {
          const $ = this._def.schema._parseSync({
            data: b.data,
            path: b.path,
            parent: b
          });
          if (!(0, e.isValid)($))
            return $;
          const M = L.transform($.value, B);
          if (M instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: x.value, value: M };
        } else
          return this._def.schema._parseAsync({ data: b.data, path: b.path, parent: b }).then(($) => (0, e.isValid)($) ? Promise.resolve(L.transform($.value, B)).then((M) => ({ status: x.value, value: M })) : $);
      l.util.assertNever(L);
    }
  }
  I.ZodEffects = $e, I.ZodTransformer = $e, $e.create = (_, p, x) => new $e({
    schema: _,
    typeName: se.ZodEffects,
    effect: p,
    ...m(x)
  }), $e.createWithPreprocess = (_, p, x) => new $e({
    schema: p,
    effect: { type: "preprocess", transform: _ },
    typeName: se.ZodEffects,
    ...m(x)
  });
  class He extends g {
    _parse(p) {
      return this._getType(p) === l.ZodParsedType.undefined ? (0, e.OK)(void 0) : this._def.innerType._parse(p);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  I.ZodOptional = He, He.create = (_, p) => new He({
    innerType: _,
    typeName: se.ZodOptional,
    ...m(p)
  });
  class Ze extends g {
    _parse(p) {
      return this._getType(p) === l.ZodParsedType.null ? (0, e.OK)(null) : this._def.innerType._parse(p);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  I.ZodNullable = Ze, Ze.create = (_, p) => new Ze({
    innerType: _,
    typeName: se.ZodNullable,
    ...m(p)
  });
  class _t extends g {
    _parse(p) {
      const { ctx: x } = this._processInputParams(p);
      let b = x.data;
      return x.parsedType === l.ZodParsedType.undefined && (b = this._def.defaultValue()), this._def.innerType._parse({
        data: b,
        path: x.path,
        parent: x
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  I.ZodDefault = _t, _t.create = (_, p) => new _t({
    innerType: _,
    typeName: se.ZodDefault,
    defaultValue: typeof p.default == "function" ? p.default : () => p.default,
    ...m(p)
  });
  class Ct extends g {
    _parse(p) {
      const { ctx: x } = this._processInputParams(p), b = {
        ...x,
        common: {
          ...x.common,
          issues: []
        }
      }, L = this._def.innerType._parse({
        data: b.data,
        path: b.path,
        parent: {
          ...b
        }
      });
      return (0, e.isAsync)(L) ? L.then((B) => ({
        status: "valid",
        value: B.status === "valid" ? B.value : this._def.catchValue({
          get error() {
            return new a.ZodError(b.common.issues);
          },
          input: b.data
        })
      })) : {
        status: "valid",
        value: L.status === "valid" ? L.value : this._def.catchValue({
          get error() {
            return new a.ZodError(b.common.issues);
          },
          input: b.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  I.ZodCatch = Ct, Ct.create = (_, p) => new Ct({
    innerType: _,
    typeName: se.ZodCatch,
    catchValue: typeof p.catch == "function" ? p.catch : () => p.catch,
    ...m(p)
  });
  class mt extends g {
    _parse(p) {
      if (this._getType(p) !== l.ZodParsedType.nan) {
        const b = this._getOrReturnCtx(p);
        return (0, e.addIssueToContext)(b, {
          code: a.ZodIssueCode.invalid_type,
          expected: l.ZodParsedType.nan,
          received: b.parsedType
        }), e.INVALID;
      }
      return { status: "valid", value: p.data };
    }
  }
  I.ZodNaN = mt, mt.create = (_) => new mt({
    typeName: se.ZodNaN,
    ...m(_)
  }), I.BRAND = Symbol("zod_brand");
  class Tt extends g {
    _parse(p) {
      const { ctx: x } = this._processInputParams(p), b = x.data;
      return this._def.type._parse({
        data: b,
        path: x.path,
        parent: x
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  I.ZodBranded = Tt;
  class ht extends g {
    _parse(p) {
      const { status: x, ctx: b } = this._processInputParams(p);
      if (b.common.async)
        return (async () => {
          const B = await this._def.in._parseAsync({
            data: b.data,
            path: b.path,
            parent: b
          });
          return B.status === "aborted" ? e.INVALID : B.status === "dirty" ? (x.dirty(), (0, e.DIRTY)(B.value)) : this._def.out._parseAsync({
            data: B.value,
            path: b.path,
            parent: b
          });
        })();
      {
        const L = this._def.in._parseSync({
          data: b.data,
          path: b.path,
          parent: b
        });
        return L.status === "aborted" ? e.INVALID : L.status === "dirty" ? (x.dirty(), {
          status: "dirty",
          value: L.value
        }) : this._def.out._parseSync({
          data: L.value,
          path: b.path,
          parent: b
        });
      }
    }
    static create(p, x) {
      return new ht({
        in: p,
        out: x,
        typeName: se.ZodPipeline
      });
    }
  }
  I.ZodPipeline = ht;
  class Me extends g {
    _parse(p) {
      const x = this._def.innerType._parse(p), b = (L) => ((0, e.isValid)(L) && (L.value = Object.freeze(L.value)), L);
      return (0, e.isAsync)(x) ? x.then((L) => b(L)) : b(x);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  I.ZodReadonly = Me, Me.create = (_, p) => new Me({
    innerType: _,
    typeName: se.ZodReadonly,
    ...m(p)
  });
  function Pt(_, p) {
    const x = typeof _ == "function" ? _(p) : typeof _ == "string" ? { message: _ } : _;
    return typeof x == "string" ? { message: x } : x;
  }
  function Ut(_, p = {}, x) {
    return _ ? Fe.create().superRefine((b, L) => {
      var B, $;
      const M = _(b);
      if (M instanceof Promise)
        return M.then((ie) => {
          var re, pe;
          if (!ie) {
            const gt = Pt(p, b), os = (pe = (re = gt.fatal) !== null && re !== void 0 ? re : x) !== null && pe !== void 0 ? pe : !0;
            L.addIssue({ code: "custom", ...gt, fatal: os });
          }
        });
      if (!M) {
        const ie = Pt(p, b), re = ($ = (B = ie.fatal) !== null && B !== void 0 ? B : x) !== null && $ !== void 0 ? $ : !0;
        L.addIssue({ code: "custom", ...ie, fatal: re });
      }
    }) : Fe.create();
  }
  I.custom = Ut, I.late = {
    object: be.lazycreate
  };
  var se;
  (function(_) {
    _.ZodString = "ZodString", _.ZodNumber = "ZodNumber", _.ZodNaN = "ZodNaN", _.ZodBigInt = "ZodBigInt", _.ZodBoolean = "ZodBoolean", _.ZodDate = "ZodDate", _.ZodSymbol = "ZodSymbol", _.ZodUndefined = "ZodUndefined", _.ZodNull = "ZodNull", _.ZodAny = "ZodAny", _.ZodUnknown = "ZodUnknown", _.ZodNever = "ZodNever", _.ZodVoid = "ZodVoid", _.ZodArray = "ZodArray", _.ZodObject = "ZodObject", _.ZodUnion = "ZodUnion", _.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", _.ZodIntersection = "ZodIntersection", _.ZodTuple = "ZodTuple", _.ZodRecord = "ZodRecord", _.ZodMap = "ZodMap", _.ZodSet = "ZodSet", _.ZodFunction = "ZodFunction", _.ZodLazy = "ZodLazy", _.ZodLiteral = "ZodLiteral", _.ZodEnum = "ZodEnum", _.ZodEffects = "ZodEffects", _.ZodNativeEnum = "ZodNativeEnum", _.ZodOptional = "ZodOptional", _.ZodNullable = "ZodNullable", _.ZodDefault = "ZodDefault", _.ZodCatch = "ZodCatch", _.ZodPromise = "ZodPromise", _.ZodBranded = "ZodBranded", _.ZodPipeline = "ZodPipeline", _.ZodReadonly = "ZodReadonly";
  })(se || (I.ZodFirstPartyTypeKind = se = {}));
  const or = (_, p = {
    message: `Input not instance of ${_.name}`
  }) => Ut((x) => x instanceof _, p);
  I.instanceof = or;
  const Nt = Ce.create;
  I.string = Nt;
  const Vt = Ie.create;
  I.number = Vt;
  const Xt = mt.create;
  I.nan = Xt;
  const Ht = je.create;
  I.bigint = Ht;
  const Kt = qe.create;
  I.boolean = Kt;
  const ar = Xe.create;
  I.date = ar;
  const Zt = Je.create;
  I.symbol = Zt;
  const O = ke.create;
  I.undefined = O;
  const Cr = Ge.create;
  I.null = Cr;
  const Tr = Fe.create;
  I.any = Tr;
  const mr = Se.create;
  I.unknown = mr;
  const Sr = Oe.create;
  I.never = Sr;
  const P = it.create;
  I.void = P;
  const G = Te.create;
  I.array = G;
  const W = be.create;
  I.object = W;
  const de = be.strictCreate;
  I.strictObject = de;
  const ge = we.create;
  I.union = ge;
  const ve = nt.create;
  I.discriminatedUnion = ve;
  const ye = st.create;
  I.intersection = ye;
  const fe = Ve.create;
  I.tuple = fe;
  const Ke = X.create;
  I.record = Ke;
  const Ae = dt.create;
  I.map = Ae;
  const _e = Ye.create;
  I.set = _e;
  const We = z.create;
  I.function = We;
  const It = pt.create;
  I.lazy = It;
  const bt = ft.create;
  I.literal = bt;
  const Ne = et.create;
  I.enum = Ne;
  const ur = yt.create;
  I.nativeEnum = ur;
  const hr = ot.create;
  I.promise = hr;
  const br = $e.create;
  I.effect = br, I.transformer = br;
  const mi = He.create;
  I.optional = mi;
  const zr = Ze.create;
  I.nullable = zr;
  const Q = $e.createWithPreprocess;
  I.preprocess = Q;
  const d = ht.create;
  I.pipeline = d;
  const c = () => Nt().optional();
  I.ostring = c;
  const j = () => Vt().optional();
  I.onumber = j;
  const ee = () => Kt().optional();
  return I.oboolean = ee, I.coerce = {
    string: (_) => Ce.create({ ..._, coerce: !0 }),
    number: (_) => Ie.create({ ..._, coerce: !0 }),
    boolean: (_) => qe.create({
      ..._,
      coerce: !0
    }),
    bigint: (_) => je.create({ ..._, coerce: !0 }),
    date: (_) => Xe.create({ ..._, coerce: !0 })
  }, I.NEVER = e.INVALID, I;
}
var Yu;
function ec() {
  return Yu || (Yu = 1, function(r) {
    var t = Zr && Zr.__createBinding || (Object.create ? function(n, s, o, e) {
      e === void 0 && (e = o);
      var l = Object.getOwnPropertyDescriptor(s, o);
      (!l || ("get" in l ? !s.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return s[o];
      } }), Object.defineProperty(n, e, l);
    } : function(n, s, o, e) {
      e === void 0 && (e = o), n[e] = s[o];
    }), i = Zr && Zr.__exportStar || function(n, s) {
      for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && t(s, n, o);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), i(/* @__PURE__ */ Pu(), r), i(/* @__PURE__ */ _h(), r), i(/* @__PURE__ */ Yh(), r), i(/* @__PURE__ */ tu(), r), i(/* @__PURE__ */ tb(), r), i(/* @__PURE__ */ Bu(), r);
  }(Zr)), Zr;
}
var tc;
function fi() {
  return tc || (tc = 1, function(r) {
    var t = Wt && Wt.__createBinding || (Object.create ? function(e, l, a, u) {
      u === void 0 && (u = a);
      var f = Object.getOwnPropertyDescriptor(l, a);
      (!f || ("get" in f ? !l.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
        return l[a];
      } }), Object.defineProperty(e, u, f);
    } : function(e, l, a, u) {
      u === void 0 && (u = a), e[u] = l[a];
    }), i = Wt && Wt.__setModuleDefault || (Object.create ? function(e, l) {
      Object.defineProperty(e, "default", { enumerable: !0, value: l });
    } : function(e, l) {
      e.default = l;
    }), n = Wt && Wt.__importStar || function(e) {
      if (e && e.__esModule) return e;
      var l = {};
      if (e != null) for (var a in e) a !== "default" && Object.prototype.hasOwnProperty.call(e, a) && t(l, e, a);
      return i(l, e), l;
    }, s = Wt && Wt.__exportStar || function(e, l) {
      for (var a in e) a !== "default" && !Object.prototype.hasOwnProperty.call(l, a) && t(l, e, a);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.z = void 0;
    const o = n(/* @__PURE__ */ ec());
    r.z = o, s(/* @__PURE__ */ ec(), r), r.default = o;
  }(Wt)), Wt;
}
var Wr = {}, lu = {}, rc;
function Ch() {
  return rc || (rc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.DisallowedDomainError = r.UnsupportedDomainError = r.ReservedHandleError = r.InvalidHandleError = r.isValidTld = r.isValidHandle = r.normalizeAndEnsureValidHandle = r.normalizeHandle = r.ensureValidHandleRegex = r.ensureValidHandle = r.DISALLOWED_TLDS = r.INVALID_HANDLE = void 0, r.INVALID_HANDLE = "handle.invalid", r.DISALLOWED_TLDS = [
      ".local",
      ".arpa",
      ".invalid",
      ".localhost",
      ".internal",
      ".example",
      ".alt",
      // policy could concievably change on ".onion" some day
      ".onion"
      // NOTE: .test is allowed in testing and devopment. In practical terms
      // "should" "never" actually resolve and get registered in production
    ];
    const t = (m) => {
      if (!/^[a-zA-Z0-9.-]*$/.test(m))
        throw new l("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
      if (m.length > 253)
        throw new l("Handle is too long (253 chars max)");
      const g = m.split(".");
      if (g.length < 2)
        throw new l("Handle domain needs at least two parts");
      for (let A = 0; A < g.length; A++) {
        const v = g[A];
        if (v.length < 1)
          throw new l("Handle parts can not be empty");
        if (v.length > 63)
          throw new l("Handle part too long (max 63 chars)");
        if (v.endsWith("-") || v.startsWith("-"))
          throw new l("Handle parts can not start or end with hyphens");
        if (A + 1 === g.length && !/^[a-zA-Z]/.test(v))
          throw new l("Handle final component (TLD) must start with ASCII letter");
      }
    };
    r.ensureValidHandle = t;
    const i = (m) => {
      if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(m))
        throw new l("Handle didn't validate via regex");
      if (m.length > 253)
        throw new l("Handle is too long (253 chars max)");
    };
    r.ensureValidHandleRegex = i;
    const n = (m) => m.toLowerCase();
    r.normalizeHandle = n;
    const s = (m) => {
      const g = (0, r.normalizeHandle)(m);
      return (0, r.ensureValidHandle)(g), g;
    };
    r.normalizeAndEnsureValidHandle = s;
    const o = (m) => {
      try {
        (0, r.ensureValidHandle)(m);
      } catch (g) {
        if (g instanceof l)
          return !1;
        throw g;
      }
      return !0;
    };
    r.isValidHandle = o;
    const e = (m) => !r.DISALLOWED_TLDS.some((g) => m.endsWith(g));
    r.isValidTld = e;
    class l extends Error {
    }
    r.InvalidHandleError = l;
    class a extends Error {
    }
    r.ReservedHandleError = a;
    class u extends Error {
    }
    r.UnsupportedDomainError = u;
    class f extends Error {
    }
    r.DisallowedDomainError = f;
  }(lu)), lu;
}
var Er = {}, ic;
function Th() {
  if (ic) return Er;
  ic = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.InvalidDidError = Er.ensureValidDidRegex = Er.ensureValidDid = void 0;
  const r = (n) => {
    if (!n.startsWith("did:"))
      throw new i('DID requires "did:" prefix');
    if (!/^[a-zA-Z0-9._:%-]*$/.test(n))
      throw new i("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
    const { length: s, 1: o } = n.split(":");
    if (s < 3)
      throw new i("DID requires prefix, method, and method-specific content");
    if (!/^[a-z]+$/.test(o))
      throw new i("DID method must be lower-case letters");
    if (n.endsWith(":") || n.endsWith("%"))
      throw new i('DID can not end with ":" or "%"');
    if (n.length > 2 * 1024)
      throw new i("DID is too long (2048 chars max)");
  };
  Er.ensureValidDid = r;
  const t = (n) => {
    if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(n))
      throw new i("DID didn't validate via regex");
    if (n.length > 2 * 1024)
      throw new i("DID is too long (2048 chars max)");
  };
  Er.ensureValidDidRegex = t;
  class i extends Error {
  }
  return Er.InvalidDidError = i, Er;
}
var du = {}, nc;
function Sh() {
  return nc || (nc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.InvalidNsidError = r.ensureValidNsidRegex = r.ensureValidNsid = r.NSID = void 0;
    class t {
      static parse(e) {
        return new t(e);
      }
      static create(e, l) {
        const a = [...e.split(".").reverse(), l].join(".");
        return new t(a);
      }
      static isValid(e) {
        try {
          return t.parse(e), !0;
        } catch {
          return !1;
        }
      }
      constructor(e) {
        Object.defineProperty(this, "segments", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: []
        }), (0, r.ensureValidNsid)(e), this.segments = e.split(".");
      }
      get authority() {
        return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
      }
      get name() {
        return this.segments.at(this.segments.length - 1);
      }
      toString() {
        return this.segments.join(".");
      }
    }
    r.NSID = t;
    const i = (o) => {
      const e = o;
      if (!/^[a-zA-Z0-9.-]*$/.test(e))
        throw new s("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
      if (e.length > 317)
        throw new s("NSID is too long (317 chars max)");
      const l = e.split(".");
      if (l.length < 3)
        throw new s("NSID needs at least three parts");
      for (let a = 0; a < l.length; a++) {
        const u = l[a];
        if (u.length < 1)
          throw new s("NSID parts can not be empty");
        if (u.length > 63)
          throw new s("NSID part too long (max 63 chars)");
        if (u.endsWith("-") || u.startsWith("-"))
          throw new s("NSID parts can not start or end with hyphen");
        if (/^[0-9]/.test(u) && a === 0)
          throw new s("NSID first part may not start with a digit");
        if (!/^[a-zA-Z][a-zA-Z0-9]*$/.test(u) && a + 1 === l.length)
          throw new s("NSID name part must be only letters and digits (and no leading digit)");
      }
    };
    r.ensureValidNsid = i;
    const n = (o) => {
      if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z0-9]{0,62})?)$/.test(o))
        throw new s("NSID didn't validate via regex");
      if (o.length > 317)
        throw new s("NSID is too long (317 chars max)");
    };
    r.ensureValidNsidRegex = n;
    class s extends Error {
    }
    r.InvalidNsidError = s;
  }(du)), du;
}
var Jr = {}, Qr = {}, sc;
function rb() {
  if (sc) return Qr;
  sc = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.ensureValidAtUriRegex = Qr.ensureValidAtUri = void 0;
  const r = Th(), t = Ch(), i = Sh(), n = (o) => {
    const e = o.split("#");
    if (e.length > 2)
      throw new Error('ATURI can have at most one "#", separating fragment out');
    const l = e[1] || null;
    if (o = e[0], !/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(o))
      throw new Error("Disallowed characters in ATURI (ASCII)");
    const a = o.split("/");
    if (a.length >= 3 && (a[0] !== "at:" || a[1].length !== 0))
      throw new Error('ATURI must start with "at://"');
    if (a.length < 3)
      throw new Error("ATURI requires at least method and authority sections");
    try {
      a[2].startsWith("did:") ? (0, r.ensureValidDid)(a[2]) : (0, t.ensureValidHandle)(a[2]);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
    if (a.length >= 4) {
      if (a[3].length === 0)
        throw new Error("ATURI can not have a slash after authority without a path segment");
      try {
        (0, i.ensureValidNsid)(a[3]);
      } catch {
        throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
      }
    }
    if (a.length >= 5 && a[4].length === 0)
      throw new Error("ATURI can not have a slash after collection, unless record key is provided");
    if (a.length >= 6)
      throw new Error("ATURI path can have at most two parts, and no trailing slash");
    if (e.length >= 2 && l == null)
      throw new Error("ATURI fragment must be non-empty and start with slash");
    if (l != null) {
      if (l.length === 0 || l[0] !== "/")
        throw new Error("ATURI fragment must be non-empty and start with slash");
      if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(l))
        throw new Error("Disallowed characters in ATURI fragment (ASCII)");
    }
    if (o.length > 8 * 1024)
      throw new Error("ATURI is far too long");
  };
  Qr.ensureValidAtUri = n;
  const s = (o) => {
    const e = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/, l = o.match(e);
    if (!l || !l.groups)
      throw new Error("ATURI didn't validate via regex");
    const a = l.groups;
    try {
      (0, t.ensureValidHandleRegex)(a.authority);
    } catch {
      try {
        (0, r.ensureValidDidRegex)(a.authority);
      } catch {
        throw new Error("ATURI authority must be a valid handle or DID");
      }
    }
    if (a.collection)
      try {
        (0, i.ensureValidNsidRegex)(a.collection);
      } catch {
        throw new Error("ATURI collection path segment must be a valid NSID");
      }
    if (o.length > 8 * 1024)
      throw new Error("ATURI is far too long");
  };
  return Qr.ensureValidAtUriRegex = s, Qr;
}
var oc;
function ib() {
  return oc || (oc = 1, function(r) {
    var t = Jr && Jr.__createBinding || (Object.create ? function(l, a, u, f) {
      f === void 0 && (f = u);
      var m = Object.getOwnPropertyDescriptor(a, u);
      (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
        return a[u];
      } }), Object.defineProperty(l, f, m);
    } : function(l, a, u, f) {
      f === void 0 && (f = u), l[f] = a[u];
    }), i = Jr && Jr.__exportStar || function(l, a) {
      for (var u in l) u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && t(a, l, u);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.AtUri = r.ATP_URI_REGEX = void 0, i(rb(), r), r.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
    /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
    const n = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
    class s {
      constructor(a, u) {
        Object.defineProperty(this, "hash", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), Object.defineProperty(this, "host", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), Object.defineProperty(this, "pathname", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), Object.defineProperty(this, "searchParams", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        });
        let f;
        if (u) {
          if (f = o(u), !f)
            throw new Error(`Invalid at uri: ${u}`);
          const m = e(a);
          if (!m)
            throw new Error(`Invalid path: ${a}`);
          Object.assign(f, m);
        } else if (f = o(a), !f)
          throw new Error(`Invalid at uri: ${a}`);
        this.hash = f.hash, this.host = f.host, this.pathname = f.pathname, this.searchParams = f.searchParams;
      }
      static make(a, u, f) {
        let m = a;
        return u && (m += "/" + u), f && (m += "/" + f), new s(m);
      }
      get protocol() {
        return "at:";
      }
      get origin() {
        return `at://${this.host}`;
      }
      get hostname() {
        return this.host;
      }
      set hostname(a) {
        this.host = a;
      }
      get search() {
        return this.searchParams.toString();
      }
      set search(a) {
        this.searchParams = new URLSearchParams(a);
      }
      get collection() {
        return this.pathname.split("/").filter(Boolean)[0] || "";
      }
      set collection(a) {
        const u = this.pathname.split("/").filter(Boolean);
        u[0] = a, this.pathname = u.join("/");
      }
      get rkey() {
        return this.pathname.split("/").filter(Boolean)[1] || "";
      }
      set rkey(a) {
        const u = this.pathname.split("/").filter(Boolean);
        u[0] || (u[0] = "undefined"), u[1] = a, this.pathname = u.join("/");
      }
      get href() {
        return this.toString();
      }
      toString() {
        let a = this.pathname || "/";
        a.startsWith("/") || (a = `/${a}`);
        let u = this.searchParams.toString();
        u && !u.startsWith("?") && (u = `?${u}`);
        let f = this.hash;
        return f && !f.startsWith("#") && (f = `#${f}`), `at://${this.host}${a}${u}${f}`;
      }
    }
    r.AtUri = s;
    function o(l) {
      const a = r.ATP_URI_REGEX.exec(l);
      if (a)
        return {
          hash: a[5] || "",
          host: a[2] || "",
          pathname: a[3] || "",
          searchParams: new URLSearchParams(a[4] || "")
        };
    }
    function e(l) {
      const a = n.exec(l);
      if (a)
        return {
          hash: a[3] || "",
          pathname: a[1] || "",
          searchParams: new URLSearchParams(a[2] || "")
        };
    }
  }(Jr)), Jr;
}
var xr = {}, ac;
function nb() {
  if (ac) return xr;
  ac = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.InvalidTidError = xr.isValidTid = xr.ensureValidTid = void 0;
  const r = 13, t = /^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/, i = (o) => {
    if (o.length !== r)
      throw new s(`TID must be ${r} characters`);
    if (!t.test(o))
      throw new s("TID syntax not valid (regex)");
  };
  xr.ensureValidTid = i;
  const n = (o) => o.length === r && t.test(o);
  xr.isValidTid = n;
  class s extends Error {
  }
  return xr.InvalidTidError = s, xr;
}
var pu = {}, uc;
function sb() {
  return uc || (uc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.InvalidRecordKeyError = r.isValidRecordKey = r.ensureValidRecordKey = void 0;
    const t = (s) => {
      if (s.length > 512 || s.length < 1)
        throw new n("record key must be 1 to 512 characters");
      if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(s))
        throw new n("record key syntax not valid (regex)");
      if (s === "." || s === "..")
        throw new n('record key can not be "." or ".."');
    };
    r.ensureValidRecordKey = t;
    const i = (s) => {
      try {
        (0, r.ensureValidRecordKey)(s);
      } catch (o) {
        if (o instanceof n)
          return !1;
        throw o;
      }
      return !0;
    };
    r.isValidRecordKey = i;
    class n extends Error {
    }
    r.InvalidRecordKeyError = n;
  }(pu)), pu;
}
var fu = {}, cc;
function ob() {
  return cc || (cc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.InvalidDatetimeError = r.normalizeDatetimeAlways = r.normalizeDatetime = r.isValidDatetime = r.ensureValidDatetime = void 0;
    const t = (e) => {
      const l = new Date(e);
      if (isNaN(l.getTime()))
        throw new o("datetime did not parse as ISO 8601");
      if (l.toISOString().startsWith("-"))
        throw new o("datetime normalized to a negative time");
      if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(e))
        throw new o("datetime didn't validate via regex");
      if (e.length > 64)
        throw new o("datetime is too long (64 chars max)");
      if (e.endsWith("-00:00"))
        throw new o('datetime can not use "-00:00" for UTC timezone');
      if (e.startsWith("000"))
        throw new o("datetime so close to year zero not allowed");
    };
    r.ensureValidDatetime = t;
    const i = (e) => {
      try {
        (0, r.ensureValidDatetime)(e);
      } catch (l) {
        if (l instanceof o)
          return !1;
        throw l;
      }
      return !0;
    };
    r.isValidDatetime = i;
    const n = (e) => {
      if ((0, r.isValidDatetime)(e)) {
        const u = new Date(e).toISOString();
        if ((0, r.isValidDatetime)(u))
          return u;
      }
      if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(e)) {
        const u = /* @__PURE__ */ new Date(e + "Z");
        if (!isNaN(u.getTime())) {
          const f = u.toISOString();
          if ((0, r.isValidDatetime)(f))
            return f;
        }
      }
      const l = new Date(e);
      if (isNaN(l.getTime()))
        throw new o("datetime did not parse as any timestamp format");
      const a = l.toISOString();
      if ((0, r.isValidDatetime)(a))
        return a;
      throw new o("datetime normalized to invalid timestamp string");
    };
    r.normalizeDatetime = n;
    const s = (e) => {
      try {
        return (0, r.normalizeDatetime)(e);
      } catch (l) {
        if (l instanceof o)
          return (/* @__PURE__ */ new Date(0)).toISOString();
        throw l;
      }
    };
    r.normalizeDatetimeAlways = s;
    class o extends Error {
    }
    r.InvalidDatetimeError = o;
  }(fu)), fu;
}
var lc;
function fn() {
  return lc || (lc = 1, function(r) {
    var t = Wr && Wr.__createBinding || (Object.create ? function(n, s, o, e) {
      e === void 0 && (e = o);
      var l = Object.getOwnPropertyDescriptor(s, o);
      (!l || ("get" in l ? !s.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return s[o];
      } }), Object.defineProperty(n, e, l);
    } : function(n, s, o, e) {
      e === void 0 && (e = o), n[e] = s[o];
    }), i = Wr && Wr.__exportStar || function(n, s) {
      for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && t(s, n, o);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), i(Ch(), r), i(Th(), r), i(Sh(), r), i(ib(), r), i(nb(), r), i(sb(), r), i(ob(), r);
  }(Wr)), Wr;
}
var En = {}, dc;
function Uu() {
  if (dc) return En;
  dc = 1, Object.defineProperty(En, "__esModule", { value: !0 }), En.toLexUri = t, En.requiredPropertiesRefinement = i;
  const r = /* @__PURE__ */ fi();
  function t(n, s) {
    if (n.split("#").length > 2)
      throw new Error("Uri can only have one hash segment");
    if (n.startsWith("lex:"))
      return n;
    if (n.startsWith("#")) {
      if (!s)
        throw new Error(`Unable to resolve uri without anchor: ${n}`);
      return `${s}${n}`;
    }
    return `lex:${n}`;
  }
  function i(n, s) {
    if (n.required !== void 0) {
      if (!Array.isArray(n.required)) {
        s.addIssue({
          code: r.z.ZodIssueCode.invalid_type,
          received: typeof n.required,
          expected: "array"
        });
        return;
      }
      if (n.properties === void 0) {
        n.required.length > 0 && s.addIssue({
          code: r.z.ZodIssueCode.custom,
          message: "Required fields defined but no properties defined"
        });
        return;
      }
      for (const o of n.required)
        n.properties[o] === void 0 && s.addIssue({
          code: r.z.ZodIssueCode.custom,
          message: `Required field "${o}" not defined`
        });
    }
  }
  return En;
}
var pc;
function yi() {
  return pc || (pc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.LexiconDefNotFoundError = r.InvalidLexiconError = r.ValidationError = r.lexiconDoc = r.lexUserType = r.lexRecord = r.lexXrpcSubscription = r.lexXrpcProcedure = r.lexXrpcQuery = r.lexXrpcError = r.lexXrpcSubscriptionMessage = r.lexXrpcBody = r.lexXrpcParameters = r.lexObject = r.lexToken = r.lexPrimitiveArray = r.lexArray = r.lexBlob = r.lexRefVariant = r.lexRefUnion = r.lexRef = r.lexIpldType = r.lexCidLink = r.lexBytes = r.lexPrimitive = r.lexUnknown = r.lexString = r.lexStringFormat = r.lexInteger = r.lexBoolean = void 0, r.isValidLexiconDoc = s, r.isObj = o, r.isDiscriminatedObject = e, r.parseLexiconDoc = l;
    const t = /* @__PURE__ */ fi(), i = fn(), n = Uu();
    r.lexBoolean = t.z.object({
      type: t.z.literal("boolean"),
      description: t.z.string().optional(),
      default: t.z.boolean().optional(),
      const: t.z.boolean().optional()
    }).strict(), r.lexInteger = t.z.object({
      type: t.z.literal("integer"),
      description: t.z.string().optional(),
      default: t.z.number().int().optional(),
      minimum: t.z.number().int().optional(),
      maximum: t.z.number().int().optional(),
      enum: t.z.number().int().array().optional(),
      const: t.z.number().int().optional()
    }).strict(), r.lexStringFormat = t.z.enum([
      "datetime",
      "uri",
      "at-uri",
      "did",
      "handle",
      "at-identifier",
      "nsid",
      "cid",
      "language",
      "tid",
      "record-key"
    ]), r.lexString = t.z.object({
      type: t.z.literal("string"),
      format: r.lexStringFormat.optional(),
      description: t.z.string().optional(),
      default: t.z.string().optional(),
      minLength: t.z.number().int().optional(),
      maxLength: t.z.number().int().optional(),
      minGraphemes: t.z.number().int().optional(),
      maxGraphemes: t.z.number().int().optional(),
      enum: t.z.string().array().optional(),
      const: t.z.string().optional(),
      knownValues: t.z.string().array().optional()
    }).strict(), r.lexUnknown = t.z.object({
      type: t.z.literal("unknown"),
      description: t.z.string().optional()
    }).strict(), r.lexPrimitive = t.z.discriminatedUnion("type", [
      r.lexBoolean,
      r.lexInteger,
      r.lexString,
      r.lexUnknown
    ]), r.lexBytes = t.z.object({
      type: t.z.literal("bytes"),
      description: t.z.string().optional(),
      maxLength: t.z.number().optional(),
      minLength: t.z.number().optional()
    }).strict(), r.lexCidLink = t.z.object({
      type: t.z.literal("cid-link"),
      description: t.z.string().optional()
    }).strict(), r.lexIpldType = t.z.discriminatedUnion("type", [r.lexBytes, r.lexCidLink]), r.lexRef = t.z.object({
      type: t.z.literal("ref"),
      description: t.z.string().optional(),
      ref: t.z.string()
    }).strict(), r.lexRefUnion = t.z.object({
      type: t.z.literal("union"),
      description: t.z.string().optional(),
      refs: t.z.string().array(),
      closed: t.z.boolean().optional()
    }).strict(), r.lexRefVariant = t.z.discriminatedUnion("type", [r.lexRef, r.lexRefUnion]), r.lexBlob = t.z.object({
      type: t.z.literal("blob"),
      description: t.z.string().optional(),
      accept: t.z.string().array().optional(),
      maxSize: t.z.number().optional()
    }).strict(), r.lexArray = t.z.object({
      type: t.z.literal("array"),
      description: t.z.string().optional(),
      items: t.z.discriminatedUnion("type", [
        // lexPrimitive
        r.lexBoolean,
        r.lexInteger,
        r.lexString,
        r.lexUnknown,
        // lexIpldType
        r.lexBytes,
        r.lexCidLink,
        // lexRefVariant
        r.lexRef,
        r.lexRefUnion,
        // other
        r.lexBlob
      ]),
      minLength: t.z.number().int().optional(),
      maxLength: t.z.number().int().optional()
    }).strict(), r.lexPrimitiveArray = r.lexArray.merge(t.z.object({
      items: r.lexPrimitive
    }).strict()), r.lexToken = t.z.object({
      type: t.z.literal("token"),
      description: t.z.string().optional()
    }).strict(), r.lexObject = t.z.object({
      type: t.z.literal("object"),
      description: t.z.string().optional(),
      required: t.z.string().array().optional(),
      nullable: t.z.string().array().optional(),
      properties: t.z.record(t.z.discriminatedUnion("type", [
        r.lexArray,
        // lexPrimitive
        r.lexBoolean,
        r.lexInteger,
        r.lexString,
        r.lexUnknown,
        // lexIpldType
        r.lexBytes,
        r.lexCidLink,
        // lexRefVariant
        r.lexRef,
        r.lexRefUnion,
        // other
        r.lexBlob
      ]))
    }).strict().superRefine(n.requiredPropertiesRefinement), r.lexXrpcParameters = t.z.object({
      type: t.z.literal("params"),
      description: t.z.string().optional(),
      required: t.z.string().array().optional(),
      properties: t.z.record(t.z.discriminatedUnion("type", [
        r.lexPrimitiveArray,
        // lexPrimitive
        r.lexBoolean,
        r.lexInteger,
        r.lexString,
        r.lexUnknown
      ]))
    }).strict().superRefine(n.requiredPropertiesRefinement), r.lexXrpcBody = t.z.object({
      description: t.z.string().optional(),
      encoding: t.z.string(),
      // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
      schema: t.z.union([r.lexRefVariant, r.lexObject]).optional()
    }).strict(), r.lexXrpcSubscriptionMessage = t.z.object({
      description: t.z.string().optional(),
      // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
      schema: t.z.union([r.lexRefVariant, r.lexObject]).optional()
    }).strict(), r.lexXrpcError = t.z.object({
      name: t.z.string(),
      description: t.z.string().optional()
    }).strict(), r.lexXrpcQuery = t.z.object({
      type: t.z.literal("query"),
      description: t.z.string().optional(),
      parameters: r.lexXrpcParameters.optional(),
      output: r.lexXrpcBody.optional(),
      errors: r.lexXrpcError.array().optional()
    }).strict(), r.lexXrpcProcedure = t.z.object({
      type: t.z.literal("procedure"),
      description: t.z.string().optional(),
      parameters: r.lexXrpcParameters.optional(),
      input: r.lexXrpcBody.optional(),
      output: r.lexXrpcBody.optional(),
      errors: r.lexXrpcError.array().optional()
    }).strict(), r.lexXrpcSubscription = t.z.object({
      type: t.z.literal("subscription"),
      description: t.z.string().optional(),
      parameters: r.lexXrpcParameters.optional(),
      message: r.lexXrpcSubscriptionMessage.optional(),
      errors: r.lexXrpcError.array().optional()
    }).strict(), r.lexRecord = t.z.object({
      type: t.z.literal("record"),
      description: t.z.string().optional(),
      key: t.z.string().optional(),
      record: r.lexObject
    }).strict(), r.lexUserType = t.z.custom((m) => {
      if (!(!m || typeof m != "object") && m.type !== void 0)
        switch (m.type) {
          case "record":
            return r.lexRecord.parse(m);
          case "query":
            return r.lexXrpcQuery.parse(m);
          case "procedure":
            return r.lexXrpcProcedure.parse(m);
          case "subscription":
            return r.lexXrpcSubscription.parse(m);
          case "blob":
            return r.lexBlob.parse(m);
          case "array":
            return r.lexArray.parse(m);
          case "token":
            return r.lexToken.parse(m);
          case "object":
            return r.lexObject.parse(m);
          case "boolean":
            return r.lexBoolean.parse(m);
          case "integer":
            return r.lexInteger.parse(m);
          case "string":
            return r.lexString.parse(m);
          case "bytes":
            return r.lexBytes.parse(m);
          case "cid-link":
            return r.lexCidLink.parse(m);
          case "unknown":
            return r.lexUnknown.parse(m);
        }
    }, (m) => !m || typeof m != "object" ? {
      message: "Must be an object",
      fatal: !0
    } : m.type === void 0 ? {
      message: "Must have a type",
      fatal: !0
    } : typeof m.type != "string" ? {
      message: "Type property must be a string",
      fatal: !0
    } : {
      message: `Invalid type: ${m.type} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
      fatal: !0
    }), r.lexiconDoc = t.z.object({
      lexicon: t.z.literal(1),
      id: t.z.string().refine((m) => i.NSID.isValid(m), {
        message: "Must be a valid NSID"
      }),
      revision: t.z.number().optional(),
      description: t.z.string().optional(),
      defs: t.z.record(r.lexUserType)
    }).strict().superRefine((m, g) => {
      for (const A in m.defs) {
        const v = m.defs[A];
        A !== "main" && (v.type === "record" || v.type === "procedure" || v.type === "query" || v.type === "subscription") && g.addIssue({
          code: t.z.ZodIssueCode.custom,
          message: "Records, procedures, queries, and subscriptions must be the main definition."
        });
      }
    });
    function s(m) {
      return r.lexiconDoc.safeParse(m).success;
    }
    function o(m) {
      return m != null && typeof m == "object";
    }
    function e(m) {
      return o(m) && "$type" in m && typeof m.$type == "string";
    }
    function l(m) {
      return r.lexiconDoc.parse(m), m;
    }
    class a extends Error {
    }
    r.ValidationError = a;
    class u extends Error {
    }
    r.InvalidLexiconError = u;
    class f extends Error {
    }
    r.LexiconDefNotFoundError = f;
  }(au)), au;
}
var xn = {}, wr = {}, Yr = {}, ls = {}, yu = {}, ab = wh, fc = 128, ub = -128, cb = Math.pow(2, 31);
function wh(r, t, i) {
  t = t || [], i = i || 0;
  for (var n = i; r >= cb; )
    t[i++] = r & 255 | fc, r /= 128;
  for (; r & ub; )
    t[i++] = r & 255 | fc, r >>>= 7;
  return t[i] = r | 0, wh.bytes = i - n + 1, t;
}
var lb = ku, db = 128, yc = 127;
function ku(r, n) {
  var i = 0, n = n || 0, s = 0, o = n, e, l = r.length;
  do {
    if (o >= l)
      throw ku.bytes = 0, new RangeError("Could not decode varint");
    e = r[o++], i += s < 28 ? (e & yc) << s : (e & yc) * Math.pow(2, s), s += 7;
  } while (e >= db);
  return ku.bytes = o - n, i;
}
var pb = Math.pow(2, 7), fb = Math.pow(2, 14), yb = Math.pow(2, 21), mb = Math.pow(2, 28), hb = Math.pow(2, 35), bb = Math.pow(2, 42), gb = Math.pow(2, 49), Eb = Math.pow(2, 56), xb = Math.pow(2, 63), vb = function(r) {
  return r < pb ? 1 : r < fb ? 2 : r < yb ? 3 : r < mb ? 4 : r < hb ? 5 : r < bb ? 6 : r < gb ? 7 : r < Eb ? 8 : r < xb ? 9 : 10;
}, Rb = {
  encode: ab,
  decode: lb,
  encodingLength: vb
}, Qa = Rb;
const Du = (r, t = 0) => [
  Qa.decode(r, t),
  Qa.decode.bytes
], Ya = (r, t, i = 0) => (Qa.encode(r, t, i), t), eu = (r) => Qa.encodingLength(r), Ab = (r, t) => {
  if (r === t)
    return !0;
  if (r.byteLength !== t.byteLength)
    return !1;
  for (let i = 0; i < r.byteLength; i++)
    if (r[i] !== t[i])
      return !1;
  return !0;
}, Vu = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
}, _b = (r) => new TextEncoder().encode(r), Cb = (r) => new TextDecoder().decode(r), Tb = (r, t) => {
  const i = t.byteLength, n = eu(r), s = n + eu(i), o = new Uint8Array(s + i);
  return Ya(r, o, 0), Ya(i, o, n), o.set(t, s), new Ku(r, i, t, o);
}, Sb = (r) => {
  const t = Vu(r), [i, n] = Du(t), [s, o] = Du(t.subarray(n)), e = t.subarray(n + o);
  if (e.byteLength !== s)
    throw new Error("Incorrect length");
  return new Ku(i, s, e, t);
}, wb = (r, t) => r === t ? !0 : r.code === t.code && r.size === t.size && Ab(r.bytes, t.bytes);
class Ku {
  constructor(t, i, n, s) {
    this.code = t, this.size = i, this.digest = n, this.bytes = s;
  }
}
function Lb(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var i = new Uint8Array(256), n = 0; n < i.length; n++)
    i[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var o = r.charAt(s), e = o.charCodeAt(0);
    if (i[e] !== 255)
      throw new TypeError(o + " is ambiguous");
    i[e] = s;
  }
  var l = r.length, a = r.charAt(0), u = Math.log(l) / Math.log(256), f = Math.log(256) / Math.log(l);
  function m(v) {
    if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (v.length === 0)
      return "";
    for (var R = 0, E = 0, h = 0, C = v.length; h !== C && v[h] === 0; )
      h++, R++;
    for (var K = (C - h) * f + 1 >>> 0, k = new Uint8Array(K); h !== C; ) {
      for (var F = v[h], Z = 0, q = K - 1; (F !== 0 || Z < E) && q !== -1; q--, Z++)
        F += 256 * k[q] >>> 0, k[q] = F % l >>> 0, F = F / l >>> 0;
      if (F !== 0)
        throw new Error("Non-zero carry");
      E = Z, h++;
    }
    for (var J = K - E; J !== K && k[J] === 0; )
      J++;
    for (var xe = a.repeat(R); J < K; ++J)
      xe += r.charAt(k[J]);
    return xe;
  }
  function g(v) {
    if (typeof v != "string")
      throw new TypeError("Expected String");
    if (v.length === 0)
      return new Uint8Array();
    var R = 0;
    if (v[R] !== " ") {
      for (var E = 0, h = 0; v[R] === a; )
        E++, R++;
      for (var C = (v.length - R) * u + 1 >>> 0, K = new Uint8Array(C); v[R]; ) {
        var k = i[v.charCodeAt(R)];
        if (k === 255)
          return;
        for (var F = 0, Z = C - 1; (k !== 0 || F < h) && Z !== -1; Z--, F++)
          k += l * K[Z] >>> 0, K[Z] = k % 256 >>> 0, k = k / 256 >>> 0;
        if (k !== 0)
          throw new Error("Non-zero carry");
        h = F, R++;
      }
      if (v[R] !== " ") {
        for (var q = C - h; q !== C && K[q] === 0; )
          q++;
        for (var J = new Uint8Array(E + (C - q)), xe = E; q !== C; )
          J[xe++] = K[q++];
        return J;
      }
    }
  }
  function A(v) {
    var R = g(v);
    if (R)
      return R;
    throw new Error(`Non-${t} character`);
  }
  return {
    encode: m,
    decodeUnsafe: g,
    decode: A
  };
}
var kb = Lb, Db = kb;
class Bb {
  constructor(t, i, n) {
    this.name = t, this.prefix = i, this.baseEncode = n;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Pb {
  constructor(t, i, n) {
    if (this.name = t, this.prefix = i, i.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = i.codePointAt(0), this.baseDecode = n;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return Lh(this, t);
  }
}
class Ub {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return Lh(this, t);
  }
  decode(t) {
    const i = t[0], n = this.decoders[i];
    if (n)
      return n.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Lh = (r, t) => new Ub({
  ...r.decoders || { [r.prefix]: r },
  ...t.decoders || { [t.prefix]: t }
});
class Vb {
  constructor(t, i, n, s) {
    this.name = t, this.prefix = i, this.baseEncode = n, this.baseDecode = s, this.encoder = new Bb(t, i, n), this.decoder = new Pb(t, i, s);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const ru = ({ name: r, prefix: t, encode: i, decode: n }) => new Vb(r, t, i, n), is = ({ prefix: r, name: t, alphabet: i }) => {
  const { encode: n, decode: s } = Db(i, t);
  return ru({
    prefix: r,
    name: t,
    encode: n,
    decode: (o) => Vu(s(o))
  });
}, Kb = (r, t, i, n) => {
  const s = {};
  for (let f = 0; f < t.length; ++f)
    s[t[f]] = f;
  let o = r.length;
  for (; r[o - 1] === "="; )
    --o;
  const e = new Uint8Array(o * i / 8 | 0);
  let l = 0, a = 0, u = 0;
  for (let f = 0; f < o; ++f) {
    const m = s[r[f]];
    if (m === void 0)
      throw new SyntaxError(`Non-${n} character`);
    a = a << i | m, l += i, l >= 8 && (l -= 8, e[u++] = 255 & a >> l);
  }
  if (l >= i || 255 & a << 8 - l)
    throw new SyntaxError("Unexpected end of data");
  return e;
}, Ib = (r, t, i) => {
  const n = t[t.length - 1] === "=", s = (1 << i) - 1;
  let o = "", e = 0, l = 0;
  for (let a = 0; a < r.length; ++a)
    for (l = l << 8 | r[a], e += 8; e > i; )
      e -= i, o += t[s & l >> e];
  if (e && (o += t[s & l << i - e]), n)
    for (; o.length * i & 7; )
      o += "=";
  return o;
}, ut = ({ name: r, prefix: t, bitsPerChar: i, alphabet: n }) => ru({
  prefix: t,
  name: r,
  encode(s) {
    return Ib(s, n, i);
  },
  decode(s) {
    return Kb(s, n, i, r);
  }
}), Ar = is({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), jb = is({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Ar,
  base58flickr: jb
}, Symbol.toStringTag, { value: "Module" })), ts = ut({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), Ob = ut({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), Mb = ut({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Nb = ut({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), Gb = ut({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), Fb = ut({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), $b = ut({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), zb = ut({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), Xb = ut({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), Hb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: ts,
  base32hex: Gb,
  base32hexpad: $b,
  base32hexpadupper: zb,
  base32hexupper: Fb,
  base32pad: Mb,
  base32padupper: Nb,
  base32upper: Ob,
  base32z: Xb
}, Symbol.toStringTag, { value: "Module" }));
class lt {
  constructor(t, i, n, s) {
    this.code = i, this.version = t, this.multihash = n, this.bytes = s, this.byteOffset = s.byteOffset, this.byteLength = s.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: ps,
      byteLength: ps,
      code: ds,
      version: ds,
      multihash: ds,
      bytes: ds,
      _baseCache: ps,
      asCID: ps
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: t, multihash: i } = this;
        if (t !== vn)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (i.code !== Qb)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return lt.createV0(i);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: t, digest: i } = this.multihash, n = Tb(t, i);
        return lt.createV1(this.code, n);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(t) {
    return t && this.code === t.code && this.version === t.version && wb(this.multihash, t.multihash);
  }
  toString(t) {
    const { bytes: i, version: n, _baseCache: s } = this;
    switch (n) {
      case 0:
        return Wb(i, s, t || Ar.encoder);
      default:
        return Jb(i, s, t || ts.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(t) {
    return eg(/^0\.0/, tg), !!(t && (t[hc] || t.asCID === t));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(t) {
    if (t instanceof lt)
      return t;
    if (t != null && t.asCID === t) {
      const { version: i, code: n, multihash: s, bytes: o } = t;
      return new lt(i, n, s, o || mc(i, n, s.bytes));
    } else if (t != null && t[hc] === !0) {
      const { version: i, multihash: n, code: s } = t, o = Sb(n);
      return lt.create(i, s, o);
    } else
      return null;
  }
  static create(t, i, n) {
    if (typeof i != "number")
      throw new Error("String codecs are no longer supported");
    switch (t) {
      case 0: {
        if (i !== vn)
          throw new Error(`Version 0 CID must use dag-pb (code: ${vn}) block encoding`);
        return new lt(t, i, n, n.bytes);
      }
      case 1: {
        const s = mc(t, i, n.bytes);
        return new lt(t, i, n, s);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(t) {
    return lt.create(0, vn, t);
  }
  static createV1(t, i) {
    return lt.create(1, t, i);
  }
  static decode(t) {
    const [i, n] = lt.decodeFirst(t);
    if (n.length)
      throw new Error("Incorrect length");
    return i;
  }
  static decodeFirst(t) {
    const i = lt.inspectBytes(t), n = i.size - i.multihashSize, s = Vu(t.subarray(n, n + i.multihashSize));
    if (s.byteLength !== i.multihashSize)
      throw new Error("Incorrect length");
    const o = s.subarray(i.multihashSize - i.digestSize), e = new Ku(i.multihashCode, i.digestSize, o, s);
    return [
      i.version === 0 ? lt.createV0(e) : lt.createV1(i.codec, e),
      t.subarray(i.size)
    ];
  }
  static inspectBytes(t) {
    let i = 0;
    const n = () => {
      const [m, g] = Du(t.subarray(i));
      return i += g, m;
    };
    let s = n(), o = vn;
    if (s === 18 ? (s = 0, i = 0) : s === 1 && (o = n()), s !== 0 && s !== 1)
      throw new RangeError(`Invalid CID version ${s}`);
    const e = i, l = n(), a = n(), u = i + a, f = u - e;
    return {
      version: s,
      codec: o,
      multihashCode: l,
      digestSize: a,
      multihashSize: f,
      size: u
    };
  }
  static parse(t, i) {
    const [n, s] = Zb(t, i), o = lt.decode(s);
    return o._baseCache.set(n, t), o;
  }
}
const Zb = (r, t) => {
  switch (r[0]) {
    case "Q": {
      const i = t || Ar;
      return [
        Ar.prefix,
        i.decode(`${Ar.prefix}${r}`)
      ];
    }
    case Ar.prefix: {
      const i = t || Ar;
      return [
        Ar.prefix,
        i.decode(r)
      ];
    }
    case ts.prefix: {
      const i = t || ts;
      return [
        ts.prefix,
        i.decode(r)
      ];
    }
    default: {
      if (t == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        r[0],
        t.decode(r)
      ];
    }
  }
}, Wb = (r, t, i) => {
  const { prefix: n } = i;
  if (n !== Ar.prefix)
    throw Error(`Cannot string encode V0 in ${i.name} encoding`);
  const s = t.get(n);
  if (s == null) {
    const o = i.encode(r).slice(1);
    return t.set(n, o), o;
  } else
    return s;
}, Jb = (r, t, i) => {
  const { prefix: n } = i, s = t.get(n);
  if (s == null) {
    const o = i.encode(r);
    return t.set(n, o), o;
  } else
    return s;
}, vn = 112, Qb = 18, mc = (r, t, i) => {
  const n = eu(r), s = n + eu(t), o = new Uint8Array(s + i.byteLength);
  return Ya(r, o, 0), Ya(t, o, n), o.set(i, s), o;
}, hc = Symbol.for("@ipld/js-cid/CID"), ds = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, ps = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, Yb = "0.0.0-dev", eg = (r, t) => {
  if (r.test(Yb))
    console.warn(t);
  else
    throw new Error(t);
}, tg = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, rg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: lt
}, Symbol.toStringTag, { value: "Module" })), yn = /* @__PURE__ */ vh(rg);
var Qt = {}, Yt = {}, bc;
function ig() {
  if (bc) return Yt;
  bc = 1, Object.defineProperty(Yt, "__esModule", { value: !0 }), Yt.isObject = Yt.assure = Yt.create = Yt.is = void 0;
  const r = (s, o) => o.safeParse(s).success;
  Yt.is = r;
  const t = (s) => (o) => s.safeParse(o).success;
  Yt.create = t;
  const i = (s, o) => s.parse(o);
  Yt.assure = i;
  const n = (s) => typeof s == "object" && s !== null;
  return Yt.isObject = n, Yt;
}
var mu = {}, gc;
function rs() {
  return gc || (gc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.parseIntWithFallback = r.dedupeStrs = r.range = r.chunkArray = r.errHasMsg = r.isErrnoException = r.asyncFilter = r.s32decode = r.s32encode = r.streamToBuffer = r.flattenUint8Arrays = r.bailableWait = r.wait = r.jitter = r.noUndefinedVals = void 0, r.omit = i;
    const t = (C) => (Object.keys(C).forEach((K) => {
      C[K] === void 0 && delete C[K];
    }), C);
    r.noUndefinedVals = t;
    function i(C, K) {
      if (!C)
        return C;
      const k = {}, F = Object.keys(C);
      for (let Z = 0; Z < F.length; Z++) {
        const q = F[Z];
        K.includes(q) || (k[q] = C[q]);
      }
      return k;
    }
    const n = (C) => Math.round((Math.random() - 0.5) * C * 2);
    r.jitter = n;
    const s = (C) => new Promise((K) => setTimeout(K, C));
    r.wait = s;
    const o = (C) => {
      let K;
      const k = new Promise((F) => {
        const Z = setTimeout(F, C);
        K = () => {
          clearTimeout(Z), F();
        };
      });
      return { bail: K, wait: () => k };
    };
    r.bailableWait = o;
    const e = (C) => {
      const K = C.reduce((Z, q) => Z + q.length, 0), k = new Uint8Array(K);
      let F = 0;
      return C.forEach((Z) => {
        k.set(Z, F), F += Z.length;
      }), k;
    };
    r.flattenUint8Arrays = e;
    const l = async (C) => {
      const K = [];
      for await (const k of C)
        K.push(k);
      return (0, r.flattenUint8Arrays)(K);
    };
    r.streamToBuffer = l;
    const a = "234567abcdefghijklmnopqrstuvwxyz", u = (C) => {
      let K = "";
      for (; C; ) {
        const k = C % 32;
        C = Math.floor(C / 32), K = a.charAt(k) + K;
      }
      return K;
    };
    r.s32encode = u;
    const f = (C) => {
      let K = 0;
      for (const k of C)
        K = K * 32 + a.indexOf(k);
      return K;
    };
    r.s32decode = f;
    const m = async (C, K) => {
      const k = await Promise.all(C.map((F) => K(F)));
      return C.filter((F, Z) => k[Z]);
    };
    r.asyncFilter = m;
    const g = (C) => !!C && C.code;
    r.isErrnoException = g;
    const A = (C, K) => !!C && typeof C == "object" && C.message === K;
    r.errHasMsg = A;
    const v = (C, K) => C.reduce((k, F, Z) => {
      const q = Math.floor(Z / K);
      return k[q] || (k[q] = []), k[q].push(F), k;
    }, []);
    r.chunkArray = v;
    const R = (C) => {
      const K = [];
      for (let k = 0; k < C; k++)
        K.push(k);
      return K;
    };
    r.range = R;
    const E = (C) => [...new Set(C)];
    r.dedupeStrs = E;
    const h = (C, K) => {
      const k = parseInt(C || "", 10);
      return isNaN(k) ? K : k;
    };
    r.parseIntWithFallback = h;
  }(mu)), mu;
}
var hi = {}, Ec;
function ng() {
  if (Ec) return hi;
  Ec = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.mapDefined = void 0, hi.keyBy = r;
  function r(i, n) {
    return i.reduce((s, o) => (s.set(o[n], o), s), /* @__PURE__ */ new Map());
  }
  const t = (i, n) => {
    const s = [];
    for (const o of i) {
      const e = n(o);
      e !== void 0 && s.push(e);
    }
    return s;
  };
  return hi.mapDefined = t, hi;
}
var hu = {}, xc;
function sg() {
  return xc || (xc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.AsyncBufferFullError = r.AsyncBuffer = r.allComplete = r.createDeferrables = r.createDeferrable = r.readFromGenerator = void 0, r.allFulfilled = a, r.handleAllSettledErrors = u, r.isRejectedResult = f, r.isFulfilledResult = g;
    const t = rs(), i = async (R, E, h = Promise.resolve(), C = Number.MAX_SAFE_INTEGER) => {
      const K = [];
      let k, F = !1;
      const Z = async () => {
        if (await E(K.at(-1)))
          return !0;
        const J = (0, t.bailableWait)(20);
        return await J.wait(), k = J.bail, F ? !1 : await Z();
      }, q = new Promise((J) => {
        h.then(() => {
          Z().then(() => J());
        });
      });
      try {
        for (; K.length < C; ) {
          const J = await Promise.race([R.next(), q]);
          if (!J)
            break;
          const xe = J;
          if (xe.done)
            break;
          K.push(xe.value);
        }
      } finally {
        F = !0, k && k();
      }
      return K;
    };
    r.readFromGenerator = i;
    const n = () => {
      let R;
      const E = new Promise((h) => {
        R = () => h();
      });
      return { resolve: R, complete: E };
    };
    r.createDeferrable = n;
    const s = (R) => {
      const E = [];
      for (let h = 0; h < R; h++)
        E.push((0, r.createDeferrable)());
      return E;
    };
    r.createDeferrables = s;
    const o = async (R) => {
      await Promise.all(R.map((E) => E.complete));
    };
    r.allComplete = o;
    class e {
      constructor(E) {
        Object.defineProperty(this, "maxSize", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: E
        }), Object.defineProperty(this, "buffer", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: []
        }), Object.defineProperty(this, "promise", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), Object.defineProperty(this, "resolve", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), Object.defineProperty(this, "closed", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: !1
        }), Object.defineProperty(this, "toThrow", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), this.promise = Promise.resolve(), this.resolve = () => null, this.resetPromise();
      }
      get curr() {
        return this.buffer;
      }
      get size() {
        return this.buffer.length;
      }
      get isClosed() {
        return this.closed;
      }
      resetPromise() {
        this.promise = new Promise((E) => this.resolve = E);
      }
      push(E) {
        this.buffer.push(E), this.resolve();
      }
      pushMany(E) {
        E.forEach((h) => this.buffer.push(h)), this.resolve();
      }
      async *events() {
        for (; ; ) {
          if (this.closed && this.buffer.length === 0) {
            if (this.toThrow)
              throw this.toThrow;
            return;
          }
          if (await this.promise, this.toThrow)
            throw this.toThrow;
          if (this.maxSize && this.size > this.maxSize)
            throw new l(this.maxSize);
          const [E, ...h] = this.buffer;
          E ? (this.buffer = h, yield E) : this.resetPromise();
        }
      }
      throw(E) {
        this.toThrow = E, this.closed = !0, this.resolve();
      }
      close() {
        this.closed = !0, this.resolve();
      }
    }
    r.AsyncBuffer = e;
    class l extends Error {
      constructor(E) {
        super(`ReachedMaxBufferSize: ${E}`);
      }
    }
    r.AsyncBufferFullError = l;
    function a(R) {
      return Promise.allSettled(R).then(u);
    }
    function u(R) {
      const E = R.filter(f).map(m);
      if (E.length === 0)
        return R.map(A);
      throw E.length === 1 ? E[0] : new AggregateError(E, `Multiple errors: ${E.map(v).join(`
`)}`);
    }
    function f(R) {
      return R.status === "rejected";
    }
    function m(R) {
      return R.reason;
    }
    function g(R) {
      return R.status === "fulfilled";
    }
    function A(R) {
      return R.value;
    }
    function v(R) {
      return R instanceof Error ? R.message : String(R);
    }
  }(hu)), hu;
}
var Rn = {}, vc;
function og() {
  if (vc) return Rn;
  vc = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.TID = void 0;
  const r = rs(), t = 13;
  let i = 0, n = 0, s = null;
  function o(l) {
    return l.replaceAll("-", "");
  }
  class e {
    constructor(a) {
      Object.defineProperty(this, "str", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      });
      const u = o(a);
      if (u.length !== t)
        throw new Error(`Poorly formatted TID: ${u.length} length`);
      this.str = u;
    }
    static next(a) {
      const u = Math.max(Date.now(), i);
      u === i && n++, i = u;
      const f = u * 1e3 + n;
      s === null && (s = Math.floor(Math.random() * 32));
      const m = e.fromTime(f, s);
      return !a || m.newerThan(a) ? m : e.fromTime(a.timestamp() + 1, s);
    }
    static nextStr(a) {
      return e.next(a ? new e(a) : void 0).toString();
    }
    static fromTime(a, u) {
      const f = `${(0, r.s32encode)(a)}${(0, r.s32encode)(u).padStart(2, "2")}`;
      return new e(f);
    }
    static fromStr(a) {
      return new e(a);
    }
    static oldestFirst(a, u) {
      return a.compareTo(u);
    }
    static newestFirst(a, u) {
      return u.compareTo(a);
    }
    static is(a) {
      return o(a).length === t;
    }
    timestamp() {
      return (0, r.s32decode)(this.str.slice(0, 11));
    }
    clockid() {
      return (0, r.s32decode)(this.str.slice(11, 13));
    }
    formatted() {
      const a = this.toString();
      return `${a.slice(0, 4)}-${a.slice(4, 7)}-${a.slice(7, 11)}-${a.slice(11, 13)}`;
    }
    toString() {
      return this.str;
    }
    // newer > older
    compareTo(a) {
      return this.str > a.str ? 1 : this.str < a.str ? -1 : 0;
    }
    equals(a) {
      return this.str === a.str;
    }
    newerThan(a) {
      return this.compareTo(a) > 0;
    }
    olderThan(a) {
      return this.compareTo(a) < 0;
    }
  }
  return Rn.TID = e, Rn;
}
var vr = {};
function ag(r, t) {
  for (let i = 0; i < r.byteLength; i++) {
    if (r[i] < t[i])
      return -1;
    if (r[i] > t[i])
      return 1;
  }
  return r.byteLength > t.byteLength ? 1 : r.byteLength < t.byteLength ? -1 : 0;
}
function ug(r, t) {
  t || (t = r.reduce((s, o) => s + o.length, 0));
  const i = new Uint8Array(t);
  let n = 0;
  for (const s of r)
    i.set(s, n), n += s.length;
  return i;
}
function cg(r, t) {
  if (r === t)
    return !0;
  if (r.byteLength !== t.byteLength)
    return !1;
  for (let i = 0; i < r.byteLength; i++)
    if (r[i] !== t[i])
      return !1;
  return !0;
}
const lg = ru({
  prefix: "\0",
  name: "identity",
  encode: (r) => Cb(r),
  decode: (r) => _b(r)
}), dg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: lg
}, Symbol.toStringTag, { value: "Module" })), pg = ut({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), fg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: pg
}, Symbol.toStringTag, { value: "Module" })), yg = ut({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), mg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: yg
}, Symbol.toStringTag, { value: "Module" })), hg = is({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), bg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: hg
}, Symbol.toStringTag, { value: "Module" })), gg = ut({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), Eg = ut({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), xg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: gg,
  base16upper: Eg
}, Symbol.toStringTag, { value: "Module" })), vg = is({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Rg = is({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), Ag = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: vg,
  base36upper: Rg
}, Symbol.toStringTag, { value: "Module" })), _g = ut({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), Cg = ut({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), Tg = ut({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), Sg = ut({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), wg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: _g,
  base64pad: Cg,
  base64url: Tg,
  base64urlpad: Sg
}, Symbol.toStringTag, { value: "Module" })), kh = Array.from(""), Lg = kh.reduce((r, t, i) => (r[i] = t, r), []), kg = kh.reduce((r, t, i) => (r[t.codePointAt(0)] = i, r), []);
function Dg(r) {
  return r.reduce((t, i) => (t += Lg[i], t), "");
}
function Bg(r) {
  const t = [];
  for (const i of r) {
    const n = kg[i.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${i}`);
    t.push(n);
  }
  return new Uint8Array(t);
}
const Pg = ru({
  prefix: "",
  name: "base256emoji",
  encode: Dg,
  decode: Bg
}), Ug = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: Pg
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Rc = {
  ...dg,
  ...fg,
  ...mg,
  ...bg,
  ...xg,
  ...Hb,
  ...Ag,
  ...qb,
  ...wg,
  ...Ug
};
function Dh(r, t, i, n) {
  return {
    name: r,
    prefix: t,
    encoder: {
      name: r,
      prefix: t,
      encode: i
    },
    decoder: { decode: n }
  };
}
const Ac = Dh("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1))), bu = Dh("ascii", "a", (r) => {
  let t = "a";
  for (let i = 0; i < r.length; i++)
    t += String.fromCharCode(r[i]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = new Uint8Array(r.length);
  for (let i = 0; i < r.length; i++)
    t[i] = r.charCodeAt(i);
  return t;
}), Bh = {
  utf8: Ac,
  "utf-8": Ac,
  hex: Rc.base16,
  latin1: bu,
  ascii: bu,
  binary: bu,
  ...Rc
};
function Vg(r, t = "utf8") {
  const i = Bh[t];
  if (!i)
    throw new Error(`Unsupported encoding "${t}"`);
  return i.decoder.decode(`${i.prefix}${r}`);
}
function Kg(r, t = "utf8") {
  const i = Bh[t];
  if (!i)
    throw new Error(`Unsupported encoding "${t}"`);
  return i.encoder.encode(r).substring(1);
}
function Ig(r, t) {
  if (r.length !== t.length)
    throw new Error("Inputs should have the same length");
  const i = new Uint8Array(r.length);
  for (let n = 0; n < r.length; n++)
    i[n] = r[n] ^ t[n];
  return i;
}
const jg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: ag,
  concat: ug,
  equals: cg,
  fromString: Vg,
  toString: Kg,
  xor: Ig
}, Symbol.toStringTag, { value: "Module" })), Ph = /* @__PURE__ */ vh(jg);
var _c;
function qg() {
  return _c || (_c = 1, function(r) {
    var t = vr && vr.__createBinding || (Object.create ? function(u, f, m, g) {
      g === void 0 && (g = m);
      var A = Object.getOwnPropertyDescriptor(f, m);
      (!A || ("get" in A ? !f.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
        return f[m];
      } }), Object.defineProperty(u, g, A);
    } : function(u, f, m, g) {
      g === void 0 && (g = m), u[g] = f[m];
    }), i = vr && vr.__setModuleDefault || (Object.create ? function(u, f) {
      Object.defineProperty(u, "default", { enumerable: !0, value: f });
    } : function(u, f) {
      u.default = f;
    }), n = vr && vr.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var f = {};
      if (u != null) for (var m in u) m !== "default" && Object.prototype.hasOwnProperty.call(u, m) && t(f, u, m);
      return i(f, u), f;
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.ipldEquals = r.ipldToJson = r.jsonToIpld = void 0;
    const s = yn, o = n(Ph), e = (u) => {
      if (Array.isArray(u))
        return u.map((f) => (0, r.jsonToIpld)(f));
      if (u && typeof u == "object") {
        if (typeof u.$link == "string" && Object.keys(u).length === 1)
          return s.CID.parse(u.$link);
        if (typeof u.$bytes == "string" && Object.keys(u).length === 1)
          return o.fromString(u.$bytes, "base64");
        const f = {};
        for (const m of Object.keys(u))
          f[m] = (0, r.jsonToIpld)(u[m]);
        return f;
      }
      return u;
    };
    r.jsonToIpld = e;
    const l = (u) => {
      if (Array.isArray(u))
        return u.map((f) => (0, r.ipldToJson)(f));
      if (u && typeof u == "object") {
        if (u instanceof Uint8Array)
          return {
            $bytes: o.toString(u, "base64")
          };
        if (s.CID.asCID(u))
          return {
            $link: u.toString()
          };
        const f = {};
        for (const m of Object.keys(u))
          f[m] = (0, r.ipldToJson)(u[m]);
        return f;
      }
      return u;
    };
    r.ipldToJson = l;
    const a = (u, f) => {
      var m;
      if (Array.isArray(u) && Array.isArray(f)) {
        if (u.length !== f.length)
          return !1;
        for (let g = 0; g < u.length; g++)
          if (!(0, r.ipldEquals)(u[g], f[g]))
            return !1;
        return !0;
      }
      if (u && f && typeof u == "object" && typeof f == "object") {
        if (u instanceof Uint8Array && f instanceof Uint8Array)
          return o.equals(u, f);
        if (s.CID.asCID(u) && s.CID.asCID(f))
          return (m = s.CID.asCID(u)) == null ? void 0 : m.equals(s.CID.asCID(f));
        if (Object.keys(u).length !== Object.keys(f).length)
          return !1;
        for (const g of Object.keys(u))
          if (!(0, r.ipldEquals)(u[g], f[g]))
            return !1;
        return !0;
      }
      return u === f;
    };
    r.ipldEquals = a;
  }(vr)), vr;
}
var bi = {}, Cc;
function Og() {
  if (Cc) return bi;
  Cc = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.retry = t, bi.createRetryable = i, bi.backoffMs = n;
  const r = rs();
  async function t(e, l = {}) {
    const { maxRetries: a = 3, retryable: u = () => !0, getWaitMs: f = n } = l;
    let m = 0, g;
    for (; !g; )
      try {
        return await e();
      } catch (A) {
        const v = f(m);
        m < a && v !== null && u(A) ? (m += 1, v !== 0 && await (0, r.wait)(v)) : g = A;
      }
    throw g;
  }
  function i(e) {
    return async (l, a) => t(l, { ...a, retryable: e });
  }
  function n(e, l = 100, a = 1e3) {
    const u = Math.pow(2, e) * l, f = Math.min(u, a);
    return s(f);
  }
  function s(e) {
    const l = e * 0.15;
    return e + o(-l, l);
  }
  function o(e, l) {
    return Math.random() * (l - e) + e;
  }
  return bi;
}
var gu = {}, Tc;
function Mg() {
  return Tc || (Tc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.def = r.schema = void 0;
    const t = yn, i = /* @__PURE__ */ fi(), n = i.z.any().refine((o) => t.CID.asCID(o) !== null, {
      message: "Not a CID"
    }).transform((o) => t.CID.asCID(o)), s = i.z.object({
      version: i.z.literal(1),
      roots: i.z.array(n)
    });
    r.schema = {
      cid: n,
      carHeader: s,
      bytes: i.z.instanceof(Uint8Array),
      string: i.z.string(),
      array: i.z.array(i.z.unknown()),
      map: i.z.record(i.z.string(), i.z.unknown()),
      unknown: i.z.unknown()
    }, r.def = {
      cid: {
        name: "cid",
        schema: r.schema.cid
      },
      carHeader: {
        name: "CAR header",
        schema: r.schema.carHeader
      },
      bytes: {
        name: "bytes",
        schema: r.schema.bytes
      },
      string: {
        name: "string",
        schema: r.schema.string
      },
      map: {
        name: "map",
        schema: r.schema.map
      },
      unknown: {
        name: "unknown",
        schema: r.schema.unknown
      }
    };
  }(gu)), gu;
}
var Eu = {}, Sc;
function Ng() {
  return Sc || (Sc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.addHoursToDate = r.lessThanAgoMs = r.DAY = r.HOUR = r.MINUTE = r.SECOND = void 0, r.SECOND = 1e3, r.MINUTE = r.SECOND * 60, r.HOUR = r.MINUTE * 60, r.DAY = r.HOUR * 24;
    const t = (n, s) => Date.now() < n.getTime() + s;
    r.lessThanAgoMs = t;
    const i = (n, s) => {
      const o = s ? new Date(s) : /* @__PURE__ */ new Date();
      return o.setHours(o.getHours() + n), o;
    };
    r.addHoursToDate = i;
  }(Eu)), Eu;
}
var De = {}, gi = {}, Ei = {}, xu = {}, wc;
function Uh() {
  return wc || (wc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.EXTENDED_PICTOGRAPHIC = r.CLUSTER_BREAK = void 0, function(t) {
      t[t.CR = 0] = "CR", t[t.LF = 1] = "LF", t[t.CONTROL = 2] = "CONTROL", t[t.EXTEND = 3] = "EXTEND", t[t.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", t[t.SPACINGMARK = 5] = "SPACINGMARK", t[t.L = 6] = "L", t[t.V = 7] = "V", t[t.T = 8] = "T", t[t.LV = 9] = "LV", t[t.LVT = 10] = "LVT", t[t.OTHER = 11] = "OTHER", t[t.PREPEND = 12] = "PREPEND", t[t.E_BASE = 13] = "E_BASE", t[t.E_MODIFIER = 14] = "E_MODIFIER", t[t.ZWJ = 15] = "ZWJ", t[t.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", t[t.E_BASE_GAZ = 17] = "E_BASE_GAZ";
    }(r.CLUSTER_BREAK || (r.CLUSTER_BREAK = {})), r.EXTENDED_PICTOGRAPHIC = 101;
  }(xu)), xu;
}
var fs = {}, Lc;
function Gg() {
  if (Lc) return fs;
  Lc = 1, Object.defineProperty(fs, "__esModule", { value: !0 });
  const r = Uh(), t = 0, i = 1, n = 2, s = 3, o = 4;
  let e = class {
    /**
     * Check if the the character at the position {pos} of the string is surrogate
     * @param str {string}
     * @param pos {number}
     * @returns {boolean}
     */
    static isSurrogate(a, u) {
      return 55296 <= a.charCodeAt(u) && a.charCodeAt(u) <= 56319 && 56320 <= a.charCodeAt(u + 1) && a.charCodeAt(u + 1) <= 57343;
    }
    /**
     * The String.prototype.codePointAt polyfill
     * Private function, gets a Unicode code point from a JavaScript UTF-16 string
     * handling surrogate pairs appropriately
     * @param str {string}
     * @param idx {number}
     * @returns {number}
     */
    static codePointAt(a, u) {
      u === void 0 && (u = 0);
      const f = a.charCodeAt(u);
      if (55296 <= f && f <= 56319 && u < a.length - 1) {
        const m = f, g = a.charCodeAt(u + 1);
        return 56320 <= g && g <= 57343 ? (m - 55296) * 1024 + (g - 56320) + 65536 : m;
      }
      if (56320 <= f && f <= 57343 && u >= 1) {
        const m = a.charCodeAt(u - 1), g = f;
        return 55296 <= m && m <= 56319 ? (m - 55296) * 1024 + (g - 56320) + 65536 : g;
      }
      return f;
    }
    //
    /**
     * Private function, returns whether a break is allowed between the two given grapheme breaking classes
     * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
     * @param start {number}
     * @param mid {Array<number>}
     * @param end {number}
     * @param startEmoji {number}
     * @param midEmoji {Array<number>}
     * @param endEmoji {number}
     * @returns {number}
     */
    static shouldBreak(a, u, f, m, g, A) {
      const v = [a].concat(u).concat([f]), R = [m].concat(g).concat([A]), E = v[v.length - 2], h = f, C = A, K = v.lastIndexOf(r.CLUSTER_BREAK.REGIONAL_INDICATOR);
      if (K > 0 && v.slice(1, K).every(function(F) {
        return F === r.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }) && [r.CLUSTER_BREAK.PREPEND, r.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(E) === -1)
        return v.filter(function(F) {
          return F === r.CLUSTER_BREAK.REGIONAL_INDICATOR;
        }).length % 2 === 1 ? s : o;
      if (E === r.CLUSTER_BREAK.CR && h === r.CLUSTER_BREAK.LF)
        return t;
      if (E === r.CLUSTER_BREAK.CONTROL || E === r.CLUSTER_BREAK.CR || E === r.CLUSTER_BREAK.LF)
        return i;
      if (h === r.CLUSTER_BREAK.CONTROL || h === r.CLUSTER_BREAK.CR || h === r.CLUSTER_BREAK.LF)
        return i;
      if (E === r.CLUSTER_BREAK.L && (h === r.CLUSTER_BREAK.L || h === r.CLUSTER_BREAK.V || h === r.CLUSTER_BREAK.LV || h === r.CLUSTER_BREAK.LVT))
        return t;
      if ((E === r.CLUSTER_BREAK.LV || E === r.CLUSTER_BREAK.V) && (h === r.CLUSTER_BREAK.V || h === r.CLUSTER_BREAK.T))
        return t;
      if ((E === r.CLUSTER_BREAK.LVT || E === r.CLUSTER_BREAK.T) && h === r.CLUSTER_BREAK.T)
        return t;
      if (h === r.CLUSTER_BREAK.EXTEND || h === r.CLUSTER_BREAK.ZWJ)
        return t;
      if (h === r.CLUSTER_BREAK.SPACINGMARK)
        return t;
      if (E === r.CLUSTER_BREAK.PREPEND)
        return t;
      const k = R.slice(0, -1).lastIndexOf(r.EXTENDED_PICTOGRAPHIC);
      return k !== -1 && R[k] === r.EXTENDED_PICTOGRAPHIC && v.slice(k + 1, -2).every(function(F) {
        return F === r.CLUSTER_BREAK.EXTEND;
      }) && E === r.CLUSTER_BREAK.ZWJ && C === r.EXTENDED_PICTOGRAPHIC ? t : u.indexOf(r.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? n : E === r.CLUSTER_BREAK.REGIONAL_INDICATOR && h === r.CLUSTER_BREAK.REGIONAL_INDICATOR ? t : i;
    }
  };
  return fs.default = e, fs;
}
var ys = {}, kc;
function Fg() {
  if (kc) return ys;
  kc = 1, Object.defineProperty(ys, "__esModule", { value: !0 });
  let r = class {
    constructor(i, n) {
      this._index = 0, this._str = i, this._nextBreak = n;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let i;
      if ((i = this._nextBreak(this._str, this._index)) < this._str.length) {
        const n = this._str.slice(this._index, i);
        return this._index = i, { value: n, done: !1 };
      }
      if (this._index < this._str.length) {
        const n = this._str.slice(this._index);
        return this._index = this._str.length, { value: n, done: !1 };
      }
      return { value: void 0, done: !0 };
    }
  };
  return ys.default = r, ys;
}
var Dc;
function $g() {
  if (Dc) return Ei;
  Dc = 1;
  var r = Ei && Ei.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(Ei, "__esModule", { value: !0 });
  const t = Uh(), i = r(Gg()), n = r(Fg());
  let s = class Gr {
    /**
     * Returns the next grapheme break in the string after the given index
     * @param string {string}
     * @param index {number}
     * @returns {number}
     */
    static nextBreak(e, l) {
      if (l === void 0 && (l = 0), l < 0)
        return 0;
      if (l >= e.length - 1)
        return e.length;
      const a = i.default.codePointAt(e, l), u = Gr.getGraphemeBreakProperty(a), f = Gr.getEmojiProperty(a), m = [], g = [];
      for (let A = l + 1; A < e.length; A++) {
        if (i.default.isSurrogate(e, A - 1))
          continue;
        const v = i.default.codePointAt(e, A), R = Gr.getGraphemeBreakProperty(v), E = Gr.getEmojiProperty(v);
        if (i.default.shouldBreak(u, m, R, f, g, E))
          return A;
        m.push(R), g.push(E);
      }
      return e.length;
    }
    /**
     * Breaks the given string into an array of grapheme clusters
     * @param str {string}
     * @returns {string[]}
     */
    splitGraphemes(e) {
      const l = [];
      let a = 0, u;
      for (; (u = Gr.nextBreak(e, a)) < e.length; )
        l.push(e.slice(a, u)), a = u;
      return a < e.length && l.push(e.slice(a)), l;
    }
    /**
     * Returns an iterator of grapheme clusters in the given string
     * @param str {string}
     * @returns {GraphemerIterator}
     */
    iterateGraphemes(e) {
      return new n.default(e, Gr.nextBreak);
    }
    /**
     * Returns the number of grapheme clusters in the given string
     * @param str {string}
     * @returns {number}
     */
    countGraphemes(e) {
      let l = 0, a = 0, u;
      for (; (u = Gr.nextBreak(e, a)) < e.length; )
        a = u, l++;
      return a < e.length && l++, l;
    }
    /**
     * Given a Unicode code point, determines this symbol's grapheme break property
     * @param code {number} Unicode code point
     * @returns {number}
     */
    static getGraphemeBreakProperty(e) {
      if (e < 48905) {
        if (e < 44116) {
          if (e < 4141) {
            if (e < 2818) {
              if (e < 2363)
                if (e < 1759) {
                  if (e < 1471) {
                    if (e < 127) {
                      if (e < 11) {
                        if (e < 10) {
                          if (0 <= e && e <= 9)
                            return t.CLUSTER_BREAK.CONTROL;
                        } else if (e === 10)
                          return t.CLUSTER_BREAK.LF;
                      } else if (e < 13) {
                        if (11 <= e && e <= 12)
                          return t.CLUSTER_BREAK.CONTROL;
                      } else if (e < 14) {
                        if (e === 13)
                          return t.CLUSTER_BREAK.CR;
                      } else if (14 <= e && e <= 31)
                        return t.CLUSTER_BREAK.CONTROL;
                    } else if (e < 768) {
                      if (e < 173) {
                        if (127 <= e && e <= 159)
                          return t.CLUSTER_BREAK.CONTROL;
                      } else if (e === 173)
                        return t.CLUSTER_BREAK.CONTROL;
                    } else if (e < 1155) {
                      if (768 <= e && e <= 879)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1425) {
                      if (1155 <= e && e <= 1161)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (1425 <= e && e <= 1469)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1552) {
                    if (e < 1476) {
                      if (e < 1473) {
                        if (e === 1471)
                          return t.CLUSTER_BREAK.EXTEND;
                      } else if (1473 <= e && e <= 1474)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1479) {
                      if (1476 <= e && e <= 1477)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1536) {
                      if (e === 1479)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (1536 <= e && e <= 1541)
                      return t.CLUSTER_BREAK.PREPEND;
                  } else if (e < 1648) {
                    if (e < 1564) {
                      if (1552 <= e && e <= 1562)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1611) {
                      if (e === 1564)
                        return t.CLUSTER_BREAK.CONTROL;
                    } else if (1611 <= e && e <= 1631)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1750) {
                    if (e === 1648)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1757) {
                    if (1750 <= e && e <= 1756)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 1757)
                    return t.CLUSTER_BREAK.PREPEND;
                } else if (e < 2075) {
                  if (e < 1840)
                    if (e < 1770) {
                      if (e < 1767) {
                        if (1759 <= e && e <= 1764)
                          return t.CLUSTER_BREAK.EXTEND;
                      } else if (1767 <= e && e <= 1768)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 1807) {
                      if (1770 <= e && e <= 1773)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else {
                      if (e === 1807)
                        return t.CLUSTER_BREAK.PREPEND;
                      if (e === 1809)
                        return t.CLUSTER_BREAK.EXTEND;
                    }
                  else if (e < 2027) {
                    if (e < 1958) {
                      if (1840 <= e && e <= 1866)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (1958 <= e && e <= 1968)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2045) {
                    if (2027 <= e && e <= 2035)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2070) {
                    if (e === 2045)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (2070 <= e && e <= 2073)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2200) {
                  if (e < 2089) {
                    if (e < 2085) {
                      if (2075 <= e && e <= 2083)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (2085 <= e && e <= 2087)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2137) {
                    if (2089 <= e && e <= 2093)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2192) {
                    if (2137 <= e && e <= 2139)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (2192 <= e && e <= 2193)
                    return t.CLUSTER_BREAK.PREPEND;
                } else if (e < 2275) {
                  if (e < 2250) {
                    if (2200 <= e && e <= 2207)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2274) {
                    if (2250 <= e && e <= 2273)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2274)
                    return t.CLUSTER_BREAK.PREPEND;
                } else if (e < 2307) {
                  if (2275 <= e && e <= 2306)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 2307)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 2362)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 2561) {
                if (e < 2434) {
                  if (e < 2381) {
                    if (e < 2366) {
                      if (e === 2363)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                      if (e === 2364)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 2369) {
                      if (2366 <= e && e <= 2368)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e < 2377) {
                      if (2369 <= e && e <= 2376)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (2377 <= e && e <= 2380)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2385) {
                    if (e < 2382) {
                      if (e === 2381)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (2382 <= e && e <= 2383)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2402) {
                    if (2385 <= e && e <= 2391)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2433) {
                    if (2402 <= e && e <= 2403)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2433)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2503) {
                  if (e < 2494) {
                    if (e < 2492) {
                      if (2434 <= e && e <= 2435)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2492)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2495) {
                    if (e === 2494)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2497) {
                    if (2495 <= e && e <= 2496)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2497 <= e && e <= 2500)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2519) {
                  if (e < 2507) {
                    if (2503 <= e && e <= 2504)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2509) {
                    if (2507 <= e && e <= 2508)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2509)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2530) {
                  if (e === 2519)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2558) {
                  if (2530 <= e && e <= 2531)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 2558)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2691) {
                if (e < 2631) {
                  if (e < 2620) {
                    if (e < 2563) {
                      if (2561 <= e && e <= 2562)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e === 2563)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2622) {
                    if (e === 2620)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2625) {
                    if (2622 <= e && e <= 2624)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2625 <= e && e <= 2626)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2672) {
                  if (e < 2635) {
                    if (2631 <= e && e <= 2632)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2641) {
                    if (2635 <= e && e <= 2637)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2641)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2677) {
                  if (2672 <= e && e <= 2673)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2689) {
                  if (e === 2677)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (2689 <= e && e <= 2690)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2761) {
                if (e < 2750) {
                  if (e === 2691)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 2748)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 2753) {
                  if (2750 <= e && e <= 2752)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2759) {
                  if (2753 <= e && e <= 2757)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (2759 <= e && e <= 2760)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2786) {
                if (e < 2763) {
                  if (e === 2761)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2765) {
                  if (2763 <= e && e <= 2764)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2765)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2810) {
                if (2786 <= e && e <= 2787)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 2817) {
                if (2810 <= e && e <= 2815)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 2817)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3315) {
              if (e < 3076) {
                if (e < 2946) {
                  if (e < 2887) {
                    if (e < 2878) {
                      if (e < 2876) {
                        if (2818 <= e && e <= 2819)
                          return t.CLUSTER_BREAK.SPACINGMARK;
                      } else if (e === 2876)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 2880) {
                      if (2878 <= e && e <= 2879)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 2881) {
                      if (e === 2880)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (2881 <= e && e <= 2884)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2893) {
                    if (e < 2891) {
                      if (2887 <= e && e <= 2888)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (2891 <= e && e <= 2892)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2901) {
                    if (e === 2893)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2914) {
                    if (2901 <= e && e <= 2903)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (2914 <= e && e <= 2915)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3014) {
                  if (e < 3007) {
                    if (e === 2946 || e === 3006)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3008) {
                    if (e === 3007)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 3009) {
                    if (e === 3008)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (3009 <= e && e <= 3010)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3031) {
                  if (e < 3018) {
                    if (3014 <= e && e <= 3016)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 3021) {
                    if (3018 <= e && e <= 3020)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 3021)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3072) {
                  if (e === 3031)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3073) {
                  if (e === 3072)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3073 <= e && e <= 3075)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3262) {
                if (e < 3146) {
                  if (e < 3134) {
                    if (e === 3076 || e === 3132)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3137) {
                    if (3134 <= e && e <= 3136)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3142) {
                    if (3137 <= e && e <= 3140)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3142 <= e && e <= 3144)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3201) {
                  if (e < 3157) {
                    if (3146 <= e && e <= 3149)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3170) {
                    if (3157 <= e && e <= 3158)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (3170 <= e && e <= 3171)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3202) {
                  if (e === 3201)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3260) {
                  if (3202 <= e && e <= 3203)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3260)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3270) {
                if (e < 3264) {
                  if (e === 3262)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 3263)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3266) {
                  if (3264 <= e && e <= 3265)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3267) {
                  if (e === 3266)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3267 <= e && e <= 3268)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3276) {
                if (e < 3271) {
                  if (e === 3270)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3274) {
                  if (3271 <= e && e <= 3272)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (3274 <= e && e <= 3275)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3285) {
                if (3276 <= e && e <= 3277)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3298) {
                if (3285 <= e && e <= 3286)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3298 <= e && e <= 3299)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3551) {
              if (e < 3406) {
                if (e < 3391) {
                  if (e < 3330) {
                    if (e < 3328) {
                      if (e === 3315)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (3328 <= e && e <= 3329)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 3387) {
                    if (3330 <= e && e <= 3331)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 3390) {
                    if (3387 <= e && e <= 3388)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 3390)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3398) {
                  if (e < 3393) {
                    if (3391 <= e && e <= 3392)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3393 <= e && e <= 3396)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3402) {
                  if (3398 <= e && e <= 3400)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3405) {
                  if (3402 <= e && e <= 3404)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3405)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3530) {
                if (e < 3426) {
                  if (e === 3406)
                    return t.CLUSTER_BREAK.PREPEND;
                  if (e === 3415)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3457) {
                  if (3426 <= e && e <= 3427)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3458) {
                  if (e === 3457)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3458 <= e && e <= 3459)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3538) {
                if (e < 3535) {
                  if (e === 3530)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3536) {
                  if (e === 3535)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (3536 <= e && e <= 3537)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3542) {
                if (3538 <= e && e <= 3540)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3544) {
                if (e === 3542)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3544 <= e && e <= 3550)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3893) {
              if (e < 3655) {
                if (e < 3633) {
                  if (e < 3570) {
                    if (e === 3551)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (3570 <= e && e <= 3571)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3635) {
                  if (e === 3633)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 3636) {
                  if (e === 3635)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (3636 <= e && e <= 3642)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3764)
                if (e < 3761) {
                  if (3655 <= e && e <= 3662)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 3761)
                    return t.CLUSTER_BREAK.EXTEND;
                  if (e === 3763)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                }
              else if (e < 3784) {
                if (3764 <= e && e <= 3772)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3864) {
                if (3784 <= e && e <= 3790)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3864 <= e && e <= 3865)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3967) {
              if (e < 3897) {
                if (e === 3893 || e === 3895)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3902) {
                if (e === 3897)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 3953) {
                if (3902 <= e && e <= 3903)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (3953 <= e && e <= 3966)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3981) {
              if (e < 3968) {
                if (e === 3967)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3974) {
                if (3968 <= e && e <= 3972)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (3974 <= e && e <= 3975)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 3993) {
              if (3981 <= e && e <= 3991)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 4038) {
              if (3993 <= e && e <= 4028)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 4038)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 7204) {
            if (e < 6448) {
              if (e < 5938) {
                if (e < 4226) {
                  if (e < 4157) {
                    if (e < 4146) {
                      if (e < 4145) {
                        if (4141 <= e && e <= 4144)
                          return t.CLUSTER_BREAK.EXTEND;
                      } else if (e === 4145)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e < 4153) {
                      if (4146 <= e && e <= 4151)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e < 4155) {
                      if (4153 <= e && e <= 4154)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (4155 <= e && e <= 4156)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4184) {
                    if (e < 4182) {
                      if (4157 <= e && e <= 4158)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (4182 <= e && e <= 4183)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4190) {
                    if (4184 <= e && e <= 4185)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4209) {
                    if (4190 <= e && e <= 4192)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (4209 <= e && e <= 4212)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 4352) {
                  if (e < 4229) {
                    if (e === 4226)
                      return t.CLUSTER_BREAK.EXTEND;
                    if (e === 4228)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4237) {
                    if (4229 <= e && e <= 4230)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 4237 || e === 4253)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 4957) {
                  if (e < 4448) {
                    if (4352 <= e && e <= 4447)
                      return t.CLUSTER_BREAK.L;
                  } else if (e < 4520) {
                    if (4448 <= e && e <= 4519)
                      return t.CLUSTER_BREAK.V;
                  } else if (4520 <= e && e <= 4607)
                    return t.CLUSTER_BREAK.T;
                } else if (e < 5906) {
                  if (4957 <= e && e <= 4959)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 5909) {
                  if (5906 <= e && e <= 5908)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 5909)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6089) {
                if (e < 6070) {
                  if (e < 5970) {
                    if (e < 5940) {
                      if (5938 <= e && e <= 5939)
                        return t.CLUSTER_BREAK.EXTEND;
                    } else if (e === 5940)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 6002) {
                    if (5970 <= e && e <= 5971)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 6068) {
                    if (6002 <= e && e <= 6003)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (6068 <= e && e <= 6069)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6078) {
                  if (e < 6071) {
                    if (e === 6070)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (6071 <= e && e <= 6077)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6086) {
                  if (6078 <= e && e <= 6085)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6087) {
                  if (e === 6086)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6087 <= e && e <= 6088)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6277)
                if (e < 6155) {
                  if (e < 6109) {
                    if (6089 <= e && e <= 6099)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 6109)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6158) {
                  if (6155 <= e && e <= 6157)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 6158)
                    return t.CLUSTER_BREAK.CONTROL;
                  if (e === 6159)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 6435) {
                if (e < 6313) {
                  if (6277 <= e && e <= 6278)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6432) {
                  if (e === 6313)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6432 <= e && e <= 6434)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 6439) {
                if (6435 <= e && e <= 6438)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6441) {
                if (6439 <= e && e <= 6440)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (6441 <= e && e <= 6443)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6971) {
              if (e < 6744)
                if (e < 6681) {
                  if (e < 6451) {
                    if (e < 6450) {
                      if (6448 <= e && e <= 6449)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 6450)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 6457) {
                    if (6451 <= e && e <= 6456)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 6679) {
                    if (6457 <= e && e <= 6459)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (6679 <= e && e <= 6680)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6741) {
                  if (e < 6683) {
                    if (6681 <= e && e <= 6682)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6683)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6742) {
                  if (e === 6741)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else {
                  if (e === 6742)
                    return t.CLUSTER_BREAK.EXTEND;
                  if (e === 6743)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                }
              else if (e < 6771) {
                if (e < 6754) {
                  if (e < 6752) {
                    if (6744 <= e && e <= 6750)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 6752)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6757) {
                  if (e === 6754)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6765) {
                  if (6757 <= e && e <= 6764)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6765 <= e && e <= 6770)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6912) {
                if (e < 6783) {
                  if (6771 <= e && e <= 6780)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6832) {
                  if (e === 6783)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6832 <= e && e <= 6862)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 6916) {
                if (6912 <= e && e <= 6915)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 6964) {
                if (e === 6916)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (6964 <= e && e <= 6970)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 7080) {
              if (e < 7019) {
                if (e < 6973) {
                  if (e === 6971)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 6972)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 6978) {
                  if (6973 <= e && e <= 6977)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6979) {
                  if (e === 6978)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (6979 <= e && e <= 6980)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7073) {
                if (e < 7040) {
                  if (7019 <= e && e <= 7027)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 7042) {
                  if (7040 <= e && e <= 7041)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 7042)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7074) {
                if (e === 7073)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7078) {
                if (7074 <= e && e <= 7077)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (7078 <= e && e <= 7079)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7144)
              if (e < 7083) {
                if (e < 7082) {
                  if (7080 <= e && e <= 7081)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 7082)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7142) {
                if (7083 <= e && e <= 7085)
                  return t.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 7142)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 7143)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 7150) {
              if (e < 7146) {
                if (7144 <= e && e <= 7145)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 7149) {
                if (7146 <= e && e <= 7148)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 7149)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 7151) {
              if (e === 7150)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7154) {
              if (7151 <= e && e <= 7153)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (7154 <= e && e <= 7155)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43346) {
            if (e < 11647) {
              if (e < 7415) {
                if (e < 7380) {
                  if (e < 7220) {
                    if (e < 7212) {
                      if (7204 <= e && e <= 7211)
                        return t.CLUSTER_BREAK.SPACINGMARK;
                    } else if (7212 <= e && e <= 7219)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e < 7222) {
                    if (7220 <= e && e <= 7221)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 7376) {
                    if (7222 <= e && e <= 7223)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (7376 <= e && e <= 7378)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 7394) {
                  if (e < 7393) {
                    if (7380 <= e && e <= 7392)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 7393)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7405) {
                  if (7394 <= e && e <= 7400)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e === 7405 || e === 7412)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 8205)
                if (e < 7616) {
                  if (e < 7416) {
                    if (e === 7415)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7416 <= e && e <= 7417)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 8203) {
                  if (7616 <= e && e <= 7679)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 8203)
                    return t.CLUSTER_BREAK.CONTROL;
                  if (e === 8204)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 8288) {
                if (e < 8206) {
                  if (e === 8205)
                    return t.CLUSTER_BREAK.ZWJ;
                } else if (e < 8232) {
                  if (8206 <= e && e <= 8207)
                    return t.CLUSTER_BREAK.CONTROL;
                } else if (8232 <= e && e <= 8238)
                  return t.CLUSTER_BREAK.CONTROL;
              } else if (e < 8400) {
                if (8288 <= e && e <= 8303)
                  return t.CLUSTER_BREAK.CONTROL;
              } else if (e < 11503) {
                if (8400 <= e && e <= 8432)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (11503 <= e && e <= 11505)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43043) {
              if (e < 42612) {
                if (e < 12330) {
                  if (e < 11744) {
                    if (e === 11647)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (11744 <= e && e <= 11775)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 12441) {
                  if (12330 <= e && e <= 12335)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 42607) {
                  if (12441 <= e && e <= 12442)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (42607 <= e && e <= 42610)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43010) {
                if (e < 42654) {
                  if (42612 <= e && e <= 42621)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 42736) {
                  if (42654 <= e && e <= 42655)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (42736 <= e && e <= 42737)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43014) {
                if (e === 43010)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 43014 || e === 43019)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43188) {
              if (e < 43047) {
                if (e < 43045) {
                  if (43043 <= e && e <= 43044)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (43045 <= e && e <= 43046)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43052) {
                if (e === 43047)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43136) {
                if (e === 43052)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43136 <= e && e <= 43137)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43263) {
              if (e < 43204) {
                if (43188 <= e && e <= 43203)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43232) {
                if (43204 <= e && e <= 43205)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43232 <= e && e <= 43249)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43302) {
              if (e === 43263)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43335) {
              if (43302 <= e && e <= 43309)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (43335 <= e && e <= 43345)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 43698) {
            if (e < 43493) {
              if (e < 43444)
                if (e < 43392) {
                  if (e < 43360) {
                    if (43346 <= e && e <= 43347)
                      return t.CLUSTER_BREAK.SPACINGMARK;
                  } else if (43360 <= e && e <= 43388)
                    return t.CLUSTER_BREAK.L;
                } else if (e < 43395) {
                  if (43392 <= e && e <= 43394)
                    return t.CLUSTER_BREAK.EXTEND;
                } else {
                  if (e === 43395)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                  if (e === 43443)
                    return t.CLUSTER_BREAK.EXTEND;
                }
              else if (e < 43450) {
                if (e < 43446) {
                  if (43444 <= e && e <= 43445)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (43446 <= e && e <= 43449)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43452) {
                if (43450 <= e && e <= 43451)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43454) {
                if (43452 <= e && e <= 43453)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43454 <= e && e <= 43456)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43573) {
              if (e < 43567) {
                if (e < 43561) {
                  if (e === 43493)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (43561 <= e && e <= 43566)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43569) {
                if (43567 <= e && e <= 43568)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 43571) {
                if (43569 <= e && e <= 43570)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (43571 <= e && e <= 43572)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43597) {
              if (e < 43587) {
                if (43573 <= e && e <= 43574)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 43587 || e === 43596)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 43644) {
              if (e === 43597)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43644 || e === 43696)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 44006) {
            if (e < 43756)
              if (e < 43710) {
                if (e < 43703) {
                  if (43698 <= e && e <= 43700)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (43703 <= e && e <= 43704)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43713) {
                if (43710 <= e && e <= 43711)
                  return t.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43713)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 43755)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 43766) {
              if (e < 43758) {
                if (43756 <= e && e <= 43757)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 43765) {
                if (43758 <= e && e <= 43759)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 43765)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 44003) {
              if (e === 43766)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 44005) {
              if (44003 <= e && e <= 44004)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44005)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 44032)
            if (e < 44009) {
              if (e < 44008) {
                if (44006 <= e && e <= 44007)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 44008)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 44012) {
              if (44009 <= e && e <= 44010)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 44012)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 44013)
                return t.CLUSTER_BREAK.EXTEND;
            }
          else if (e < 44061) {
            if (e < 44033) {
              if (e === 44032)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 44060) {
              if (44033 <= e && e <= 44059)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 44060)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 44088) {
            if (44061 <= e && e <= 44087)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 44089) {
            if (e === 44088)
              return t.CLUSTER_BREAK.LV;
          } else if (44089 <= e && e <= 44115)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 46497) {
          if (e < 45293) {
            if (e < 44704) {
              if (e < 44397) {
                if (e < 44256) {
                  if (e < 44173) {
                    if (e < 44144) {
                      if (e < 44117) {
                        if (e === 44116)
                          return t.CLUSTER_BREAK.LV;
                      } else if (44117 <= e && e <= 44143)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e < 44145) {
                      if (e === 44144)
                        return t.CLUSTER_BREAK.LV;
                    } else if (e < 44172) {
                      if (44145 <= e && e <= 44171)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 44172)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44201) {
                    if (e < 44200) {
                      if (44173 <= e && e <= 44199)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 44200)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44228) {
                    if (44201 <= e && e <= 44227)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44229) {
                    if (e === 44228)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44229 <= e && e <= 44255)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44313) {
                  if (e < 44284) {
                    if (e < 44257) {
                      if (e === 44256)
                        return t.CLUSTER_BREAK.LV;
                    } else if (44257 <= e && e <= 44283)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44285) {
                    if (e === 44284)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44312) {
                    if (44285 <= e && e <= 44311)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44312)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44368) {
                  if (e < 44340) {
                    if (44313 <= e && e <= 44339)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44341) {
                    if (e === 44340)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44341 <= e && e <= 44367)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44369) {
                  if (e === 44368)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44396) {
                  if (44369 <= e && e <= 44395)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44396)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44537) {
                if (e < 44480) {
                  if (e < 44425) {
                    if (e < 44424) {
                      if (44397 <= e && e <= 44423)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 44424)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44452) {
                    if (44425 <= e && e <= 44451)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44453) {
                    if (e === 44452)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44453 <= e && e <= 44479)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44508) {
                  if (e < 44481) {
                    if (e === 44480)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44481 <= e && e <= 44507)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44509) {
                  if (e === 44508)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44536) {
                  if (44509 <= e && e <= 44535)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44536)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44620) {
                if (e < 44565) {
                  if (e < 44564) {
                    if (44537 <= e && e <= 44563)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44564)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44592) {
                  if (44565 <= e && e <= 44591)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44593) {
                  if (e === 44592)
                    return t.CLUSTER_BREAK.LV;
                } else if (44593 <= e && e <= 44619)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44649) {
                if (e < 44621) {
                  if (e === 44620)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44648) {
                  if (44621 <= e && e <= 44647)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44648)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44676) {
                if (44649 <= e && e <= 44675)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44677) {
                if (e === 44676)
                  return t.CLUSTER_BREAK.LV;
              } else if (44677 <= e && e <= 44703)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 44985) {
              if (e < 44844) {
                if (e < 44761) {
                  if (e < 44732) {
                    if (e < 44705) {
                      if (e === 44704)
                        return t.CLUSTER_BREAK.LV;
                    } else if (44705 <= e && e <= 44731)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 44733) {
                    if (e === 44732)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 44760) {
                    if (44733 <= e && e <= 44759)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44760)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44789) {
                  if (e < 44788) {
                    if (44761 <= e && e <= 44787)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 44788)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44816) {
                  if (44789 <= e && e <= 44815)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44817) {
                  if (e === 44816)
                    return t.CLUSTER_BREAK.LV;
                } else if (44817 <= e && e <= 44843)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44901) {
                if (e < 44872) {
                  if (e < 44845) {
                    if (e === 44844)
                      return t.CLUSTER_BREAK.LV;
                  } else if (44845 <= e && e <= 44871)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44873) {
                  if (e === 44872)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 44900) {
                  if (44873 <= e && e <= 44899)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 44900)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44956) {
                if (e < 44928) {
                  if (44901 <= e && e <= 44927)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 44929) {
                  if (e === 44928)
                    return t.CLUSTER_BREAK.LV;
                } else if (44929 <= e && e <= 44955)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 44957) {
                if (e === 44956)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 44984) {
                if (44957 <= e && e <= 44983)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 44984)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45152) {
              if (e < 45068) {
                if (e < 45013) {
                  if (e < 45012) {
                    if (44985 <= e && e <= 45011)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 45012)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45040) {
                  if (45013 <= e && e <= 45039)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45041) {
                  if (e === 45040)
                    return t.CLUSTER_BREAK.LV;
                } else if (45041 <= e && e <= 45067)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45097) {
                if (e < 45069) {
                  if (e === 45068)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45096) {
                  if (45069 <= e && e <= 45095)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45096)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45124) {
                if (45097 <= e && e <= 45123)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45125) {
                if (e === 45124)
                  return t.CLUSTER_BREAK.LV;
              } else if (45125 <= e && e <= 45151)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45209) {
              if (e < 45180) {
                if (e < 45153) {
                  if (e === 45152)
                    return t.CLUSTER_BREAK.LV;
                } else if (45153 <= e && e <= 45179)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45181) {
                if (e === 45180)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45208) {
                if (45181 <= e && e <= 45207)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 45208)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45264) {
              if (e < 45236) {
                if (45209 <= e && e <= 45235)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45237) {
                if (e === 45236)
                  return t.CLUSTER_BREAK.LV;
              } else if (45237 <= e && e <= 45263)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45265) {
              if (e === 45264)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45292) {
              if (45265 <= e && e <= 45291)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 45292)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 45908) {
            if (e < 45600) {
              if (e < 45433) {
                if (e < 45376) {
                  if (e < 45321) {
                    if (e < 45320) {
                      if (45293 <= e && e <= 45319)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 45320)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 45348) {
                    if (45321 <= e && e <= 45347)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 45349) {
                    if (e === 45348)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45349 <= e && e <= 45375)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45404) {
                  if (e < 45377) {
                    if (e === 45376)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45377 <= e && e <= 45403)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45405) {
                  if (e === 45404)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45432) {
                  if (45405 <= e && e <= 45431)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45432)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45516) {
                if (e < 45461) {
                  if (e < 45460) {
                    if (45433 <= e && e <= 45459)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 45460)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45488) {
                  if (45461 <= e && e <= 45487)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45489) {
                  if (e === 45488)
                    return t.CLUSTER_BREAK.LV;
                } else if (45489 <= e && e <= 45515)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45545) {
                if (e < 45517) {
                  if (e === 45516)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45544) {
                  if (45517 <= e && e <= 45543)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45544)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45572) {
                if (45545 <= e && e <= 45571)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45573) {
                if (e === 45572)
                  return t.CLUSTER_BREAK.LV;
              } else if (45573 <= e && e <= 45599)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45741) {
              if (e < 45657) {
                if (e < 45628) {
                  if (e < 45601) {
                    if (e === 45600)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45601 <= e && e <= 45627)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45629) {
                  if (e === 45628)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45656) {
                  if (45629 <= e && e <= 45655)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45656)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45712) {
                if (e < 45684) {
                  if (45657 <= e && e <= 45683)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45685) {
                  if (e === 45684)
                    return t.CLUSTER_BREAK.LV;
                } else if (45685 <= e && e <= 45711)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45713) {
                if (e === 45712)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45740) {
                if (45713 <= e && e <= 45739)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 45740)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45824) {
              if (e < 45769) {
                if (e < 45768) {
                  if (45741 <= e && e <= 45767)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45768)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45796) {
                if (45769 <= e && e <= 45795)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 45797) {
                if (e === 45796)
                  return t.CLUSTER_BREAK.LV;
              } else if (45797 <= e && e <= 45823)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45853) {
              if (e < 45825) {
                if (e === 45824)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45852) {
                if (45825 <= e && e <= 45851)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 45852)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 45880) {
              if (45853 <= e && e <= 45879)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 45881) {
              if (e === 45880)
                return t.CLUSTER_BREAK.LV;
            } else if (45881 <= e && e <= 45907)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 46189) {
            if (e < 46048) {
              if (e < 45965) {
                if (e < 45936) {
                  if (e < 45909) {
                    if (e === 45908)
                      return t.CLUSTER_BREAK.LV;
                  } else if (45909 <= e && e <= 45935)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 45937) {
                  if (e === 45936)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 45964) {
                  if (45937 <= e && e <= 45963)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45964)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 45993) {
                if (e < 45992) {
                  if (45965 <= e && e <= 45991)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 45992)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46020) {
                if (45993 <= e && e <= 46019)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46021) {
                if (e === 46020)
                  return t.CLUSTER_BREAK.LV;
              } else if (46021 <= e && e <= 46047)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46105) {
              if (e < 46076) {
                if (e < 46049) {
                  if (e === 46048)
                    return t.CLUSTER_BREAK.LV;
                } else if (46049 <= e && e <= 46075)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46077) {
                if (e === 46076)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46104) {
                if (46077 <= e && e <= 46103)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 46104)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46160) {
              if (e < 46132) {
                if (46105 <= e && e <= 46131)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46133) {
                if (e === 46132)
                  return t.CLUSTER_BREAK.LV;
              } else if (46133 <= e && e <= 46159)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46161) {
              if (e === 46160)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46188) {
              if (46161 <= e && e <= 46187)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 46188)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 46356) {
            if (e < 46272) {
              if (e < 46217) {
                if (e < 46216) {
                  if (46189 <= e && e <= 46215)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46216)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46244) {
                if (46217 <= e && e <= 46243)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46245) {
                if (e === 46244)
                  return t.CLUSTER_BREAK.LV;
              } else if (46245 <= e && e <= 46271)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46301) {
              if (e < 46273) {
                if (e === 46272)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46300) {
                if (46273 <= e && e <= 46299)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 46300)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46328) {
              if (46301 <= e && e <= 46327)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46329) {
              if (e === 46328)
                return t.CLUSTER_BREAK.LV;
            } else if (46329 <= e && e <= 46355)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 46413) {
            if (e < 46384) {
              if (e < 46357) {
                if (e === 46356)
                  return t.CLUSTER_BREAK.LV;
              } else if (46357 <= e && e <= 46383)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46385) {
              if (e === 46384)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 46412) {
              if (46385 <= e && e <= 46411)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 46412)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 46468) {
            if (e < 46440) {
              if (46413 <= e && e <= 46439)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46441) {
              if (e === 46440)
                return t.CLUSTER_BREAK.LV;
            } else if (46441 <= e && e <= 46467)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 46469) {
            if (e === 46468)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 46496) {
            if (46469 <= e && e <= 46495)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 46496)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 47701) {
          if (e < 47112) {
            if (e < 46804) {
              if (e < 46637) {
                if (e < 46580) {
                  if (e < 46525) {
                    if (e < 46524) {
                      if (46497 <= e && e <= 46523)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 46524)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 46552) {
                    if (46525 <= e && e <= 46551)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 46553) {
                    if (e === 46552)
                      return t.CLUSTER_BREAK.LV;
                  } else if (46553 <= e && e <= 46579)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46608) {
                  if (e < 46581) {
                    if (e === 46580)
                      return t.CLUSTER_BREAK.LV;
                  } else if (46581 <= e && e <= 46607)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46609) {
                  if (e === 46608)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46636) {
                  if (46609 <= e && e <= 46635)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46636)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46720) {
                if (e < 46665) {
                  if (e < 46664) {
                    if (46637 <= e && e <= 46663)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 46664)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46692) {
                  if (46665 <= e && e <= 46691)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46693) {
                  if (e === 46692)
                    return t.CLUSTER_BREAK.LV;
                } else if (46693 <= e && e <= 46719)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46749) {
                if (e < 46721) {
                  if (e === 46720)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46748) {
                  if (46721 <= e && e <= 46747)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46748)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46776) {
                if (46749 <= e && e <= 46775)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46777) {
                if (e === 46776)
                  return t.CLUSTER_BREAK.LV;
              } else if (46777 <= e && e <= 46803)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 46945) {
              if (e < 46861) {
                if (e < 46832) {
                  if (e < 46805) {
                    if (e === 46804)
                      return t.CLUSTER_BREAK.LV;
                  } else if (46805 <= e && e <= 46831)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46833) {
                  if (e === 46832)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 46860) {
                  if (46833 <= e && e <= 46859)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46860)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46916) {
                if (e < 46888) {
                  if (46861 <= e && e <= 46887)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 46889) {
                  if (e === 46888)
                    return t.CLUSTER_BREAK.LV;
                } else if (46889 <= e && e <= 46915)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 46917) {
                if (e === 46916)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 46944) {
                if (46917 <= e && e <= 46943)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 46944)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47028) {
              if (e < 46973) {
                if (e < 46972) {
                  if (46945 <= e && e <= 46971)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 46972)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47e3) {
                if (46973 <= e && e <= 46999)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47001) {
                if (e === 47e3)
                  return t.CLUSTER_BREAK.LV;
              } else if (47001 <= e && e <= 47027)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47057) {
              if (e < 47029) {
                if (e === 47028)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47056) {
                if (47029 <= e && e <= 47055)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47056)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47084) {
              if (47057 <= e && e <= 47083)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47085) {
              if (e === 47084)
                return t.CLUSTER_BREAK.LV;
            } else if (47085 <= e && e <= 47111)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 47393) {
            if (e < 47252) {
              if (e < 47169) {
                if (e < 47140) {
                  if (e < 47113) {
                    if (e === 47112)
                      return t.CLUSTER_BREAK.LV;
                  } else if (47113 <= e && e <= 47139)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 47141) {
                  if (e === 47140)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 47168) {
                  if (47141 <= e && e <= 47167)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47168)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47197) {
                if (e < 47196) {
                  if (47169 <= e && e <= 47195)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47196)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47224) {
                if (47197 <= e && e <= 47223)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47225) {
                if (e === 47224)
                  return t.CLUSTER_BREAK.LV;
              } else if (47225 <= e && e <= 47251)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47309) {
              if (e < 47280) {
                if (e < 47253) {
                  if (e === 47252)
                    return t.CLUSTER_BREAK.LV;
                } else if (47253 <= e && e <= 47279)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47281) {
                if (e === 47280)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47308) {
                if (47281 <= e && e <= 47307)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47308)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47364) {
              if (e < 47336) {
                if (47309 <= e && e <= 47335)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47337) {
                if (e === 47336)
                  return t.CLUSTER_BREAK.LV;
              } else if (47337 <= e && e <= 47363)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47365) {
              if (e === 47364)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47392) {
              if (47365 <= e && e <= 47391)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 47392)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 47560) {
            if (e < 47476) {
              if (e < 47421) {
                if (e < 47420) {
                  if (47393 <= e && e <= 47419)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47420)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47448) {
                if (47421 <= e && e <= 47447)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47449) {
                if (e === 47448)
                  return t.CLUSTER_BREAK.LV;
              } else if (47449 <= e && e <= 47475)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47505) {
              if (e < 47477) {
                if (e === 47476)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47504) {
                if (47477 <= e && e <= 47503)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47504)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47532) {
              if (47505 <= e && e <= 47531)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47533) {
              if (e === 47532)
                return t.CLUSTER_BREAK.LV;
            } else if (47533 <= e && e <= 47559)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 47617) {
            if (e < 47588) {
              if (e < 47561) {
                if (e === 47560)
                  return t.CLUSTER_BREAK.LV;
              } else if (47561 <= e && e <= 47587)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47589) {
              if (e === 47588)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47616) {
              if (47589 <= e && e <= 47615)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 47616)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 47672) {
            if (e < 47644) {
              if (47617 <= e && e <= 47643)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47645) {
              if (e === 47644)
                return t.CLUSTER_BREAK.LV;
            } else if (47645 <= e && e <= 47671)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 47673) {
            if (e === 47672)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 47700) {
            if (47673 <= e && e <= 47699)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 47700)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48316) {
          if (e < 48008) {
            if (e < 47841) {
              if (e < 47784) {
                if (e < 47729) {
                  if (e < 47728) {
                    if (47701 <= e && e <= 47727)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 47728)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 47756) {
                  if (47729 <= e && e <= 47755)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 47757) {
                  if (e === 47756)
                    return t.CLUSTER_BREAK.LV;
                } else if (47757 <= e && e <= 47783)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47812) {
                if (e < 47785) {
                  if (e === 47784)
                    return t.CLUSTER_BREAK.LV;
                } else if (47785 <= e && e <= 47811)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47813) {
                if (e === 47812)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47840) {
                if (47813 <= e && e <= 47839)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47840)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47924) {
              if (e < 47869) {
                if (e < 47868) {
                  if (47841 <= e && e <= 47867)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 47868)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47896) {
                if (47869 <= e && e <= 47895)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 47897) {
                if (e === 47896)
                  return t.CLUSTER_BREAK.LV;
              } else if (47897 <= e && e <= 47923)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47953) {
              if (e < 47925) {
                if (e === 47924)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 47952) {
                if (47925 <= e && e <= 47951)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 47952)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 47980) {
              if (47953 <= e && e <= 47979)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 47981) {
              if (e === 47980)
                return t.CLUSTER_BREAK.LV;
            } else if (47981 <= e && e <= 48007)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48149) {
            if (e < 48065) {
              if (e < 48036) {
                if (e < 48009) {
                  if (e === 48008)
                    return t.CLUSTER_BREAK.LV;
                } else if (48009 <= e && e <= 48035)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 48037) {
                if (e === 48036)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 48064) {
                if (48037 <= e && e <= 48063)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48064)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48120) {
              if (e < 48092) {
                if (48065 <= e && e <= 48091)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 48093) {
                if (e === 48092)
                  return t.CLUSTER_BREAK.LV;
              } else if (48093 <= e && e <= 48119)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48121) {
              if (e === 48120)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48148) {
              if (48121 <= e && e <= 48147)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48148)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48232) {
            if (e < 48177) {
              if (e < 48176) {
                if (48149 <= e && e <= 48175)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48176)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48204) {
              if (48177 <= e && e <= 48203)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48205) {
              if (e === 48204)
                return t.CLUSTER_BREAK.LV;
            } else if (48205 <= e && e <= 48231)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48261) {
            if (e < 48233) {
              if (e === 48232)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48260) {
              if (48233 <= e && e <= 48259)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48260)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48288) {
            if (48261 <= e && e <= 48287)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48289) {
            if (e === 48288)
              return t.CLUSTER_BREAK.LV;
          } else if (48289 <= e && e <= 48315)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 48597) {
          if (e < 48456) {
            if (e < 48373) {
              if (e < 48344) {
                if (e < 48317) {
                  if (e === 48316)
                    return t.CLUSTER_BREAK.LV;
                } else if (48317 <= e && e <= 48343)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 48345) {
                if (e === 48344)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 48372) {
                if (48345 <= e && e <= 48371)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48372)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48401) {
              if (e < 48400) {
                if (48373 <= e && e <= 48399)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48400)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48428) {
              if (48401 <= e && e <= 48427)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48429) {
              if (e === 48428)
                return t.CLUSTER_BREAK.LV;
            } else if (48429 <= e && e <= 48455)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48513) {
            if (e < 48484) {
              if (e < 48457) {
                if (e === 48456)
                  return t.CLUSTER_BREAK.LV;
              } else if (48457 <= e && e <= 48483)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48485) {
              if (e === 48484)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48512) {
              if (48485 <= e && e <= 48511)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48512)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48568) {
            if (e < 48540) {
              if (48513 <= e && e <= 48539)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48541) {
              if (e === 48540)
                return t.CLUSTER_BREAK.LV;
            } else if (48541 <= e && e <= 48567)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48569) {
            if (e === 48568)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48596) {
            if (48569 <= e && e <= 48595)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 48596)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48764) {
          if (e < 48680) {
            if (e < 48625) {
              if (e < 48624) {
                if (48597 <= e && e <= 48623)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 48624)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48652) {
              if (48625 <= e && e <= 48651)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 48653) {
              if (e === 48652)
                return t.CLUSTER_BREAK.LV;
            } else if (48653 <= e && e <= 48679)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48709) {
            if (e < 48681) {
              if (e === 48680)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 48708) {
              if (48681 <= e && e <= 48707)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 48708)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48736) {
            if (48709 <= e && e <= 48735)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48737) {
            if (e === 48736)
              return t.CLUSTER_BREAK.LV;
          } else if (48737 <= e && e <= 48763)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 48821) {
          if (e < 48792) {
            if (e < 48765) {
              if (e === 48764)
                return t.CLUSTER_BREAK.LV;
            } else if (48765 <= e && e <= 48791)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48793) {
            if (e === 48792)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 48820) {
            if (48793 <= e && e <= 48819)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 48820)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48876) {
          if (e < 48848) {
            if (48821 <= e && e <= 48847)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 48849) {
            if (e === 48848)
              return t.CLUSTER_BREAK.LV;
          } else if (48849 <= e && e <= 48875)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 48877) {
          if (e === 48876)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 48904) {
          if (48877 <= e && e <= 48903)
            return t.CLUSTER_BREAK.LVT;
        } else if (e === 48904)
          return t.CLUSTER_BREAK.LV;
      } else if (e < 53720) {
        if (e < 51312) {
          if (e < 50108) {
            if (e < 49493) {
              if (e < 49212) {
                if (e < 49045) {
                  if (e < 48988) {
                    if (e < 48933) {
                      if (e < 48932) {
                        if (48905 <= e && e <= 48931)
                          return t.CLUSTER_BREAK.LVT;
                      } else if (e === 48932)
                        return t.CLUSTER_BREAK.LV;
                    } else if (e < 48960) {
                      if (48933 <= e && e <= 48959)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e < 48961) {
                      if (e === 48960)
                        return t.CLUSTER_BREAK.LV;
                    } else if (48961 <= e && e <= 48987)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49016) {
                    if (e < 48989) {
                      if (e === 48988)
                        return t.CLUSTER_BREAK.LV;
                    } else if (48989 <= e && e <= 49015)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49017) {
                    if (e === 49016)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49044) {
                    if (49017 <= e && e <= 49043)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49044)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49128) {
                  if (e < 49073) {
                    if (e < 49072) {
                      if (49045 <= e && e <= 49071)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 49072)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49100) {
                    if (49073 <= e && e <= 49099)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49101) {
                    if (e === 49100)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49101 <= e && e <= 49127)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49157) {
                  if (e < 49129) {
                    if (e === 49128)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49156) {
                    if (49129 <= e && e <= 49155)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49156)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49184) {
                  if (49157 <= e && e <= 49183)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49185) {
                  if (e === 49184)
                    return t.CLUSTER_BREAK.LV;
                } else if (49185 <= e && e <= 49211)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49352) {
                if (e < 49269) {
                  if (e < 49240) {
                    if (e < 49213) {
                      if (e === 49212)
                        return t.CLUSTER_BREAK.LV;
                    } else if (49213 <= e && e <= 49239)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49241) {
                    if (e === 49240)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49268) {
                    if (49241 <= e && e <= 49267)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49268)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49297) {
                  if (e < 49296) {
                    if (49269 <= e && e <= 49295)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49296)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49324) {
                  if (49297 <= e && e <= 49323)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49325) {
                  if (e === 49324)
                    return t.CLUSTER_BREAK.LV;
                } else if (49325 <= e && e <= 49351)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49409) {
                if (e < 49380) {
                  if (e < 49353) {
                    if (e === 49352)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49353 <= e && e <= 49379)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49381) {
                  if (e === 49380)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49408) {
                  if (49381 <= e && e <= 49407)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49408)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49464) {
                if (e < 49436) {
                  if (49409 <= e && e <= 49435)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49437) {
                  if (e === 49436)
                    return t.CLUSTER_BREAK.LV;
                } else if (49437 <= e && e <= 49463)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49465) {
                if (e === 49464)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49492) {
                if (49465 <= e && e <= 49491)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 49492)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 49800) {
              if (e < 49633) {
                if (e < 49576) {
                  if (e < 49521) {
                    if (e < 49520) {
                      if (49493 <= e && e <= 49519)
                        return t.CLUSTER_BREAK.LVT;
                    } else if (e === 49520)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 49548) {
                    if (49521 <= e && e <= 49547)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 49549) {
                    if (e === 49548)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49549 <= e && e <= 49575)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49604) {
                  if (e < 49577) {
                    if (e === 49576)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49577 <= e && e <= 49603)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49605) {
                  if (e === 49604)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49632) {
                  if (49605 <= e && e <= 49631)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49632)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49716) {
                if (e < 49661) {
                  if (e < 49660) {
                    if (49633 <= e && e <= 49659)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 49660)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49688) {
                  if (49661 <= e && e <= 49687)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49689) {
                  if (e === 49688)
                    return t.CLUSTER_BREAK.LV;
                } else if (49689 <= e && e <= 49715)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49745) {
                if (e < 49717) {
                  if (e === 49716)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49744) {
                  if (49717 <= e && e <= 49743)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49744)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49772) {
                if (49745 <= e && e <= 49771)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49773) {
                if (e === 49772)
                  return t.CLUSTER_BREAK.LV;
              } else if (49773 <= e && e <= 49799)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 49941) {
              if (e < 49857) {
                if (e < 49828) {
                  if (e < 49801) {
                    if (e === 49800)
                      return t.CLUSTER_BREAK.LV;
                  } else if (49801 <= e && e <= 49827)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49829) {
                  if (e === 49828)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 49856) {
                  if (49829 <= e && e <= 49855)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49856)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49912) {
                if (e < 49884) {
                  if (49857 <= e && e <= 49883)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 49885) {
                  if (e === 49884)
                    return t.CLUSTER_BREAK.LV;
                } else if (49885 <= e && e <= 49911)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49913) {
                if (e === 49912)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49940) {
                if (49913 <= e && e <= 49939)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 49940)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50024) {
              if (e < 49969) {
                if (e < 49968) {
                  if (49941 <= e && e <= 49967)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 49968)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 49996) {
                if (49969 <= e && e <= 49995)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 49997) {
                if (e === 49996)
                  return t.CLUSTER_BREAK.LV;
              } else if (49997 <= e && e <= 50023)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50053) {
              if (e < 50025) {
                if (e === 50024)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50052) {
                if (50025 <= e && e <= 50051)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50052)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50080) {
              if (50053 <= e && e <= 50079)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50081) {
              if (e === 50080)
                return t.CLUSTER_BREAK.LV;
            } else if (50081 <= e && e <= 50107)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 50697) {
            if (e < 50389) {
              if (e < 50248) {
                if (e < 50165) {
                  if (e < 50136) {
                    if (e < 50109) {
                      if (e === 50108)
                        return t.CLUSTER_BREAK.LV;
                    } else if (50109 <= e && e <= 50135)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 50137) {
                    if (e === 50136)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 50164) {
                    if (50137 <= e && e <= 50163)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50164)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50193) {
                  if (e < 50192) {
                    if (50165 <= e && e <= 50191)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50192)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50220) {
                  if (50193 <= e && e <= 50219)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50221) {
                  if (e === 50220)
                    return t.CLUSTER_BREAK.LV;
                } else if (50221 <= e && e <= 50247)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50305) {
                if (e < 50276) {
                  if (e < 50249) {
                    if (e === 50248)
                      return t.CLUSTER_BREAK.LV;
                  } else if (50249 <= e && e <= 50275)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50277) {
                  if (e === 50276)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50304) {
                  if (50277 <= e && e <= 50303)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 50304)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50360) {
                if (e < 50332) {
                  if (50305 <= e && e <= 50331)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50333) {
                  if (e === 50332)
                    return t.CLUSTER_BREAK.LV;
                } else if (50333 <= e && e <= 50359)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50361) {
                if (e === 50360)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50388) {
                if (50361 <= e && e <= 50387)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50388)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50556) {
              if (e < 50472) {
                if (e < 50417) {
                  if (e < 50416) {
                    if (50389 <= e && e <= 50415)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50416)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50444) {
                  if (50417 <= e && e <= 50443)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50445) {
                  if (e === 50444)
                    return t.CLUSTER_BREAK.LV;
                } else if (50445 <= e && e <= 50471)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50501) {
                if (e < 50473) {
                  if (e === 50472)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50500) {
                  if (50473 <= e && e <= 50499)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 50500)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50528) {
                if (50501 <= e && e <= 50527)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50529) {
                if (e === 50528)
                  return t.CLUSTER_BREAK.LV;
              } else if (50529 <= e && e <= 50555)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50613) {
              if (e < 50584) {
                if (e < 50557) {
                  if (e === 50556)
                    return t.CLUSTER_BREAK.LV;
                } else if (50557 <= e && e <= 50583)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50585) {
                if (e === 50584)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50612) {
                if (50585 <= e && e <= 50611)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50612)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50668) {
              if (e < 50640) {
                if (50613 <= e && e <= 50639)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50641) {
                if (e === 50640)
                  return t.CLUSTER_BREAK.LV;
              } else if (50641 <= e && e <= 50667)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50669) {
              if (e === 50668)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50696) {
              if (50669 <= e && e <= 50695)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 50696)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 51004) {
            if (e < 50837) {
              if (e < 50780) {
                if (e < 50725) {
                  if (e < 50724) {
                    if (50697 <= e && e <= 50723)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 50724)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 50752) {
                  if (50725 <= e && e <= 50751)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 50753) {
                  if (e === 50752)
                    return t.CLUSTER_BREAK.LV;
                } else if (50753 <= e && e <= 50779)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50808) {
                if (e < 50781) {
                  if (e === 50780)
                    return t.CLUSTER_BREAK.LV;
                } else if (50781 <= e && e <= 50807)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50809) {
                if (e === 50808)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50836) {
                if (50809 <= e && e <= 50835)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50836)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50920) {
              if (e < 50865) {
                if (e < 50864) {
                  if (50837 <= e && e <= 50863)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 50864)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50892) {
                if (50865 <= e && e <= 50891)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 50893) {
                if (e === 50892)
                  return t.CLUSTER_BREAK.LV;
              } else if (50893 <= e && e <= 50919)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50949) {
              if (e < 50921) {
                if (e === 50920)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 50948) {
                if (50921 <= e && e <= 50947)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 50948)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 50976) {
              if (50949 <= e && e <= 50975)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 50977) {
              if (e === 50976)
                return t.CLUSTER_BREAK.LV;
            } else if (50977 <= e && e <= 51003)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 51145) {
            if (e < 51061) {
              if (e < 51032) {
                if (e < 51005) {
                  if (e === 51004)
                    return t.CLUSTER_BREAK.LV;
                } else if (51005 <= e && e <= 51031)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51033) {
                if (e === 51032)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51060) {
                if (51033 <= e && e <= 51059)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51060)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51116) {
              if (e < 51088) {
                if (51061 <= e && e <= 51087)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51089) {
                if (e === 51088)
                  return t.CLUSTER_BREAK.LV;
              } else if (51089 <= e && e <= 51115)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51117) {
              if (e === 51116)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51144) {
              if (51117 <= e && e <= 51143)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 51144)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 51228) {
            if (e < 51173) {
              if (e < 51172) {
                if (51145 <= e && e <= 51171)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51172)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51200) {
              if (51173 <= e && e <= 51199)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51201) {
              if (e === 51200)
                return t.CLUSTER_BREAK.LV;
            } else if (51201 <= e && e <= 51227)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 51257) {
            if (e < 51229) {
              if (e === 51228)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51256) {
              if (51229 <= e && e <= 51255)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 51256)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 51284) {
            if (51257 <= e && e <= 51283)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 51285) {
            if (e === 51284)
              return t.CLUSTER_BREAK.LV;
          } else if (51285 <= e && e <= 51311)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 52516) {
          if (e < 51901) {
            if (e < 51593) {
              if (e < 51452) {
                if (e < 51369) {
                  if (e < 51340) {
                    if (e < 51313) {
                      if (e === 51312)
                        return t.CLUSTER_BREAK.LV;
                    } else if (51313 <= e && e <= 51339)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 51341) {
                    if (e === 51340)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 51368) {
                    if (51341 <= e && e <= 51367)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51368)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51397) {
                  if (e < 51396) {
                    if (51369 <= e && e <= 51395)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51396)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51424) {
                  if (51397 <= e && e <= 51423)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51425) {
                  if (e === 51424)
                    return t.CLUSTER_BREAK.LV;
                } else if (51425 <= e && e <= 51451)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51509) {
                if (e < 51480) {
                  if (e < 51453) {
                    if (e === 51452)
                      return t.CLUSTER_BREAK.LV;
                  } else if (51453 <= e && e <= 51479)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51481) {
                  if (e === 51480)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51508) {
                  if (51481 <= e && e <= 51507)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 51508)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51564) {
                if (e < 51536) {
                  if (51509 <= e && e <= 51535)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51537) {
                  if (e === 51536)
                    return t.CLUSTER_BREAK.LV;
                } else if (51537 <= e && e <= 51563)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51565) {
                if (e === 51564)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51592) {
                if (51565 <= e && e <= 51591)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51592)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51760) {
              if (e < 51676) {
                if (e < 51621) {
                  if (e < 51620) {
                    if (51593 <= e && e <= 51619)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51620)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51648) {
                  if (51621 <= e && e <= 51647)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51649) {
                  if (e === 51648)
                    return t.CLUSTER_BREAK.LV;
                } else if (51649 <= e && e <= 51675)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51705) {
                if (e < 51677) {
                  if (e === 51676)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51704) {
                  if (51677 <= e && e <= 51703)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 51704)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51732) {
                if (51705 <= e && e <= 51731)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51733) {
                if (e === 51732)
                  return t.CLUSTER_BREAK.LV;
              } else if (51733 <= e && e <= 51759)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51817) {
              if (e < 51788) {
                if (e < 51761) {
                  if (e === 51760)
                    return t.CLUSTER_BREAK.LV;
                } else if (51761 <= e && e <= 51787)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51789) {
                if (e === 51788)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 51816) {
                if (51789 <= e && e <= 51815)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 51816)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51872) {
              if (e < 51844) {
                if (51817 <= e && e <= 51843)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 51845) {
                if (e === 51844)
                  return t.CLUSTER_BREAK.LV;
              } else if (51845 <= e && e <= 51871)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 51873) {
              if (e === 51872)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 51900) {
              if (51873 <= e && e <= 51899)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 51900)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52208) {
            if (e < 52041) {
              if (e < 51984) {
                if (e < 51929) {
                  if (e < 51928) {
                    if (51901 <= e && e <= 51927)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 51928)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 51956) {
                  if (51929 <= e && e <= 51955)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 51957) {
                  if (e === 51956)
                    return t.CLUSTER_BREAK.LV;
                } else if (51957 <= e && e <= 51983)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52012) {
                if (e < 51985) {
                  if (e === 51984)
                    return t.CLUSTER_BREAK.LV;
                } else if (51985 <= e && e <= 52011)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52013) {
                if (e === 52012)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52040) {
                if (52013 <= e && e <= 52039)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52040)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52124) {
              if (e < 52069) {
                if (e < 52068) {
                  if (52041 <= e && e <= 52067)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52068)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52096) {
                if (52069 <= e && e <= 52095)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52097) {
                if (e === 52096)
                  return t.CLUSTER_BREAK.LV;
              } else if (52097 <= e && e <= 52123)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52153) {
              if (e < 52125) {
                if (e === 52124)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52152) {
                if (52125 <= e && e <= 52151)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52152)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52180) {
              if (52153 <= e && e <= 52179)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52181) {
              if (e === 52180)
                return t.CLUSTER_BREAK.LV;
            } else if (52181 <= e && e <= 52207)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 52349) {
            if (e < 52265) {
              if (e < 52236) {
                if (e < 52209) {
                  if (e === 52208)
                    return t.CLUSTER_BREAK.LV;
                } else if (52209 <= e && e <= 52235)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52237) {
                if (e === 52236)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52264) {
                if (52237 <= e && e <= 52263)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52264)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52320) {
              if (e < 52292) {
                if (52265 <= e && e <= 52291)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52293) {
                if (e === 52292)
                  return t.CLUSTER_BREAK.LV;
              } else if (52293 <= e && e <= 52319)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52321) {
              if (e === 52320)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52348) {
              if (52321 <= e && e <= 52347)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 52348)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52432) {
            if (e < 52377) {
              if (e < 52376) {
                if (52349 <= e && e <= 52375)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52376)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52404) {
              if (52377 <= e && e <= 52403)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52405) {
              if (e === 52404)
                return t.CLUSTER_BREAK.LV;
            } else if (52405 <= e && e <= 52431)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 52461) {
            if (e < 52433) {
              if (e === 52432)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52460) {
              if (52433 <= e && e <= 52459)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 52460)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52488) {
            if (52461 <= e && e <= 52487)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 52489) {
            if (e === 52488)
              return t.CLUSTER_BREAK.LV;
          } else if (52489 <= e && e <= 52515)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53105) {
          if (e < 52797) {
            if (e < 52656) {
              if (e < 52573) {
                if (e < 52544) {
                  if (e < 52517) {
                    if (e === 52516)
                      return t.CLUSTER_BREAK.LV;
                  } else if (52517 <= e && e <= 52543)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 52545) {
                  if (e === 52544)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 52572) {
                  if (52545 <= e && e <= 52571)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52572)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52601) {
                if (e < 52600) {
                  if (52573 <= e && e <= 52599)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52600)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52628) {
                if (52601 <= e && e <= 52627)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52629) {
                if (e === 52628)
                  return t.CLUSTER_BREAK.LV;
              } else if (52629 <= e && e <= 52655)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52713) {
              if (e < 52684) {
                if (e < 52657) {
                  if (e === 52656)
                    return t.CLUSTER_BREAK.LV;
                } else if (52657 <= e && e <= 52683)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52685) {
                if (e === 52684)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52712) {
                if (52685 <= e && e <= 52711)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52712)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52768) {
              if (e < 52740) {
                if (52713 <= e && e <= 52739)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52741) {
                if (e === 52740)
                  return t.CLUSTER_BREAK.LV;
              } else if (52741 <= e && e <= 52767)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52769) {
              if (e === 52768)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52796) {
              if (52769 <= e && e <= 52795)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 52796)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 52964) {
            if (e < 52880) {
              if (e < 52825) {
                if (e < 52824) {
                  if (52797 <= e && e <= 52823)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 52824)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52852) {
                if (52825 <= e && e <= 52851)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 52853) {
                if (e === 52852)
                  return t.CLUSTER_BREAK.LV;
              } else if (52853 <= e && e <= 52879)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52909) {
              if (e < 52881) {
                if (e === 52880)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 52908) {
                if (52881 <= e && e <= 52907)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 52908)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 52936) {
              if (52909 <= e && e <= 52935)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52937) {
              if (e === 52936)
                return t.CLUSTER_BREAK.LV;
            } else if (52937 <= e && e <= 52963)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53021) {
            if (e < 52992) {
              if (e < 52965) {
                if (e === 52964)
                  return t.CLUSTER_BREAK.LV;
              } else if (52965 <= e && e <= 52991)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 52993) {
              if (e === 52992)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53020) {
              if (52993 <= e && e <= 53019)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53020)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53076) {
            if (e < 53048) {
              if (53021 <= e && e <= 53047)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53049) {
              if (e === 53048)
                return t.CLUSTER_BREAK.LV;
            } else if (53049 <= e && e <= 53075)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53077) {
            if (e === 53076)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53104) {
            if (53077 <= e && e <= 53103)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 53104)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 53412) {
          if (e < 53245) {
            if (e < 53188) {
              if (e < 53133) {
                if (e < 53132) {
                  if (53105 <= e && e <= 53131)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 53132)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 53160) {
                if (53133 <= e && e <= 53159)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 53161) {
                if (e === 53160)
                  return t.CLUSTER_BREAK.LV;
              } else if (53161 <= e && e <= 53187)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53216) {
              if (e < 53189) {
                if (e === 53188)
                  return t.CLUSTER_BREAK.LV;
              } else if (53189 <= e && e <= 53215)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53217) {
              if (e === 53216)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53244) {
              if (53217 <= e && e <= 53243)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53244)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53328) {
            if (e < 53273) {
              if (e < 53272) {
                if (53245 <= e && e <= 53271)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 53272)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53300) {
              if (53273 <= e && e <= 53299)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53301) {
              if (e === 53300)
                return t.CLUSTER_BREAK.LV;
            } else if (53301 <= e && e <= 53327)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53357) {
            if (e < 53329) {
              if (e === 53328)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53356) {
              if (53329 <= e && e <= 53355)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53356)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53384) {
            if (53357 <= e && e <= 53383)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53385) {
            if (e === 53384)
              return t.CLUSTER_BREAK.LV;
          } else if (53385 <= e && e <= 53411)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53553) {
          if (e < 53469) {
            if (e < 53440) {
              if (e < 53413) {
                if (e === 53412)
                  return t.CLUSTER_BREAK.LV;
              } else if (53413 <= e && e <= 53439)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53441) {
              if (e === 53440)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 53468) {
              if (53441 <= e && e <= 53467)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53468)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53524) {
            if (e < 53496) {
              if (53469 <= e && e <= 53495)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 53497) {
              if (e === 53496)
                return t.CLUSTER_BREAK.LV;
            } else if (53497 <= e && e <= 53523)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53525) {
            if (e === 53524)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53552) {
            if (53525 <= e && e <= 53551)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 53552)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 53636) {
          if (e < 53581) {
            if (e < 53580) {
              if (53553 <= e && e <= 53579)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 53580)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53608) {
            if (53581 <= e && e <= 53607)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 53609) {
            if (e === 53608)
              return t.CLUSTER_BREAK.LV;
          } else if (53609 <= e && e <= 53635)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53665) {
          if (e < 53637) {
            if (e === 53636)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 53664) {
            if (53637 <= e && e <= 53663)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 53664)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 53692) {
          if (53665 <= e && e <= 53691)
            return t.CLUSTER_BREAK.LVT;
        } else if (e < 53693) {
          if (e === 53692)
            return t.CLUSTER_BREAK.LV;
        } else if (53693 <= e && e <= 53719)
          return t.CLUSTER_BREAK.LVT;
      } else if (e < 70459) {
        if (e < 54897) {
          if (e < 54308) {
            if (e < 54001) {
              if (e < 53860) {
                if (e < 53777) {
                  if (e < 53748) {
                    if (e < 53721) {
                      if (e === 53720)
                        return t.CLUSTER_BREAK.LV;
                    } else if (53721 <= e && e <= 53747)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e < 53749) {
                    if (e === 53748)
                      return t.CLUSTER_BREAK.LV;
                  } else if (e < 53776) {
                    if (53749 <= e && e <= 53775)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 53776)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 53805) {
                  if (e < 53804) {
                    if (53777 <= e && e <= 53803)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 53804)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 53832) {
                  if (53805 <= e && e <= 53831)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 53833) {
                  if (e === 53832)
                    return t.CLUSTER_BREAK.LV;
                } else if (53833 <= e && e <= 53859)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 53917) {
                if (e < 53888) {
                  if (e < 53861) {
                    if (e === 53860)
                      return t.CLUSTER_BREAK.LV;
                  } else if (53861 <= e && e <= 53887)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 53889) {
                  if (e === 53888)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 53916) {
                  if (53889 <= e && e <= 53915)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 53916)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 53972) {
                if (e < 53944) {
                  if (53917 <= e && e <= 53943)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 53945) {
                  if (e === 53944)
                    return t.CLUSTER_BREAK.LV;
                } else if (53945 <= e && e <= 53971)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 53973) {
                if (e === 53972)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54e3) {
                if (53973 <= e && e <= 53999)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54e3)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54141) {
              if (e < 54084) {
                if (e < 54029) {
                  if (e < 54028) {
                    if (54001 <= e && e <= 54027)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 54028)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 54056) {
                  if (54029 <= e && e <= 54055)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 54057) {
                  if (e === 54056)
                    return t.CLUSTER_BREAK.LV;
                } else if (54057 <= e && e <= 54083)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54112) {
                if (e < 54085) {
                  if (e === 54084)
                    return t.CLUSTER_BREAK.LV;
                } else if (54085 <= e && e <= 54111)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54113) {
                if (e === 54112)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54140) {
                if (54113 <= e && e <= 54139)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54140)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54224) {
              if (e < 54169) {
                if (e < 54168) {
                  if (54141 <= e && e <= 54167)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54168)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54196) {
                if (54169 <= e && e <= 54195)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54197) {
                if (e === 54196)
                  return t.CLUSTER_BREAK.LV;
              } else if (54197 <= e && e <= 54223)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54253) {
              if (e < 54225) {
                if (e === 54224)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54252) {
                if (54225 <= e && e <= 54251)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54252)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54280) {
              if (54253 <= e && e <= 54279)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54281) {
              if (e === 54280)
                return t.CLUSTER_BREAK.LV;
            } else if (54281 <= e && e <= 54307)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 54589) {
            if (e < 54448) {
              if (e < 54365) {
                if (e < 54336) {
                  if (e < 54309) {
                    if (e === 54308)
                      return t.CLUSTER_BREAK.LV;
                  } else if (54309 <= e && e <= 54335)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 54337) {
                  if (e === 54336)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 54364) {
                  if (54337 <= e && e <= 54363)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54364)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54393) {
                if (e < 54392) {
                  if (54365 <= e && e <= 54391)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54392)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54420) {
                if (54393 <= e && e <= 54419)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54421) {
                if (e === 54420)
                  return t.CLUSTER_BREAK.LV;
              } else if (54421 <= e && e <= 54447)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54505) {
              if (e < 54476) {
                if (e < 54449) {
                  if (e === 54448)
                    return t.CLUSTER_BREAK.LV;
                } else if (54449 <= e && e <= 54475)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54477) {
                if (e === 54476)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54504) {
                if (54477 <= e && e <= 54503)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54504)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54560) {
              if (e < 54532) {
                if (54505 <= e && e <= 54531)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54533) {
                if (e === 54532)
                  return t.CLUSTER_BREAK.LV;
              } else if (54533 <= e && e <= 54559)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54561) {
              if (e === 54560)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54588) {
              if (54561 <= e && e <= 54587)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 54588)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 54756) {
            if (e < 54672) {
              if (e < 54617) {
                if (e < 54616) {
                  if (54589 <= e && e <= 54615)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 54616)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54644) {
                if (54617 <= e && e <= 54643)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 54645) {
                if (e === 54644)
                  return t.CLUSTER_BREAK.LV;
              } else if (54645 <= e && e <= 54671)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54701) {
              if (e < 54673) {
                if (e === 54672)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 54700) {
                if (54673 <= e && e <= 54699)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 54700)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54728) {
              if (54701 <= e && e <= 54727)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54729) {
              if (e === 54728)
                return t.CLUSTER_BREAK.LV;
            } else if (54729 <= e && e <= 54755)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 54813) {
            if (e < 54784) {
              if (e < 54757) {
                if (e === 54756)
                  return t.CLUSTER_BREAK.LV;
              } else if (54757 <= e && e <= 54783)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54785) {
              if (e === 54784)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 54812) {
              if (54785 <= e && e <= 54811)
                return t.CLUSTER_BREAK.LVT;
            } else if (e === 54812)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 54868) {
            if (e < 54840) {
              if (54813 <= e && e <= 54839)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 54841) {
              if (e === 54840)
                return t.CLUSTER_BREAK.LV;
            } else if (54841 <= e && e <= 54867)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 54869) {
            if (e === 54868)
              return t.CLUSTER_BREAK.LV;
          } else if (e < 54896) {
            if (54869 <= e && e <= 54895)
              return t.CLUSTER_BREAK.LVT;
          } else if (e === 54896)
            return t.CLUSTER_BREAK.LV;
        } else if (e < 69632) {
          if (e < 55216) {
            if (e < 55037) {
              if (e < 54980) {
                if (e < 54925) {
                  if (e < 54924) {
                    if (54897 <= e && e <= 54923)
                      return t.CLUSTER_BREAK.LVT;
                  } else if (e === 54924)
                    return t.CLUSTER_BREAK.LV;
                } else if (e < 54952) {
                  if (54925 <= e && e <= 54951)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e < 54953) {
                  if (e === 54952)
                    return t.CLUSTER_BREAK.LV;
                } else if (54953 <= e && e <= 54979)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 55008) {
                if (e < 54981) {
                  if (e === 54980)
                    return t.CLUSTER_BREAK.LV;
                } else if (54981 <= e && e <= 55007)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 55009) {
                if (e === 55008)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 55036) {
                if (55009 <= e && e <= 55035)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 55036)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 55120) {
              if (e < 55065) {
                if (e < 55064) {
                  if (55037 <= e && e <= 55063)
                    return t.CLUSTER_BREAK.LVT;
                } else if (e === 55064)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 55092) {
                if (55065 <= e && e <= 55091)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e < 55093) {
                if (e === 55092)
                  return t.CLUSTER_BREAK.LV;
              } else if (55093 <= e && e <= 55119)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 55149) {
              if (e < 55121) {
                if (e === 55120)
                  return t.CLUSTER_BREAK.LV;
              } else if (e < 55148) {
                if (55121 <= e && e <= 55147)
                  return t.CLUSTER_BREAK.LVT;
              } else if (e === 55148)
                return t.CLUSTER_BREAK.LV;
            } else if (e < 55176) {
              if (55149 <= e && e <= 55175)
                return t.CLUSTER_BREAK.LVT;
            } else if (e < 55177) {
              if (e === 55176)
                return t.CLUSTER_BREAK.LV;
            } else if (55177 <= e && e <= 55203)
              return t.CLUSTER_BREAK.LVT;
          } else if (e < 68097) {
            if (e < 65279) {
              if (e < 64286) {
                if (e < 55243) {
                  if (55216 <= e && e <= 55238)
                    return t.CLUSTER_BREAK.V;
                } else if (55243 <= e && e <= 55291)
                  return t.CLUSTER_BREAK.T;
              } else if (e < 65024) {
                if (e === 64286)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 65056) {
                if (65024 <= e && e <= 65039)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (65056 <= e && e <= 65071)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 66045) {
              if (e < 65438) {
                if (e === 65279)
                  return t.CLUSTER_BREAK.CONTROL;
              } else if (e < 65520) {
                if (65438 <= e && e <= 65439)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (65520 <= e && e <= 65531)
                return t.CLUSTER_BREAK.CONTROL;
            } else if (e < 66272) {
              if (e === 66045)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 66422) {
              if (e === 66272)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (66422 <= e && e <= 66426)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 68325) {
            if (e < 68108) {
              if (e < 68101) {
                if (68097 <= e && e <= 68099)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (68101 <= e && e <= 68102)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 68152) {
              if (68108 <= e && e <= 68111)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 68159) {
              if (68152 <= e && e <= 68154)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 68159)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69373) {
            if (e < 68900) {
              if (68325 <= e && e <= 68326)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69291) {
              if (68900 <= e && e <= 68903)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (69291 <= e && e <= 69292)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69446) {
            if (69373 <= e && e <= 69375)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69506) {
            if (69446 <= e && e <= 69456)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (69506 <= e && e <= 69509)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70016) {
          if (e < 69815) {
            if (e < 69747) {
              if (e < 69634) {
                if (e === 69632)
                  return t.CLUSTER_BREAK.SPACINGMARK;
                if (e === 69633)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 69688) {
                if (e === 69634)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 69744) {
                if (69688 <= e && e <= 69702)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 69744)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69762) {
              if (e < 69759) {
                if (69747 <= e && e <= 69748)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (69759 <= e && e <= 69761)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69808) {
              if (e === 69762)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69811) {
              if (69808 <= e && e <= 69810)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (69811 <= e && e <= 69814)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 69888)
            if (e < 69821) {
              if (e < 69817) {
                if (69815 <= e && e <= 69816)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (69817 <= e && e <= 69818)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69826) {
              if (e === 69821)
                return t.CLUSTER_BREAK.PREPEND;
            } else {
              if (e === 69826)
                return t.CLUSTER_BREAK.EXTEND;
              if (e === 69837)
                return t.CLUSTER_BREAK.PREPEND;
            }
          else if (e < 69933) {
            if (e < 69927) {
              if (69888 <= e && e <= 69890)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 69932) {
              if (69927 <= e && e <= 69931)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 69932)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69957) {
            if (69933 <= e && e <= 69940)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70003) {
            if (69957 <= e && e <= 69958)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70003)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70194) {
          if (e < 70082) {
            if (e < 70067) {
              if (e < 70018) {
                if (70016 <= e && e <= 70017)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e === 70018)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70070) {
              if (70067 <= e && e <= 70069)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70079) {
              if (70070 <= e && e <= 70078)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (70079 <= e && e <= 70080)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70095) {
            if (e < 70089) {
              if (70082 <= e && e <= 70083)
                return t.CLUSTER_BREAK.PREPEND;
            } else if (e < 70094) {
              if (70089 <= e && e <= 70092)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 70094)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70188) {
            if (e === 70095)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70191) {
            if (70188 <= e && e <= 70190)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (70191 <= e && e <= 70193)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70209) {
          if (e < 70197) {
            if (e < 70196) {
              if (70194 <= e && e <= 70195)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70196)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70198) {
            if (e === 70197)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70206) {
            if (70198 <= e && e <= 70199)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e === 70206)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70371) {
          if (e < 70367) {
            if (e === 70209)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 70368) {
            if (e === 70367)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (70368 <= e && e <= 70370)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70400) {
          if (70371 <= e && e <= 70378)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 70402) {
          if (70400 <= e && e <= 70401)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (70402 <= e && e <= 70403)
          return t.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72343) {
        if (e < 71339) {
          if (e < 70841) {
            if (e < 70512) {
              if (e < 70471) {
                if (e < 70463) {
                  if (e < 70462) {
                    if (70459 <= e && e <= 70460)
                      return t.CLUSTER_BREAK.EXTEND;
                  } else if (e === 70462)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (e < 70464) {
                  if (e === 70463)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 70465) {
                  if (e === 70464)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (70465 <= e && e <= 70468)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70487) {
                if (e < 70475) {
                  if (70471 <= e && e <= 70472)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (70475 <= e && e <= 70477)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70498) {
                if (e === 70487)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70502) {
                if (70498 <= e && e <= 70499)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (70502 <= e && e <= 70508)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70725) {
              if (e < 70712) {
                if (e < 70709) {
                  if (70512 <= e && e <= 70516)
                    return t.CLUSTER_BREAK.EXTEND;
                } else if (70709 <= e && e <= 70711)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70720) {
                if (70712 <= e && e <= 70719)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70722) {
                if (70720 <= e && e <= 70721)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (70722 <= e && e <= 70724)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70832) {
              if (e < 70726) {
                if (e === 70725)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 70726 || e === 70750)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70833) {
              if (e === 70832)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 70835) {
              if (70833 <= e && e <= 70834)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (70835 <= e && e <= 70840)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71096) {
            if (e < 70847)
              if (e < 70843) {
                if (e === 70841)
                  return t.CLUSTER_BREAK.SPACINGMARK;
                if (e === 70842)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70845) {
                if (70843 <= e && e <= 70844)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 70845)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 70846)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 71087) {
              if (e < 70849) {
                if (70847 <= e && e <= 70848)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 70850) {
                if (e === 70849)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (70850 <= e && e <= 70851)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71088) {
              if (e === 71087)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71090) {
              if (71088 <= e && e <= 71089)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (71090 <= e && e <= 71093)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71216) {
            if (e < 71102) {
              if (e < 71100) {
                if (71096 <= e && e <= 71099)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (71100 <= e && e <= 71101)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71103) {
              if (e === 71102)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71132) {
              if (71103 <= e && e <= 71104)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (71132 <= e && e <= 71133)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71229) {
            if (e < 71219) {
              if (71216 <= e && e <= 71218)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71227) {
              if (71219 <= e && e <= 71226)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (71227 <= e && e <= 71228)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71230) {
            if (e === 71229)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71231) {
            if (e === 71230)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (71231 <= e && e <= 71232)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 71999)
          if (e < 71463) {
            if (e < 71350) {
              if (e < 71341) {
                if (e === 71339)
                  return t.CLUSTER_BREAK.EXTEND;
                if (e === 71340)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 71342) {
                if (e === 71341)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 71344) {
                if (71342 <= e && e <= 71343)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (71344 <= e && e <= 71349)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71453) {
              if (e === 71350)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 71351)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71458) {
              if (71453 <= e && e <= 71455)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71462) {
              if (71458 <= e && e <= 71461)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 71462)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71984) {
            if (e < 71727) {
              if (e < 71724) {
                if (71463 <= e && e <= 71467)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (71724 <= e && e <= 71726)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71736) {
              if (71727 <= e && e <= 71735)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71737) {
              if (e === 71736)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (71737 <= e && e <= 71738)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 71995) {
            if (e < 71985) {
              if (e === 71984)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 71991) {
              if (71985 <= e && e <= 71989)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (71991 <= e && e <= 71992)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71997) {
            if (71995 <= e && e <= 71996)
              return t.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 71997)
              return t.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71998)
              return t.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72193)
          if (e < 72145)
            if (e < 72001) {
              if (e === 71999)
                return t.CLUSTER_BREAK.PREPEND;
              if (e === 72e3)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72002) {
              if (e === 72001)
                return t.CLUSTER_BREAK.PREPEND;
            } else {
              if (e === 72002)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 72003)
                return t.CLUSTER_BREAK.EXTEND;
            }
          else if (e < 72156) {
            if (e < 72148) {
              if (72145 <= e && e <= 72147)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72154) {
              if (72148 <= e && e <= 72151)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (72154 <= e && e <= 72155)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 72160) {
            if (72156 <= e && e <= 72159)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 72160)
              return t.CLUSTER_BREAK.EXTEND;
            if (e === 72164)
              return t.CLUSTER_BREAK.SPACINGMARK;
          }
        else if (e < 72263) {
          if (e < 72249) {
            if (e < 72243) {
              if (72193 <= e && e <= 72202)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (72243 <= e && e <= 72248)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 72250) {
            if (e === 72249)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72251) {
            if (e === 72250)
              return t.CLUSTER_BREAK.PREPEND;
          } else if (72251 <= e && e <= 72254)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 72281) {
          if (e < 72273) {
            if (e === 72263)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 72279) {
            if (72273 <= e && e <= 72278)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (72279 <= e && e <= 72280)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72324) {
          if (72281 <= e && e <= 72283)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 72330) {
          if (72324 <= e && e <= 72329)
            return t.CLUSTER_BREAK.PREPEND;
        } else if (72330 <= e && e <= 72342)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 94033) {
        if (e < 73104) {
          if (e < 72881) {
            if (e < 72766) {
              if (e < 72751) {
                if (e < 72344) {
                  if (e === 72343)
                    return t.CLUSTER_BREAK.SPACINGMARK;
                } else if (72344 <= e && e <= 72345)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (e < 72752) {
                if (e === 72751)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 72760) {
                if (72752 <= e && e <= 72758)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (72760 <= e && e <= 72765)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72850) {
              if (e === 72766)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 72767)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72873) {
              if (72850 <= e && e <= 72871)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72874) {
              if (e === 72873)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (72874 <= e && e <= 72880)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73018) {
            if (e < 72884) {
              if (e < 72882) {
                if (e === 72881)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (72882 <= e && e <= 72883)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 72885) {
              if (e === 72884)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 73009) {
              if (72885 <= e && e <= 72886)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (73009 <= e && e <= 73014)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73030) {
            if (e < 73020) {
              if (e === 73018)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 73023) {
              if (73020 <= e && e <= 73021)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (73023 <= e && e <= 73029)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73031) {
            if (e === 73030)
              return t.CLUSTER_BREAK.PREPEND;
          } else if (e < 73098) {
            if (e === 73031)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (73098 <= e && e <= 73102)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73526) {
          if (e < 73459)
            if (e < 73109) {
              if (e < 73107) {
                if (73104 <= e && e <= 73105)
                  return t.CLUSTER_BREAK.EXTEND;
              } else if (73107 <= e && e <= 73108)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 73110) {
              if (e === 73109)
                return t.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 73110)
                return t.CLUSTER_BREAK.SPACINGMARK;
              if (e === 73111)
                return t.CLUSTER_BREAK.EXTEND;
            }
          else if (e < 73474) {
            if (e < 73461) {
              if (73459 <= e && e <= 73460)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 73472) {
              if (73461 <= e && e <= 73462)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (73472 <= e && e <= 73473)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 73475) {
            if (e === 73474)
              return t.CLUSTER_BREAK.PREPEND;
          } else if (e < 73524) {
            if (e === 73475)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (73524 <= e && e <= 73525)
            return t.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 78896)
          if (e < 73536) {
            if (e < 73534) {
              if (73526 <= e && e <= 73530)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (73534 <= e && e <= 73535)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73537) {
            if (e === 73536)
              return t.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73537)
              return t.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73538)
              return t.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 92912) {
          if (e < 78912) {
            if (78896 <= e && e <= 78911)
              return t.CLUSTER_BREAK.CONTROL;
          } else if (e < 78919) {
            if (e === 78912)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (78919 <= e && e <= 78933)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 92976) {
          if (92912 <= e && e <= 92916)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 94031) {
          if (92976 <= e && e <= 92982)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e === 94031)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 121476) {
        if (e < 119143)
          if (e < 113824) {
            if (e < 94180) {
              if (e < 94095) {
                if (94033 <= e && e <= 94087)
                  return t.CLUSTER_BREAK.SPACINGMARK;
              } else if (94095 <= e && e <= 94098)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 94192) {
              if (e === 94180)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e < 113821) {
              if (94192 <= e && e <= 94193)
                return t.CLUSTER_BREAK.SPACINGMARK;
            } else if (113821 <= e && e <= 113822)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 118576) {
            if (e < 118528) {
              if (113824 <= e && e <= 113827)
                return t.CLUSTER_BREAK.CONTROL;
            } else if (118528 <= e && e <= 118573)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 119141) {
            if (118576 <= e && e <= 118598)
              return t.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 119141)
              return t.CLUSTER_BREAK.EXTEND;
            if (e === 119142)
              return t.CLUSTER_BREAK.SPACINGMARK;
          }
        else if (e < 119173) {
          if (e < 119150) {
            if (e < 119149) {
              if (119143 <= e && e <= 119145)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (e === 119149)
              return t.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 119155) {
            if (119150 <= e && e <= 119154)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 119163) {
            if (119155 <= e && e <= 119162)
              return t.CLUSTER_BREAK.CONTROL;
          } else if (119163 <= e && e <= 119170)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 121344) {
          if (e < 119210) {
            if (119173 <= e && e <= 119179)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 119362) {
            if (119210 <= e && e <= 119213)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (119362 <= e && e <= 119364)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 121403) {
          if (121344 <= e && e <= 121398)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 121461) {
          if (121403 <= e && e <= 121452)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e === 121461)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 123628) {
        if (e < 122907) {
          if (e < 121505) {
            if (e < 121499) {
              if (e === 121476)
                return t.CLUSTER_BREAK.EXTEND;
            } else if (121499 <= e && e <= 121503)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 122880) {
            if (121505 <= e && e <= 121519)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 122888) {
            if (122880 <= e && e <= 122886)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (122888 <= e && e <= 122904)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 123023) {
          if (e < 122915) {
            if (122907 <= e && e <= 122913)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (e < 122918) {
            if (122915 <= e && e <= 122916)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (122918 <= e && e <= 122922)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 123184) {
          if (e === 123023)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 123566) {
          if (123184 <= e && e <= 123190)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e === 123566)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 127995) {
        if (e < 125136) {
          if (e < 124140) {
            if (123628 <= e && e <= 123631)
              return t.CLUSTER_BREAK.EXTEND;
          } else if (124140 <= e && e <= 124143)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 125252) {
          if (125136 <= e && e <= 125142)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 127462) {
          if (125252 <= e && e <= 125258)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (127462 <= e && e <= 127487)
          return t.CLUSTER_BREAK.REGIONAL_INDICATOR;
      } else if (e < 917632) {
        if (e < 917504) {
          if (127995 <= e && e <= 127999)
            return t.CLUSTER_BREAK.EXTEND;
        } else if (e < 917536) {
          if (917504 <= e && e <= 917535)
            return t.CLUSTER_BREAK.CONTROL;
        } else if (917536 <= e && e <= 917631)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (e < 917760) {
        if (917632 <= e && e <= 917759)
          return t.CLUSTER_BREAK.CONTROL;
      } else if (e < 918e3) {
        if (917760 <= e && e <= 917999)
          return t.CLUSTER_BREAK.EXTEND;
      } else if (918e3 <= e && e <= 921599)
        return t.CLUSTER_BREAK.CONTROL;
      return t.CLUSTER_BREAK.OTHER;
    }
    /**
     * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
     * @param code {number} Unicode code point
     * @returns {number}
     */
    static getEmojiProperty(e) {
      if (e < 10160) {
        if (e < 9728) {
          if (e < 9e3) {
            if (e < 8482) {
              if (e < 8252) {
                if (e === 169 || e === 174)
                  return t.EXTENDED_PICTOGRAPHIC;
              } else if (e === 8252 || e === 8265)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 8596) {
              if (e === 8482 || e === 8505)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 8617) {
              if (8596 <= e && e <= 8601)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 8986) {
              if (8617 <= e && e <= 8618)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (8986 <= e && e <= 8987)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9410) {
            if (e < 9167) {
              if (e === 9e3 || e === 9096)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9193) {
              if (e === 9167)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9208) {
              if (9193 <= e && e <= 9203)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (9208 <= e && e <= 9210)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9654) {
            if (e < 9642) {
              if (e === 9410)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (9642 <= e && e <= 9643)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9664) {
            if (e === 9654)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9723) {
            if (e === 9664)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (9723 <= e && e <= 9726)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10035) {
          if (e < 10004) {
            if (e < 9748) {
              if (e < 9735) {
                if (9728 <= e && e <= 9733)
                  return t.EXTENDED_PICTOGRAPHIC;
              } else if (9735 <= e && e <= 9746)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9872) {
              if (9748 <= e && e <= 9861)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 9992) {
              if (9872 <= e && e <= 9989)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (9992 <= e && e <= 10002)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 10013) {
            if (e === 10004 || e === 10006)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 10017) {
            if (e === 10013)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10017 || e === 10024)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10067) {
          if (e < 10055) {
            if (e < 10052) {
              if (10035 <= e && e <= 10036)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e === 10052)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 10060) {
            if (e === 10055)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10060 || e === 10062)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10083) {
          if (e < 10071) {
            if (10067 <= e && e <= 10069)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10071)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10133) {
          if (10083 <= e && e <= 10087)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10145) {
          if (10133 <= e && e <= 10135)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10145)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127489) {
        if (e < 12951) {
          if (e < 11035) {
            if (e < 10548) {
              if (e === 10160 || e === 10175)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e < 11013) {
              if (10548 <= e && e <= 10549)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (11013 <= e && e <= 11015)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11093) {
            if (e < 11088) {
              if (11035 <= e && e <= 11036)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e === 11088)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 12336) {
            if (e === 11093)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 12336 || e === 12349)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127340) {
          if (e < 126976) {
            if (e === 12951 || e === 12953)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127245) {
            if (126976 <= e && e <= 127231)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127279) {
            if (127245 <= e && e <= 127247)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127279)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127374) {
          if (e < 127358) {
            if (127340 <= e && e <= 127345)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (127358 <= e && e <= 127359)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127377) {
          if (e === 127374)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127405) {
          if (127377 <= e && e <= 127386)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (127405 <= e && e <= 127461)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128981) {
        if (e < 127561) {
          if (e < 127535) {
            if (e < 127514) {
              if (127489 <= e && e <= 127503)
                return t.EXTENDED_PICTOGRAPHIC;
            } else if (e === 127514)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127538) {
            if (e === 127535)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (e < 127548) {
            if (127538 <= e && e <= 127546)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (127548 <= e && e <= 127551)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 128326) {
          if (e < 128e3) {
            if (127561 <= e && e <= 127994)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (128e3 <= e && e <= 128317)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 128640) {
          if (128326 <= e && e <= 128591)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 128884) {
          if (128640 <= e && e <= 128767)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (128884 <= e && e <= 128895)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129198) {
        if (e < 129096) {
          if (e < 129036) {
            if (128981 <= e && e <= 129023)
              return t.EXTENDED_PICTOGRAPHIC;
          } else if (129036 <= e && e <= 129039)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 129114) {
          if (129096 <= e && e <= 129103)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (e < 129160) {
          if (129114 <= e && e <= 129119)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (129160 <= e && e <= 129167)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129340) {
        if (e < 129292) {
          if (129198 <= e && e <= 129279)
            return t.EXTENDED_PICTOGRAPHIC;
        } else if (129292 <= e && e <= 129338)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129351) {
        if (129340 <= e && e <= 129349)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (e < 130048) {
        if (129351 <= e && e <= 129791)
          return t.EXTENDED_PICTOGRAPHIC;
      } else if (130048 <= e && e <= 131069)
        return t.EXTENDED_PICTOGRAPHIC;
      return t.CLUSTER_BREAK.OTHER;
    }
  };
  return Ei.default = s, Ei;
}
var Bc;
function zg() {
  if (Bc) return gi;
  Bc = 1;
  var r = gi && gi.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(gi, "__esModule", { value: !0 });
  const t = r($g());
  return gi.default = t.default, gi;
}
var Pc;
function Xg() {
  if (Pc) return De;
  Pc = 1;
  var r = De && De.__createBinding || (Object.create ? function(A, v, R, E) {
    E === void 0 && (E = R);
    var h = Object.getOwnPropertyDescriptor(v, R);
    (!h || ("get" in h ? !v.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return v[R];
    } }), Object.defineProperty(A, E, h);
  } : function(A, v, R, E) {
    E === void 0 && (E = R), A[E] = v[R];
  }), t = De && De.__setModuleDefault || (Object.create ? function(A, v) {
    Object.defineProperty(A, "default", { enumerable: !0, value: v });
  } : function(A, v) {
    A.default = v;
  }), i = De && De.__importStar || function(A) {
    if (A && A.__esModule) return A;
    var v = {};
    if (A != null) for (var R in A) R !== "default" && Object.prototype.hasOwnProperty.call(A, R) && r(v, A, R);
    return t(v, A), v;
  }, n = De && De.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(De, "__esModule", { value: !0 }), De.validateLanguage = De.parseLanguage = De.b64UrlToUtf8 = De.utf8ToB64Url = De.graphemeLen = De.utf8Len = void 0;
  const s = n(zg()), o = i(Ph), e = (A) => new TextEncoder().encode(A).byteLength;
  De.utf8Len = e;
  const l = (A) => new s.default().countGraphemes(A);
  De.graphemeLen = l;
  const a = (A) => o.toString(o.fromString(A, "utf8"), "base64url");
  De.utf8ToB64Url = a;
  const u = (A) => o.toString(o.fromString(A, "base64url"), "utf8");
  De.b64UrlToUtf8 = u;
  const f = (A) => {
    const v = A.match(g);
    if (!(v != null && v.groups))
      return null;
    const R = v.groups;
    return {
      grandfathered: R.grandfathered,
      language: R.language,
      extlang: R.extlang,
      script: R.script,
      region: R.region,
      variant: R.variant,
      extension: R.extension,
      privateUse: R.privateUseA || R.privateUseB
    };
  };
  De.parseLanguage = f;
  const m = (A) => g.test(A);
  De.validateLanguage = m;
  const g = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
  return De;
}
var vu = {}, Uc;
function Hg() {
  return Uc || (Uc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.didDocument = r.getServiceEndpoint = r.getNotifEndpoint = r.getFeedGenEndpoint = r.getPdsEndpoint = r.getSigningDidKey = r.getVerificationMaterial = r.getSigningKey = r.getHandle = r.getDid = r.isValidDidDoc = void 0;
    const t = /* @__PURE__ */ fi(), i = (h) => r.didDocument.safeParse(h).success;
    r.isValidDidDoc = i;
    const n = (h) => {
      const C = h.id;
      if (typeof C != "string")
        throw new Error("No `id` on document");
      return C;
    };
    r.getDid = n;
    const s = (h) => {
      const C = h.alsoKnownAs;
      if (C)
        for (let K = 0; K < C.length; K++) {
          const k = C[K];
          if (k.startsWith("at://"))
            return k.slice(5);
        }
    };
    r.getHandle = s;
    const o = (h) => (0, r.getVerificationMaterial)(h, "atproto");
    r.getSigningKey = o;
    const e = (h, C) => {
      const K = g(h, "verificationMethod", `#${C}`);
      if (K && K.publicKeyMultibase)
        return {
          type: K.type,
          publicKeyMultibase: K.publicKeyMultibase
        };
    };
    r.getVerificationMaterial = e;
    const l = (h) => {
      const C = (0, r.getSigningKey)(h);
      if (C)
        return `did:key:${C.publicKeyMultibase}`;
    };
    r.getSigningDidKey = l;
    const a = (h) => (0, r.getServiceEndpoint)(h, {
      id: "#atproto_pds",
      type: "AtprotoPersonalDataServer"
    });
    r.getPdsEndpoint = a;
    const u = (h) => (0, r.getServiceEndpoint)(h, {
      id: "#bsky_fg",
      type: "BskyFeedGenerator"
    });
    r.getFeedGenEndpoint = u;
    const f = (h) => (0, r.getServiceEndpoint)(h, {
      id: "#bsky_notif",
      type: "BskyNotificationService"
    });
    r.getNotifEndpoint = f;
    const m = (h, C) => {
      const K = g(h, "service", C.id);
      if (K && !(C.type && K.type !== C.type) && typeof K.serviceEndpoint == "string")
        return A(K.serviceEndpoint);
    };
    r.getServiceEndpoint = m;
    function g(h, C, K) {
      const k = h[C];
      if (k)
        for (let F = 0; F < k.length; F++) {
          const Z = k[F], q = Z.id;
          if (q[0] === "#" ? q === K : (
            // Optimized version of: itemId === `${doc.id}${id}`
            q.length === h.id.length + K.length && q[h.id.length] === "#" && q.endsWith(K) && q.startsWith(h.id)
          ))
            return Z;
        }
    }
    const A = (h) => {
      if (!(!h.startsWith("http://") && !h.startsWith("https://")) && v(h))
        return h;
    }, v = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
    ((h) => {
      try {
        return new URL(h), !0;
      } catch {
        return !1;
      }
    }), R = t.z.object({
      id: t.z.string(),
      type: t.z.string(),
      controller: t.z.string(),
      publicKeyMultibase: t.z.string().optional()
    }), E = t.z.object({
      id: t.z.string(),
      type: t.z.string(),
      serviceEndpoint: t.z.union([t.z.string(), t.z.record(t.z.unknown())])
    });
    r.didDocument = t.z.object({
      id: t.z.string(),
      alsoKnownAs: t.z.array(t.z.string()).optional(),
      verificationMethod: t.z.array(R).optional(),
      service: t.z.array(E).optional()
    });
  }(vu)), vu;
}
var Vc;
function _r() {
  return Vc || (Vc = 1, function(r) {
    var t = Qt && Qt.__createBinding || (Object.create ? function(o, e, l, a) {
      a === void 0 && (a = l);
      var u = Object.getOwnPropertyDescriptor(e, l);
      (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return e[l];
      } }), Object.defineProperty(o, a, u);
    } : function(o, e, l, a) {
      a === void 0 && (a = l), o[a] = e[l];
    }), i = Qt && Qt.__setModuleDefault || (Object.create ? function(o, e) {
      Object.defineProperty(o, "default", { enumerable: !0, value: e });
    } : function(o, e) {
      o.default = e;
    }), n = Qt && Qt.__importStar || function(o) {
      if (o && o.__esModule) return o;
      var e = {};
      if (o != null) for (var l in o) l !== "default" && Object.prototype.hasOwnProperty.call(o, l) && t(e, o, l);
      return i(e, o), e;
    }, s = Qt && Qt.__exportStar || function(o, e) {
      for (var l in o) l !== "default" && !Object.prototype.hasOwnProperty.call(e, l) && t(e, o, l);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.util = r.check = void 0, r.check = n(ig()), r.util = n(rs()), s(ng(), r), s(sg(), r), s(rs(), r), s(og(), r), s(qg(), r), s(Og(), r), s(Mg(), r), s(Ng(), r), s(Xg(), r), s(Hg(), r);
  }(Qt)), Qt;
}
var Kc;
function Iu() {
  return Kc || (Kc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.BlobRef = r.jsonBlobRef = r.untypedJsonBlobRef = r.typedJsonBlobRef = void 0;
    const t = yn, i = /* @__PURE__ */ fi(), n = _r();
    r.typedJsonBlobRef = i.z.object({
      $type: i.z.literal("blob"),
      ref: n.schema.cid,
      mimeType: i.z.string(),
      size: i.z.number()
    }).strict(), r.untypedJsonBlobRef = i.z.object({
      cid: i.z.string(),
      mimeType: i.z.string()
    }).strict(), r.jsonBlobRef = i.z.union([r.typedJsonBlobRef, r.untypedJsonBlobRef]);
    class s {
      constructor(e, l, a, u) {
        Object.defineProperty(this, "ref", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: e
        }), Object.defineProperty(this, "mimeType", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: l
        }), Object.defineProperty(this, "size", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: a
        }), Object.defineProperty(this, "original", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), this.original = u ?? {
          $type: "blob",
          ref: e,
          mimeType: l,
          size: a
        };
      }
      static asBlobRef(e) {
        return n.check.is(e, r.jsonBlobRef) ? s.fromJsonRef(e) : null;
      }
      static fromJsonRef(e) {
        return n.check.is(e, r.typedJsonBlobRef) ? new s(e.ref, e.mimeType, e.size) : new s(t.CID.parse(e.cid), e.mimeType, -1, e);
      }
      ipld() {
        return {
          $type: "blob",
          ref: this.ref,
          mimeType: this.mimeType,
          size: this.size
        };
      }
      toJSON() {
        return (0, n.ipldToJson)(this.ipld());
      }
    }
    r.BlobRef = s;
  }(yu)), yu;
}
var Ic;
function Zg() {
  if (Ic) return ls;
  Ic = 1, Object.defineProperty(ls, "__esModule", { value: !0 }), ls.blob = i;
  const r = Iu(), t = yi();
  function i(n, s, o, e) {
    return !e || !(e instanceof r.BlobRef) ? {
      success: !1,
      error: new t.ValidationError(`${s} should be a blob ref`)
    } : { success: !0, value: e };
  }
  return ls;
}
var cr = {}, St = {}, Ru = {}, jc;
function Wg() {
  return jc || (jc = 1, function(r) {
    (() => {
      var t = { d: (f, m) => {
        for (var g in m) t.o(m, g) && !t.o(f, g) && Object.defineProperty(f, g, { enumerable: !0, get: m[g] });
      }, o: (f, m) => Object.prototype.hasOwnProperty.call(f, m), r: (f) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(f, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(f, "__esModule", { value: !0 });
      } }, i = {};
      function n(f, m) {
        return m === void 0 && (m = "-"), new RegExp("^(?!0{4}" + m + "0{2}" + m + "0{2})((?=[0-9]{4}" + m + "(((0[^2])|1[0-2])|02(?=" + m + "(([0-1][0-9])|2[0-8])))" + m + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + m + "02" + m + "29))([0-9]{4})" + m + "(?!((0[469])|11)" + m + "31)((0[1,3-9]|1[0-2])|(02(?!" + m + "3)))" + m + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(f);
      }
      function s(f) {
        var m = /\D/.exec(f);
        return m ? m[0] : "";
      }
      function o(f, m, g) {
        m === void 0 && (m = ":"), g === void 0 && (g = !1);
        var A = new RegExp("^([0-1]|2(?=([0-3])|4" + m + "00))[0-9]" + m + "[0-5][0-9](" + m + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
        if (!g || !/[Z+\-]/.test(f)) return A.test(f);
        if (/Z$/.test(f)) return A.test(f.replace("Z", ""));
        var v = f.includes("+"), R = f.split(/[+-]/), E = R[0], h = R[1];
        return A.test(E) && function(C, K, k) {
          return k === void 0 && (k = ":"), new RegExp(K ? "^(0(?!(2" + k + "4)|0" + k + "3)|1(?=([0-1]|2(?=" + k + "[04])|[34](?=" + k + "0))))([03469](?=" + k + "[03])|[17](?=" + k + "0)|2(?=" + k + "[04])|5(?=" + k + "[034])|8(?=" + k + "[04]))" + k + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + k + "[03])|[0-24-8](?=" + k + "00))" + k + "[03]0$").test(C);
        }(h, v, s(h));
      }
      function e(f) {
        var m = f.split("T"), g = m[0], A = m[1], v = n(g, s(g));
        if (!A) return !1;
        var R, E = (R = A.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(R) ? R[0] : "");
        return v && o(A, E, !0);
      }
      function l(f, m) {
        return m === void 0 && (m = "-"), new RegExp("^[0-9]{4}" + m + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(f);
      }
      t.r(i), t.d(i, { isValidDate: () => n, isValidISODateString: () => e, isValidTime: () => o, isValidYearMonth: () => l });
      var a = r;
      for (var u in i) a[u] = i[u];
      i.__esModule && Object.defineProperty(a, "__esModule", { value: !0 });
    })();
  }(Ru)), Ru;
}
var qc;
function Jg() {
  if (qc) return St;
  qc = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.datetime = o, St.uri = e, St.atUri = l, St.did = a, St.handle = u, St.atIdentifier = f, St.nsid = m, St.cid = g, St.language = A, St.tid = v, St.recordKey = R;
  const r = Wg(), t = yn, i = _r(), n = fn(), s = yi();
  function o(E, h) {
    try {
      if (!(0, r.isValidISODateString)(h))
        throw new Error();
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
      };
    }
    return { success: !0, value: h };
  }
  function e(E, h) {
    return h.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null ? { success: !0, value: h } : {
      success: !1,
      error: new s.ValidationError(`${E} must be a uri`)
    };
  }
  function l(E, h) {
    try {
      (0, n.ensureValidAtUri)(h);
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be a valid at-uri`)
      };
    }
    return { success: !0, value: h };
  }
  function a(E, h) {
    try {
      (0, n.ensureValidDid)(h);
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be a valid did`)
      };
    }
    return { success: !0, value: h };
  }
  function u(E, h) {
    try {
      (0, n.ensureValidHandle)(h);
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be a valid handle`)
      };
    }
    return { success: !0, value: h };
  }
  function f(E, h) {
    if (h.startsWith("did:")) {
      const C = a(E, h);
      if (C.success)
        return C;
    } else {
      const C = u(E, h);
      if (C.success)
        return C;
    }
    return {
      success: !1,
      error: new s.ValidationError(`${E} must be a valid did or a handle`)
    };
  }
  function m(E, h) {
    try {
      (0, n.ensureValidNsid)(h);
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be a valid nsid`)
      };
    }
    return { success: !0, value: h };
  }
  function g(E, h) {
    try {
      t.CID.parse(h);
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be a cid string`)
      };
    }
    return { success: !0, value: h };
  }
  function A(E, h) {
    return (0, i.validateLanguage)(h) ? { success: !0, value: h } : {
      success: !1,
      error: new s.ValidationError(`${E} must be a well-formed BCP 47 language tag`)
    };
  }
  function v(E, h) {
    return (0, n.isValidTid)(h) ? { success: !0, value: h } : {
      success: !1,
      error: new s.ValidationError(`${E} must be a valid TID`)
    };
  }
  function R(E, h) {
    try {
      (0, n.ensureValidRecordKey)(h);
    } catch {
      return {
        success: !1,
        error: new s.ValidationError(`${E} must be a valid Record Key`)
      };
    }
    return { success: !0, value: h };
  }
  return St;
}
var Oc;
function Vh() {
  if (Oc) return cr;
  Oc = 1;
  var r = cr && cr.__createBinding || (Object.create ? function(v, R, E, h) {
    h === void 0 && (h = E);
    var C = Object.getOwnPropertyDescriptor(R, E);
    (!C || ("get" in C ? !R.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return R[E];
    } }), Object.defineProperty(v, h, C);
  } : function(v, R, E, h) {
    h === void 0 && (h = E), v[h] = R[E];
  }), t = cr && cr.__setModuleDefault || (Object.create ? function(v, R) {
    Object.defineProperty(v, "default", { enumerable: !0, value: R });
  } : function(v, R) {
    v.default = R;
  }), i = cr && cr.__importStar || function(v) {
    if (v && v.__esModule) return v;
    var R = {};
    if (v != null) for (var E in v) E !== "default" && Object.prototype.hasOwnProperty.call(v, E) && r(R, v, E);
    return t(R, v), R;
  };
  Object.defineProperty(cr, "__esModule", { value: !0 }), cr.validate = l;
  const n = yn, s = _r(), o = yi(), e = i(Jg());
  function l(v, R, E, h) {
    switch (E.type) {
      case "boolean":
        return a(v, R, E, h);
      case "integer":
        return u(v, R, E, h);
      case "string":
        return f(v, R, E, h);
      case "bytes":
        return m(v, R, E, h);
      case "cid-link":
        return g(v, R, E, h);
      case "unknown":
        return A(v, R, E, h);
      default:
        return {
          success: !1,
          error: new o.ValidationError(`Unexpected lexicon type: ${E.type}`)
        };
    }
  }
  function a(v, R, E, h) {
    E = E;
    const C = typeof h;
    return C === "undefined" ? typeof E.default == "boolean" ? { success: !0, value: E.default } : {
      success: !1,
      error: new o.ValidationError(`${R} must be a boolean`)
    } : C !== "boolean" ? {
      success: !1,
      error: new o.ValidationError(`${R} must be a boolean`)
    } : typeof E.const == "boolean" && h !== E.const ? {
      success: !1,
      error: new o.ValidationError(`${R} must be ${E.const}`)
    } : { success: !0, value: h };
  }
  function u(v, R, E, h) {
    return E = E, typeof h === "undefined" ? typeof E.default == "number" ? { success: !0, value: E.default } : {
      success: !1,
      error: new o.ValidationError(`${R} must be an integer`)
    } : Number.isInteger(h) ? typeof E.const == "number" && h !== E.const ? {
      success: !1,
      error: new o.ValidationError(`${R} must be ${E.const}`)
    } : Array.isArray(E.enum) && !E.enum.includes(h) ? {
      success: !1,
      error: new o.ValidationError(`${R} must be one of (${E.enum.join("|")})`)
    } : typeof E.maximum == "number" && h > E.maximum ? {
      success: !1,
      error: new o.ValidationError(`${R} can not be greater than ${E.maximum}`)
    } : typeof E.minimum == "number" && h < E.minimum ? {
      success: !1,
      error: new o.ValidationError(`${R} can not be less than ${E.minimum}`)
    } : { success: !0, value: h } : {
      success: !1,
      error: new o.ValidationError(`${R} must be an integer`)
    };
  }
  function f(v, R, E, h) {
    if (E = E, typeof h > "u")
      return typeof E.default == "string" ? { success: !0, value: E.default } : {
        success: !1,
        error: new o.ValidationError(`${R} must be a string`)
      };
    if (typeof h != "string")
      return {
        success: !1,
        error: new o.ValidationError(`${R} must be a string`)
      };
    if (typeof E.const == "string" && h !== E.const)
      return {
        success: !1,
        error: new o.ValidationError(`${R} must be ${E.const}`)
      };
    if (Array.isArray(E.enum) && !E.enum.includes(h))
      return {
        success: !1,
        error: new o.ValidationError(`${R} must be one of (${E.enum.join("|")})`)
      };
    if (typeof E.minLength == "number" || typeof E.maxLength == "number") {
      if (typeof E.minLength == "number" && h.length * 3 < E.minLength)
        return {
          success: !1,
          error: new o.ValidationError(`${R} must not be shorter than ${E.minLength} characters`)
        };
      let C = !1;
      if (typeof E.minLength > "u" && typeof E.maxLength == "number" && h.length * 3 <= E.maxLength && (C = !0), !C) {
        const K = (0, s.utf8Len)(h);
        if (typeof E.maxLength == "number" && K > E.maxLength)
          return {
            success: !1,
            error: new o.ValidationError(`${R} must not be longer than ${E.maxLength} characters`)
          };
        if (typeof E.minLength == "number" && K < E.minLength)
          return {
            success: !1,
            error: new o.ValidationError(`${R} must not be shorter than ${E.minLength} characters`)
          };
      }
    }
    if (typeof E.maxGraphemes == "number" || typeof E.minGraphemes == "number") {
      let C = !1, K = !1;
      if (typeof E.maxGraphemes == "number" && (h.length <= E.maxGraphemes ? C = !1 : C = !0), typeof E.minGraphemes == "number") {
        if (h.length < E.minGraphemes)
          return {
            success: !1,
            error: new o.ValidationError(`${R} must not be shorter than ${E.minGraphemes} graphemes`)
          };
        K = !0;
      }
      if (C || K) {
        const k = (0, s.graphemeLen)(h);
        if (typeof E.maxGraphemes == "number" && k > E.maxGraphemes)
          return {
            success: !1,
            error: new o.ValidationError(`${R} must not be longer than ${E.maxGraphemes} graphemes`)
          };
        if (typeof E.minGraphemes == "number" && k < E.minGraphemes)
          return {
            success: !1,
            error: new o.ValidationError(`${R} must not be shorter than ${E.minGraphemes} graphemes`)
          };
      }
    }
    if (typeof E.format == "string")
      switch (E.format) {
        case "datetime":
          return e.datetime(R, h);
        case "uri":
          return e.uri(R, h);
        case "at-uri":
          return e.atUri(R, h);
        case "did":
          return e.did(R, h);
        case "handle":
          return e.handle(R, h);
        case "at-identifier":
          return e.atIdentifier(R, h);
        case "nsid":
          return e.nsid(R, h);
        case "cid":
          return e.cid(R, h);
        case "language":
          return e.language(R, h);
        case "tid":
          return e.tid(R, h);
        case "record-key":
          return e.recordKey(R, h);
      }
    return { success: !0, value: h };
  }
  function m(v, R, E, h) {
    return E = E, !h || !(h instanceof Uint8Array) ? {
      success: !1,
      error: new o.ValidationError(`${R} must be a byte array`)
    } : typeof E.maxLength == "number" && h.byteLength > E.maxLength ? {
      success: !1,
      error: new o.ValidationError(`${R} must not be larger than ${E.maxLength} bytes`)
    } : typeof E.minLength == "number" && h.byteLength < E.minLength ? {
      success: !1,
      error: new o.ValidationError(`${R} must not be smaller than ${E.minLength} bytes`)
    } : { success: !0, value: h };
  }
  function g(v, R, E, h) {
    return n.CID.asCID(h) === null ? {
      success: !1,
      error: new o.ValidationError(`${R} must be a CID`)
    } : { success: !0, value: h };
  }
  function A(v, R, E, h) {
    return !h || typeof h != "object" ? {
      success: !1,
      error: new o.ValidationError(`${R} must be an object`)
    } : { success: !0, value: h };
  }
  return cr;
}
var Mc;
function ju() {
  if (Mc) return Yr;
  Mc = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.validate = s, Yr.array = o, Yr.object = e, Yr.validateOneOf = l;
  const r = yi(), t = Uu(), i = Zg(), n = Vh();
  function s(u, f, m, g) {
    switch (m.type) {
      case "object":
        return e(u, f, m, g);
      case "array":
        return o(u, f, m, g);
      case "blob":
        return (0, i.blob)(u, f, m, g);
      default:
        return (0, n.validate)(u, f, m, g);
    }
  }
  function o(u, f, m, g) {
    if (!Array.isArray(g))
      return {
        success: !1,
        error: new r.ValidationError(`${f} must be an array`)
      };
    if (typeof m.maxLength == "number" && g.length > m.maxLength)
      return {
        success: !1,
        error: new r.ValidationError(`${f} must not have more than ${m.maxLength} elements`)
      };
    if (typeof m.minLength == "number" && g.length < m.minLength)
      return {
        success: !1,
        error: new r.ValidationError(`${f} must not have fewer than ${m.minLength} elements`)
      };
    const A = m.items;
    for (let v = 0; v < g.length; v++) {
      const R = g[v], E = `${f}/${v}`, h = l(u, E, A, R);
      if (!h.success)
        return h;
    }
    return { success: !0, value: g };
  }
  function e(u, f, m, g) {
    var v, R, E;
    if (!(0, r.isObj)(g))
      return {
        success: !1,
        error: new r.ValidationError(`${f} must be an object`)
      };
    let A = g;
    if ("properties" in m && m.properties != null)
      for (const h in m.properties) {
        const C = g[h];
        if (C === null && ((v = m.nullable) != null && v.includes(h)))
          continue;
        const K = m.properties[h];
        if (C === void 0 && !((R = m.required) != null && R.includes(h)))
          if (K.type === "integer" || K.type === "boolean" || K.type === "string") {
            if (K.default === void 0)
              continue;
          } else
            continue;
        const k = `${f}/${h}`, F = l(u, k, K, C), Z = F.success ? F.value : C;
        if (Z === void 0) {
          if ((E = m.required) != null && E.includes(h))
            return {
              success: !1,
              error: new r.ValidationError(`${f} must have the property "${h}"`)
            };
        } else if (!F.success)
          return F;
        Z !== C && (A === g && (A = { ...g }), A[h] = Z);
      }
    return { success: !0, value: A };
  }
  function l(u, f, m, g, A = !1) {
    let v;
    if (m.type === "union") {
      if (!(0, r.isDiscriminatedObject)(g))
        return {
          success: !1,
          error: new r.ValidationError(`${f} must be an object which includes the "$type" property`)
        };
      if (a(m.refs, g.$type))
        v = u.getDefOrThrow(g.$type);
      else
        return m.closed ? {
          success: !1,
          error: new r.ValidationError(`${f} $type must be one of ${m.refs.join(", ")}`)
        } : { success: !0, value: g };
    } else m.type === "ref" ? v = u.getDefOrThrow(m.ref) : v = m;
    return A ? e(u, f, v, g) : s(u, f, v, g);
  }
  const a = (u, f) => {
    const m = (0, t.toLexUri)(f);
    return u.includes(m) ? !0 : m.endsWith("#main") ? u.includes(m.slice(0, -5)) : !m.includes("#") && u.includes(`${m}#main`);
  };
  return Yr;
}
var lr = {}, Nc;
function Qg() {
  if (Nc) return lr;
  Nc = 1;
  var r = lr && lr.__createBinding || (Object.create ? function(l, a, u, f) {
    f === void 0 && (f = u);
    var m = Object.getOwnPropertyDescriptor(a, u);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[u];
    } }), Object.defineProperty(l, f, m);
  } : function(l, a, u, f) {
    f === void 0 && (f = u), l[f] = a[u];
  }), t = lr && lr.__setModuleDefault || (Object.create ? function(l, a) {
    Object.defineProperty(l, "default", { enumerable: !0, value: a });
  } : function(l, a) {
    l.default = a;
  }), i = lr && lr.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var a = {};
    if (l != null) for (var u in l) u !== "default" && Object.prototype.hasOwnProperty.call(l, u) && r(a, l, u);
    return t(a, l), a;
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.params = e;
  const n = yi(), s = ju(), o = i(Vh());
  function e(l, a, u, f) {
    const m = f && typeof f == "object" ? f : {}, g = new Set(u.required ?? []);
    let A = m;
    if (typeof u.properties == "object")
      for (const v in u.properties) {
        const R = u.properties[v], E = R.type === "array" ? (0, s.array)(l, v, R, m[v]) : o.validate(l, v, R, m[v]), h = E.success ? E.value : m[v], C = typeof h > "u";
        if (C && g.has(v))
          return {
            success: !1,
            error: new n.ValidationError(`${a} must have the property "${v}"`)
          };
        if (!C && !E.success)
          return E;
        h !== m[v] && (A === m && (A = { ...m }), A[v] = h);
      }
    return { success: !0, value: A };
  }
  return lr;
}
var Gc;
function Yg() {
  if (Gc) return wr;
  Gc = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.assertValidRecord = i, wr.assertValidXrpcParams = n, wr.assertValidXrpcInput = s, wr.assertValidXrpcOutput = o, wr.assertValidXrpcMessage = e;
  const r = ju(), t = Qg();
  function i(a, u, f) {
    const m = (0, r.object)(a, "Record", u.record, f);
    if (!m.success)
      throw m.error;
    return m.value;
  }
  function n(a, u, f) {
    if (u.parameters) {
      const m = (0, t.params)(a, "Params", u.parameters, f);
      if (!m.success)
        throw m.error;
      return m.value;
    }
  }
  function s(a, u, f) {
    var m;
    if ((m = u.input) != null && m.schema)
      return l(a, "Input", u.input.schema, f, !0);
  }
  function o(a, u, f) {
    var m;
    if ((m = u.output) != null && m.schema)
      return l(a, "Output", u.output.schema, f, !0);
  }
  function e(a, u, f) {
    var m;
    if ((m = u.message) != null && m.schema)
      return l(a, "Message", u.message.schema, f, !0);
  }
  function l(a, u, f, m, g = !1) {
    const A = (0, r.validateOneOf)(a, u, f, m, g);
    if (!A.success)
      throw A.error;
    return A.value;
  }
  return wr;
}
var Fc;
function e0() {
  if (Fc) return xn;
  Fc = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.Lexicons = void 0;
  const r = yi(), t = Uu(), i = Yg(), n = ju();
  class s {
    constructor(a) {
      if (Object.defineProperty(this, "docs", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /* @__PURE__ */ new Map()
      }), Object.defineProperty(this, "defs", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /* @__PURE__ */ new Map()
      }), a)
        for (const u of a)
          this.add(u);
    }
    /**
     * @example clone a lexicon:
     * ```ts
     * const clone = new Lexicons(originalLexicon)
     * ```
     *
     * @example get docs array:
     * ```ts
     * const docs = Array.from(lexicons)
     * ```
     */
    [Symbol.iterator]() {
      return this.docs.values();
    }
    /**
     * Add a lexicon doc.
     */
    add(a) {
      const u = (0, t.toLexUri)(a.id);
      if (this.docs.has(u))
        throw new Error(`${u} has already been registered`);
      e(a, u), this.docs.set(u, a);
      for (const [f, m] of o(a))
        this.defs.set(f, m);
    }
    /**
     * Remove a lexicon doc.
     */
    remove(a) {
      a = (0, t.toLexUri)(a);
      const u = this.docs.get(a);
      if (!u)
        throw new Error(`Unable to remove "${a}": does not exist`);
      for (const [f, m] of o(u))
        this.defs.delete(f);
      this.docs.delete(a);
    }
    /**
     * Get a lexicon doc.
     */
    get(a) {
      return a = (0, t.toLexUri)(a), this.docs.get(a);
    }
    /**
     * Get a definition.
     */
    getDef(a) {
      return a = (0, t.toLexUri)(a), this.defs.get(a);
    }
    getDefOrThrow(a, u) {
      const f = this.getDef(a);
      if (!f)
        throw new r.LexiconDefNotFoundError(`Lexicon not found: ${a}`);
      if (u && !u.includes(f.type))
        throw new r.InvalidLexiconError(`Not a ${u.join(" or ")} lexicon: ${a}`);
      return f;
    }
    /**
     * Validate a record or object.
     */
    validate(a, u) {
      if (!(0, r.isObj)(u))
        throw new r.ValidationError("Value must be an object");
      const f = (0, t.toLexUri)(a), m = this.getDefOrThrow(f, ["record", "object"]);
      if (m.type === "record")
        return (0, n.object)(this, "Record", m.record, u);
      if (m.type === "object")
        return (0, n.object)(this, "Object", m, u);
      throw new r.InvalidLexiconError("Definition must be a record or object");
    }
    /**
     * Validate a record and throw on any error.
     */
    assertValidRecord(a, u) {
      if (!(0, r.isObj)(u))
        throw new r.ValidationError("Record must be an object");
      if (!("$type" in u))
        throw new r.ValidationError("Record/$type must be a string");
      const { $type: f } = u;
      if (typeof f != "string")
        throw new r.ValidationError("Record/$type must be a string");
      const m = (0, t.toLexUri)(a);
      if ((0, t.toLexUri)(f) !== m)
        throw new r.ValidationError(`Invalid $type: must be ${m}, got ${f}`);
      const g = this.getDefOrThrow(m, ["record"]);
      return (0, i.assertValidRecord)(this, g, u);
    }
    /**
     * Validate xrpc query params and throw on any error.
     */
    assertValidXrpcParams(a, u) {
      a = (0, t.toLexUri)(a);
      const f = this.getDefOrThrow(a, [
        "query",
        "procedure",
        "subscription"
      ]);
      return (0, i.assertValidXrpcParams)(this, f, u);
    }
    /**
     * Validate xrpc input body and throw on any error.
     */
    assertValidXrpcInput(a, u) {
      a = (0, t.toLexUri)(a);
      const f = this.getDefOrThrow(a, ["procedure"]);
      return (0, i.assertValidXrpcInput)(this, f, u);
    }
    /**
     * Validate xrpc output body and throw on any error.
     */
    assertValidXrpcOutput(a, u) {
      a = (0, t.toLexUri)(a);
      const f = this.getDefOrThrow(a, ["query", "procedure"]);
      return (0, i.assertValidXrpcOutput)(this, f, u);
    }
    /**
     * Validate xrpc subscription message and throw on any error.
     */
    assertValidXrpcMessage(a, u) {
      a = (0, t.toLexUri)(a);
      const f = this.getDefOrThrow(a, ["subscription"]);
      return (0, i.assertValidXrpcMessage)(this, f, u);
    }
    /**
     * Resolve a lex uri given a ref
     */
    resolveLexUri(a, u) {
      return a = (0, t.toLexUri)(a), (0, t.toLexUri)(u, a);
    }
  }
  xn.Lexicons = s;
  function* o(l) {
    for (const a in l.defs)
      yield [`lex:${l.id}#${a}`, l.defs[a]], a === "main" && (yield [`lex:${l.id}`, l.defs[a]]);
  }
  function e(l, a) {
    for (const u in l)
      l.type === "ref" ? l.ref = (0, t.toLexUri)(l.ref, a) : l.type === "union" ? l.refs = l.refs.map((f) => (0, t.toLexUri)(f, a)) : Array.isArray(l[u]) ? l[u] = l[u].map((f) => typeof f == "string" ? f.startsWith("#") ? (0, t.toLexUri)(f, a) : f : f && typeof f == "object" ? e(f, a) : f) : l[u] && typeof l[u] == "object" && (l[u] = e(l[u], a));
    return l;
  }
  return xn;
}
var Au = {}, $c;
function t0() {
  return $c || ($c = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.jsonStringToLex = r.jsonToLex = r.stringifyLex = r.lexToJson = r.ipldToLex = r.lexToIpld = void 0;
    const t = yn, i = _r(), n = Iu(), s = (f) => {
      if (Array.isArray(f))
        return f.map((m) => (0, r.lexToIpld)(m));
      if (f && typeof f == "object") {
        if (f instanceof n.BlobRef)
          return f.original;
        if (t.CID.asCID(f) || f instanceof Uint8Array)
          return f;
        const m = {};
        for (const g of Object.keys(f))
          m[g] = (0, r.lexToIpld)(f[g]);
        return m;
      }
      return f;
    };
    r.lexToIpld = s;
    const o = (f) => {
      if (Array.isArray(f))
        return f.map((m) => (0, r.ipldToLex)(m));
      if (f && typeof f == "object") {
        if ((f.$type === "blob" || typeof f.cid == "string" && typeof f.mimeType == "string") && i.check.is(f, n.jsonBlobRef))
          return n.BlobRef.fromJsonRef(f);
        if (t.CID.asCID(f) || f instanceof Uint8Array)
          return f;
        const m = {};
        for (const g of Object.keys(f))
          m[g] = (0, r.ipldToLex)(f[g]);
        return m;
      }
      return f;
    };
    r.ipldToLex = o;
    const e = (f) => (0, i.ipldToJson)((0, r.lexToIpld)(f));
    r.lexToJson = e;
    const l = (f) => JSON.stringify((0, r.lexToJson)(f));
    r.stringifyLex = l;
    const a = (f) => (0, r.ipldToLex)((0, i.jsonToIpld)(f));
    r.jsonToLex = a;
    const u = (f) => (0, r.jsonToLex)(JSON.parse(f));
    r.jsonStringToLex = u;
  }(Au)), Au;
}
var zc;
function pn() {
  return zc || (zc = 1, function(r) {
    var t = Hr && Hr.__createBinding || (Object.create ? function(n, s, o, e) {
      e === void 0 && (e = o);
      var l = Object.getOwnPropertyDescriptor(s, o);
      (!l || ("get" in l ? !s.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
        return s[o];
      } }), Object.defineProperty(n, e, l);
    } : function(n, s, o, e) {
      e === void 0 && (e = o), n[e] = s[o];
    }), i = Hr && Hr.__exportStar || function(n, s) {
      for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && t(s, n, o);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), i(yi(), r), i(e0(), r), i(Iu(), r), i(t0(), r);
  }(Hr)), Hr;
}
var _u = {}, xi = {}, Xc;
function w() {
  if (Xc) return xi;
  Xc = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.is$typed = i, xi.maybe$typed = n, xi.asPredicate = s;
  function r(o) {
    return o != null && typeof o == "object";
  }
  function t(o, e, l) {
    return l === "main" ? o === e : (
      // $type === `${id}#${hash}`
      typeof o == "string" && o.length === e.length + 1 + l.length && o.charCodeAt(e.length) === 35 && o.startsWith(e) && o.endsWith(l)
    );
  }
  function i(o, e, l) {
    return r(o) && "$type" in o && t(o.$type, e, l);
  }
  function n(o, e, l) {
    return r(o) && ("$type" in o ? o.$type === void 0 || t(o.$type, e, l) : !0);
  }
  function s(o) {
    return function(e) {
      return o(e).success;
    };
  }
  return xi;
}
var Hc;
function S() {
  return Hc || (Hc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.ids = r.lexicons = r.schemas = r.schemaDict = void 0, r.validate = n;
    const t = pn(), i = w();
    r.schemaDict = {
      ComAtprotoAdminDefs: {
        lexicon: 1,
        id: "com.atproto.admin.defs",
        defs: {
          statusAttr: {
            type: "object",
            required: ["applied"],
            properties: {
              applied: {
                type: "boolean"
              },
              ref: {
                type: "string"
              }
            }
          },
          accountView: {
            type: "object",
            required: ["did", "handle", "indexedAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              email: {
                type: "string"
              },
              relatedRecords: {
                type: "array",
                items: {
                  type: "unknown"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              invitedBy: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              },
              invites: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                }
              },
              invitesDisabled: {
                type: "boolean"
              },
              emailConfirmedAt: {
                type: "string",
                format: "datetime"
              },
              inviteNote: {
                type: "string"
              },
              deactivatedAt: {
                type: "string",
                format: "datetime"
              },
              threatSignatures: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#threatSignature"
                }
              }
            }
          },
          repoRef: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          repoBlobRef: {
            type: "object",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              recordUri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          threatSignature: {
            type: "object",
            required: ["property", "value"],
            properties: {
              property: {
                type: "string"
              },
              value: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoAdminDeleteAccount: {
        lexicon: 1,
        id: "com.atproto.admin.deleteAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Delete a user account as an administrator.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminDisableAccountInvites: {
        lexicon: 1,
        id: "com.atproto.admin.disableAccountInvites",
        defs: {
          main: {
            type: "procedure",
            description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["account"],
                properties: {
                  account: {
                    type: "string",
                    format: "did"
                  },
                  note: {
                    type: "string",
                    description: "Optional reason for disabled invites."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminDisableInviteCodes: {
        lexicon: 1,
        id: "com.atproto.admin.disableInviteCodes",
        defs: {
          main: {
            type: "procedure",
            description: "Disable some set of codes and/or all codes associated with a set of users.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  codes: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  accounts: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminEnableAccountInvites: {
        lexicon: 1,
        id: "com.atproto.admin.enableAccountInvites",
        defs: {
          main: {
            type: "procedure",
            description: "Re-enable an account's ability to receive invite codes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["account"],
                properties: {
                  account: {
                    type: "string",
                    format: "did"
                  },
                  note: {
                    type: "string",
                    description: "Optional reason for enabled invites."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminGetAccountInfo: {
        lexicon: 1,
        id: "com.atproto.admin.getAccountInfo",
        defs: {
          main: {
            type: "query",
            description: "Get details about an account.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#accountView"
              }
            }
          }
        }
      },
      ComAtprotoAdminGetAccountInfos: {
        lexicon: 1,
        id: "com.atproto.admin.getAccountInfos",
        defs: {
          main: {
            type: "query",
            description: "Get details about some accounts.",
            parameters: {
              type: "params",
              required: ["dids"],
              properties: {
                dids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["infos"],
                properties: {
                  infos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#accountView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminGetInviteCodes: {
        lexicon: 1,
        id: "com.atproto.admin.getInviteCodes",
        defs: {
          main: {
            type: "query",
            description: "Get an admin view of invite codes.",
            parameters: {
              type: "params",
              properties: {
                sort: {
                  type: "string",
                  knownValues: ["recent", "usage"],
                  default: "recent"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 500,
                  default: 100
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codes"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  codes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.defs#inviteCode"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminGetSubjectStatus: {
        lexicon: 1,
        id: "com.atproto.admin.getSubjectStatus",
        defs: {
          main: {
            type: "query",
            description: "Get the service-specific admin status of a subject (account, record, or blob).",
            parameters: {
              type: "params",
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blob: {
                  type: "string",
                  format: "cid"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject"],
                properties: {
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef",
                      "lex:com.atproto.admin.defs#repoBlobRef"
                    ]
                  },
                  takedown: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  },
                  deactivated: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminSearchAccounts: {
        lexicon: 1,
        id: "com.atproto.admin.searchAccounts",
        defs: {
          main: {
            type: "query",
            description: "Get list of accounts that matches your search query.",
            parameters: {
              type: "params",
              properties: {
                email: {
                  type: "string"
                },
                cursor: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accounts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  accounts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#accountView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminSendEmail: {
        lexicon: 1,
        id: "com.atproto.admin.sendEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Send email to a user's account email address.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["recipientDid", "content", "senderDid"],
                properties: {
                  recipientDid: {
                    type: "string",
                    format: "did"
                  },
                  content: {
                    type: "string"
                  },
                  subject: {
                    type: "string"
                  },
                  senderDid: {
                    type: "string",
                    format: "did"
                  },
                  comment: {
                    type: "string",
                    description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["sent"],
                properties: {
                  sent: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateAccountEmail: {
        lexicon: 1,
        id: "com.atproto.admin.updateAccountEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to update an account's email.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["account", "email"],
                properties: {
                  account: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  email: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateAccountHandle: {
        lexicon: 1,
        id: "com.atproto.admin.updateAccountHandle",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to update an account's handle.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "handle"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateAccountPassword: {
        lexicon: 1,
        id: "com.atproto.admin.updateAccountPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Update the password for a user account as an administrator.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "password"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  password: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateAccountSigningKey: {
        lexicon: 1,
        id: "com.atproto.admin.updateAccountSigningKey",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to update an account's signing key in their Did document.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "signingKey"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  signingKey: {
                    type: "string",
                    format: "did",
                    description: "Did-key formatted public key"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoAdminUpdateSubjectStatus: {
        lexicon: 1,
        id: "com.atproto.admin.updateSubjectStatus",
        defs: {
          main: {
            type: "procedure",
            description: "Update the service-specific admin status of a subject (account, record, or blob).",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject"],
                properties: {
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef",
                      "lex:com.atproto.admin.defs#repoBlobRef"
                    ]
                  },
                  takedown: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  },
                  deactivated: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject"],
                properties: {
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef",
                      "lex:com.atproto.admin.defs#repoBlobRef"
                    ]
                  },
                  takedown: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#statusAttr"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoIdentityDefs: {
        lexicon: 1,
        id: "com.atproto.identity.defs",
        defs: {
          identityInfo: {
            type: "object",
            required: ["did", "handle", "didDoc"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle",
                description: "The validated handle of the account; or 'handle.invalid' if the handle did not bi-directionally match the DID document."
              },
              didDoc: {
                type: "unknown",
                description: "The complete DID document for the identity."
              }
            }
          }
        }
      },
      ComAtprotoIdentityGetRecommendedDidCredentials: {
        lexicon: 1,
        id: "com.atproto.identity.getRecommendedDidCredentials",
        defs: {
          main: {
            type: "query",
            description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  rotationKeys: {
                    description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  alsoKnownAs: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  verificationMethods: {
                    type: "unknown"
                  },
                  services: {
                    type: "unknown"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoIdentityRefreshIdentity: {
        lexicon: 1,
        id: "com.atproto.identity.refreshIdentity",
        defs: {
          main: {
            type: "procedure",
            description: "Request that the server re-resolve an identity (DID and handle). The server may ignore this request, or require authentication, depending on the role, implementation, and policy of the server.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["identifier"],
                properties: {
                  identifier: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.identity.defs#identityInfo"
              }
            },
            errors: [
              {
                name: "HandleNotFound",
                description: "The resolution process confirmed that the handle does not resolve to any DID."
              },
              {
                name: "DidNotFound",
                description: "The DID resolution process confirmed that there is no current DID."
              },
              {
                name: "DidDeactivated",
                description: "The DID previously existed, but has been deactivated."
              }
            ]
          }
        }
      },
      ComAtprotoIdentityRequestPlcOperationSignature: {
        lexicon: 1,
        id: "com.atproto.identity.requestPlcOperationSignature",
        defs: {
          main: {
            type: "procedure",
            description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
          }
        }
      },
      ComAtprotoIdentityResolveDid: {
        lexicon: 1,
        id: "com.atproto.identity.resolveDid",
        defs: {
          main: {
            type: "query",
            description: "Resolves DID to DID document. Does not bi-directionally verify handle.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "DID to resolve."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["didDoc"],
                properties: {
                  didDoc: {
                    type: "unknown",
                    description: "The complete DID document for the identity."
                  }
                }
              }
            },
            errors: [
              {
                name: "DidNotFound",
                description: "The DID resolution process confirmed that there is no current DID."
              },
              {
                name: "DidDeactivated",
                description: "The DID previously existed, but has been deactivated."
              }
            ]
          }
        }
      },
      ComAtprotoIdentityResolveHandle: {
        lexicon: 1,
        id: "com.atproto.identity.resolveHandle",
        defs: {
          main: {
            type: "query",
            description: "Resolves an atproto handle (hostname) to a DID. Does not necessarily bi-directionally verify against the the DID document.",
            parameters: {
              type: "params",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The handle to resolve."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            errors: [
              {
                name: "HandleNotFound",
                description: "The resolution process confirmed that the handle does not resolve to any DID."
              }
            ]
          }
        }
      },
      ComAtprotoIdentityResolveIdentity: {
        lexicon: 1,
        id: "com.atproto.identity.resolveIdentity",
        defs: {
          main: {
            type: "query",
            description: "Resolves an identity (DID or Handle) to a full identity (DID document and verified handle).",
            parameters: {
              type: "params",
              required: ["identifier"],
              properties: {
                identifier: {
                  type: "string",
                  format: "at-identifier",
                  description: "Handle or DID to resolve."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.identity.defs#identityInfo"
              }
            },
            errors: [
              {
                name: "HandleNotFound",
                description: "The resolution process confirmed that the handle does not resolve to any DID."
              },
              {
                name: "DidNotFound",
                description: "The DID resolution process confirmed that there is no current DID."
              },
              {
                name: "DidDeactivated",
                description: "The DID previously existed, but has been deactivated."
              }
            ]
          }
        }
      },
      ComAtprotoIdentitySignPlcOperation: {
        lexicon: 1,
        id: "com.atproto.identity.signPlcOperation",
        defs: {
          main: {
            type: "procedure",
            description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  token: {
                    description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                    type: "string"
                  },
                  rotationKeys: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  alsoKnownAs: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  verificationMethods: {
                    type: "unknown"
                  },
                  services: {
                    type: "unknown"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["operation"],
                properties: {
                  operation: {
                    type: "unknown",
                    description: "A signed DID PLC operation."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoIdentitySubmitPlcOperation: {
        lexicon: 1,
        id: "com.atproto.identity.submitPlcOperation",
        defs: {
          main: {
            type: "procedure",
            description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["operation"],
                properties: {
                  operation: {
                    type: "unknown"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoIdentityUpdateHandle: {
        lexicon: 1,
        id: "com.atproto.identity.updateHandle",
        defs: {
          main: {
            type: "procedure",
            description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "The new handle."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoLabelDefs: {
        lexicon: 1,
        id: "com.atproto.label.defs",
        defs: {
          label: {
            type: "object",
            description: "Metadata tag on an atproto resource (eg, repo or record).",
            required: ["src", "uri", "val", "cts"],
            properties: {
              ver: {
                type: "integer",
                description: "The AT Protocol version of the label object."
              },
              src: {
                type: "string",
                format: "did",
                description: "DID of the actor who created this label."
              },
              uri: {
                type: "string",
                format: "uri",
                description: "AT URI of the record, repository (account), or other resource that this label applies to."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
              },
              val: {
                type: "string",
                maxLength: 128,
                description: "The short string name of the value or type of this label."
              },
              neg: {
                type: "boolean",
                description: "If true, this is a negation label, overwriting a previous label."
              },
              cts: {
                type: "string",
                format: "datetime",
                description: "Timestamp when this label was created."
              },
              exp: {
                type: "string",
                format: "datetime",
                description: "Timestamp at which this label expires (no longer applies)."
              },
              sig: {
                type: "bytes",
                description: "Signature of dag-cbor encoded label."
              }
            }
          },
          selfLabels: {
            type: "object",
            description: "Metadata tags on an atproto record, published by the author within the record.",
            required: ["values"],
            properties: {
              values: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#selfLabel"
                },
                maxLength: 10
              }
            }
          },
          selfLabel: {
            type: "object",
            description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
            required: ["val"],
            properties: {
              val: {
                type: "string",
                maxLength: 128,
                description: "The short string name of the value or type of this label."
              }
            }
          },
          labelValueDefinition: {
            type: "object",
            description: "Declares a label value and its expected interpretations and behaviors.",
            required: ["identifier", "severity", "blurs", "locales"],
            properties: {
              identifier: {
                type: "string",
                description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
                maxLength: 100,
                maxGraphemes: 100
              },
              severity: {
                type: "string",
                description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
                knownValues: ["inform", "alert", "none"]
              },
              blurs: {
                type: "string",
                description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
                knownValues: ["content", "media", "none"]
              },
              defaultSetting: {
                type: "string",
                description: "The default setting for this label.",
                knownValues: ["ignore", "warn", "hide"],
                default: "warn"
              },
              adultOnly: {
                type: "boolean",
                description: "Does the user need to have adult content enabled in order to configure this label?"
              },
              locales: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
                }
              }
            }
          },
          labelValueDefinitionStrings: {
            type: "object",
            description: "Strings which describe the label in the UI, localized into a specific language.",
            required: ["lang", "name", "description"],
            properties: {
              lang: {
                type: "string",
                description: "The code of the language these strings are written in.",
                format: "language"
              },
              name: {
                type: "string",
                description: "A short human-readable name for the label.",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                description: "A longer description of what the label means and why it might be applied.",
                maxGraphemes: 1e4,
                maxLength: 1e5
              }
            }
          },
          labelValue: {
            type: "string",
            knownValues: [
              "!hide",
              "!no-promote",
              "!warn",
              "!no-unauthenticated",
              "dmca-violation",
              "doxxing",
              "porn",
              "sexual",
              "nudity",
              "nsfl",
              "gore"
            ]
          }
        }
      },
      ComAtprotoLabelQueryLabels: {
        lexicon: 1,
        id: "com.atproto.label.queryLabels",
        defs: {
          main: {
            type: "query",
            description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
            parameters: {
              type: "params",
              required: ["uriPatterns"],
              properties: {
                uriPatterns: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                },
                sources: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  },
                  description: "Optional list of label sources (DIDs) to filter on."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 250,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["labels"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  labels: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.label.defs#label"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoLabelSubscribeLabels: {
        lexicon: 1,
        id: "com.atproto.label.subscribeLabels",
        defs: {
          main: {
            type: "subscription",
            description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
            parameters: {
              type: "params",
              properties: {
                cursor: {
                  type: "integer",
                  description: "The last known event seq number to backfill from."
                }
              }
            },
            message: {
              schema: {
                type: "union",
                refs: [
                  "lex:com.atproto.label.subscribeLabels#labels",
                  "lex:com.atproto.label.subscribeLabels#info"
                ]
              }
            },
            errors: [
              {
                name: "FutureCursor"
              }
            ]
          },
          labels: {
            type: "object",
            required: ["seq", "labels"],
            properties: {
              seq: {
                type: "integer"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          },
          info: {
            type: "object",
            required: ["name"],
            properties: {
              name: {
                type: "string",
                knownValues: ["OutdatedCursor"]
              },
              message: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoLexiconSchema: {
        lexicon: 1,
        id: "com.atproto.lexicon.schema",
        defs: {
          main: {
            type: "record",
            description: "Representation of Lexicon schemas themselves, when published as atproto records. Note that the schema language is not defined in Lexicon; this meta schema currently only includes a single version field ('lexicon'). See the atproto specifications for description of the other expected top-level fields ('id', 'defs', etc).",
            key: "nsid",
            record: {
              type: "object",
              required: ["lexicon"],
              properties: {
                lexicon: {
                  type: "integer",
                  description: "Indicates the 'version' of the Lexicon language. Must be '1' for the current atproto/Lexicon schema system."
                }
              }
            }
          }
        }
      },
      ComAtprotoModerationCreateReport: {
        lexicon: 1,
        id: "com.atproto.moderation.createReport",
        defs: {
          main: {
            type: "procedure",
            description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["reasonType", "subject"],
                properties: {
                  reasonType: {
                    type: "ref",
                    description: "Indicates the broad category of violation the report is for.",
                    ref: "lex:com.atproto.moderation.defs#reasonType"
                  },
                  reason: {
                    type: "string",
                    maxGraphemes: 2e3,
                    maxLength: 2e4,
                    description: "Additional context about the content and violation."
                  },
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef"
                    ]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [
                  "id",
                  "reasonType",
                  "subject",
                  "reportedBy",
                  "createdAt"
                ],
                properties: {
                  id: {
                    type: "integer"
                  },
                  reasonType: {
                    type: "ref",
                    ref: "lex:com.atproto.moderation.defs#reasonType"
                  },
                  reason: {
                    type: "string",
                    maxGraphemes: 2e3,
                    maxLength: 2e4
                  },
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef"
                    ]
                  },
                  reportedBy: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoModerationDefs: {
        lexicon: 1,
        id: "com.atproto.moderation.defs",
        defs: {
          reasonType: {
            type: "string",
            knownValues: [
              "com.atproto.moderation.defs#reasonSpam",
              "com.atproto.moderation.defs#reasonViolation",
              "com.atproto.moderation.defs#reasonMisleading",
              "com.atproto.moderation.defs#reasonSexual",
              "com.atproto.moderation.defs#reasonRude",
              "com.atproto.moderation.defs#reasonOther",
              "com.atproto.moderation.defs#reasonAppeal"
            ]
          },
          reasonSpam: {
            type: "token",
            description: "Spam: frequent unwanted promotion, replies, mentions"
          },
          reasonViolation: {
            type: "token",
            description: "Direct violation of server rules, laws, terms of service"
          },
          reasonMisleading: {
            type: "token",
            description: "Misleading identity, affiliation, or content"
          },
          reasonSexual: {
            type: "token",
            description: "Unwanted or mislabeled sexual content"
          },
          reasonRude: {
            type: "token",
            description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
          },
          reasonOther: {
            type: "token",
            description: "Other: reports not falling under another report category"
          },
          reasonAppeal: {
            type: "token",
            description: "Appeal: appeal a previously taken moderation action"
          },
          subjectType: {
            type: "string",
            description: "Tag describing a type of subject that might be reported.",
            knownValues: ["account", "record", "chat"]
          }
        }
      },
      ComAtprotoRepoApplyWrites: {
        lexicon: 1,
        id: "com.atproto.repo.applyWrites",
        defs: {
          main: {
            type: "procedure",
            description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "writes"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo (aka, current account)."
                  },
                  validate: {
                    type: "boolean",
                    description: "Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons."
                  },
                  writes: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.repo.applyWrites#create",
                        "lex:com.atproto.repo.applyWrites#update",
                        "lex:com.atproto.repo.applyWrites#delete"
                      ],
                      closed: !0
                    }
                  },
                  swapCommit: {
                    type: "string",
                    description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                    format: "cid"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [],
                properties: {
                  commit: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.defs#commitMeta"
                  },
                  results: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.repo.applyWrites#createResult",
                        "lex:com.atproto.repo.applyWrites#updateResult",
                        "lex:com.atproto.repo.applyWrites#deleteResult"
                      ],
                      closed: !0
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap",
                description: "Indicates that the 'swapCommit' parameter did not match current commit."
              }
            ]
          },
          create: {
            type: "object",
            description: "Operation which creates a new record.",
            required: ["collection", "value"],
            properties: {
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                maxLength: 512,
                format: "record-key",
                description: "NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility."
              },
              value: {
                type: "unknown"
              }
            }
          },
          update: {
            type: "object",
            description: "Operation which updates an existing record.",
            required: ["collection", "rkey", "value"],
            properties: {
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                format: "record-key"
              },
              value: {
                type: "unknown"
              }
            }
          },
          delete: {
            type: "object",
            description: "Operation which deletes an existing record.",
            required: ["collection", "rkey"],
            properties: {
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                format: "record-key"
              }
            }
          },
          createResult: {
            type: "object",
            required: ["uri", "cid"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              validationStatus: {
                type: "string",
                knownValues: ["valid", "unknown"]
              }
            }
          },
          updateResult: {
            type: "object",
            required: ["uri", "cid"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              validationStatus: {
                type: "string",
                knownValues: ["valid", "unknown"]
              }
            }
          },
          deleteResult: {
            type: "object",
            required: [],
            properties: {}
          }
        }
      },
      ComAtprotoRepoCreateRecord: {
        lexicon: 1,
        id: "com.atproto.repo.createRecord",
        defs: {
          main: {
            type: "procedure",
            description: "Create a single new repository record. Requires auth, implemented by PDS.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "collection", "record"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo (aka, current account)."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    format: "record-key",
                    description: "The Record Key.",
                    maxLength: 512
                  },
                  validate: {
                    type: "boolean",
                    description: "Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons."
                  },
                  record: {
                    type: "unknown",
                    description: "The record itself. Must contain a $type field."
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous commit by CID."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "cid"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  commit: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.defs#commitMeta"
                  },
                  validationStatus: {
                    type: "string",
                    knownValues: ["valid", "unknown"]
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap",
                description: "Indicates that 'swapCommit' didn't match current repo commit."
              }
            ]
          }
        }
      },
      ComAtprotoRepoDefs: {
        lexicon: 1,
        id: "com.atproto.repo.defs",
        defs: {
          commitMeta: {
            type: "object",
            required: ["cid", "rev"],
            properties: {
              cid: {
                type: "string",
                format: "cid"
              },
              rev: {
                type: "string",
                format: "tid"
              }
            }
          }
        }
      },
      ComAtprotoRepoDeleteRecord: {
        lexicon: 1,
        id: "com.atproto.repo.deleteRecord",
        defs: {
          main: {
            type: "procedure",
            description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo (aka, current account)."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    format: "record-key",
                    description: "The Record Key."
                  },
                  swapRecord: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous record by CID."
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous commit by CID."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  commit: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.defs#commitMeta"
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap"
              }
            ]
          }
        }
      },
      ComAtprotoRepoDescribeRepo: {
        lexicon: 1,
        id: "com.atproto.repo.describeRepo",
        defs: {
          main: {
            type: "query",
            description: "Get information about an account and repository, including the list of collections. Does not require auth.",
            parameters: {
              type: "params",
              required: ["repo"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [
                  "handle",
                  "did",
                  "didDoc",
                  "collections",
                  "handleIsCorrect"
                ],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown",
                    description: "The complete DID document for this account."
                  },
                  collections: {
                    type: "array",
                    description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  handleIsCorrect: {
                    type: "boolean",
                    description: "Indicates if handle is currently valid (resolves bi-directionally)"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoRepoGetRecord: {
        lexicon: 1,
        id: "com.atproto.repo.getRecord",
        defs: {
          main: {
            type: "query",
            description: "Get a single record from a repository. Does not require auth.",
            parameters: {
              type: "params",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  format: "record-key"
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "The CID of the version of the record. If not specified, then return the most recent version."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "value"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  value: {
                    type: "unknown"
                  }
                }
              }
            },
            errors: [
              {
                name: "RecordNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoRepoImportRepo: {
        lexicon: 1,
        id: "com.atproto.repo.importRepo",
        defs: {
          main: {
            type: "procedure",
            description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
            input: {
              encoding: "application/vnd.ipld.car"
            }
          }
        }
      },
      ComAtprotoRepoListMissingBlobs: {
        lexicon: 1,
        id: "com.atproto.repo.listMissingBlobs",
        defs: {
          main: {
            type: "query",
            description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 500
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["blobs"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  blobs: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                    }
                  }
                }
              }
            }
          },
          recordBlob: {
            type: "object",
            required: ["cid", "recordUri"],
            properties: {
              cid: {
                type: "string",
                format: "cid"
              },
              recordUri: {
                type: "string",
                format: "at-uri"
              }
            }
          }
        }
      },
      ComAtprotoRepoListRecords: {
        lexicon: 1,
        id: "com.atproto.repo.listRecords",
        defs: {
          main: {
            type: "query",
            description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
            parameters: {
              type: "params",
              required: ["repo", "collection"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record type."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50,
                  description: "The number of records to return."
                },
                cursor: {
                  type: "string"
                },
                reverse: {
                  type: "boolean",
                  description: "Flag to reverse the order of the returned records."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["records"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  records: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.listRecords#record"
                    }
                  }
                }
              }
            }
          },
          record: {
            type: "object",
            required: ["uri", "cid", "value"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              value: {
                type: "unknown"
              }
            }
          }
        }
      },
      ComAtprotoRepoPutRecord: {
        lexicon: 1,
        id: "com.atproto.repo.putRecord",
        defs: {
          main: {
            type: "procedure",
            description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repo", "collection", "rkey", "record"],
                nullable: ["swapRecord"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo (aka, current account)."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    format: "record-key",
                    description: "The Record Key.",
                    maxLength: 512
                  },
                  validate: {
                    type: "boolean",
                    description: "Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons."
                  },
                  record: {
                    type: "unknown",
                    description: "The record to write."
                  },
                  swapRecord: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                  },
                  swapCommit: {
                    type: "string",
                    format: "cid",
                    description: "Compare and swap with the previous commit by CID."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "cid"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  commit: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.defs#commitMeta"
                  },
                  validationStatus: {
                    type: "string",
                    knownValues: ["valid", "unknown"]
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidSwap"
              }
            ]
          }
        }
      },
      ComAtprotoRepoStrongRef: {
        lexicon: 1,
        id: "com.atproto.repo.strongRef",
        description: "A URI with a content-hash fingerprint.",
        defs: {
          main: {
            type: "object",
            required: ["uri", "cid"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          }
        }
      },
      ComAtprotoRepoUploadBlob: {
        lexicon: 1,
        id: "com.atproto.repo.uploadBlob",
        defs: {
          main: {
            type: "procedure",
            description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
            input: {
              encoding: "*/*"
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["blob"],
                properties: {
                  blob: {
                    type: "blob"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerActivateAccount: {
        lexicon: 1,
        id: "com.atproto.server.activateAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
          }
        }
      },
      ComAtprotoServerCheckAccountStatus: {
        lexicon: 1,
        id: "com.atproto.server.checkAccountStatus",
        defs: {
          main: {
            type: "query",
            description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [
                  "activated",
                  "validDid",
                  "repoCommit",
                  "repoRev",
                  "repoBlocks",
                  "indexedRecords",
                  "privateStateValues",
                  "expectedBlobs",
                  "importedBlobs"
                ],
                properties: {
                  activated: {
                    type: "boolean"
                  },
                  validDid: {
                    type: "boolean"
                  },
                  repoCommit: {
                    type: "string",
                    format: "cid"
                  },
                  repoRev: {
                    type: "string"
                  },
                  repoBlocks: {
                    type: "integer"
                  },
                  indexedRecords: {
                    type: "integer"
                  },
                  privateStateValues: {
                    type: "integer"
                  },
                  expectedBlobs: {
                    type: "integer"
                  },
                  importedBlobs: {
                    type: "integer"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerConfirmEmail: {
        lexicon: 1,
        id: "com.atproto.server.confirmEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["email", "token"],
                properties: {
                  email: {
                    type: "string"
                  },
                  token: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountNotFound"
              },
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              },
              {
                name: "InvalidEmail"
              }
            ]
          }
        }
      },
      ComAtprotoServerCreateAccount: {
        lexicon: 1,
        id: "com.atproto.server.createAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Create an account. Implemented by PDS.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle"],
                properties: {
                  email: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "Requested handle for the account."
                  },
                  did: {
                    type: "string",
                    format: "did",
                    description: "Pre-existing atproto DID, being imported to a new account."
                  },
                  inviteCode: {
                    type: "string"
                  },
                  verificationCode: {
                    type: "string"
                  },
                  verificationPhone: {
                    type: "string"
                  },
                  password: {
                    type: "string",
                    description: "Initial account password. May need to meet instance-specific password strength requirements."
                  },
                  recoveryKey: {
                    type: "string",
                    description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                  },
                  plcOp: {
                    type: "unknown",
                    description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                description: "Account login session returned on successful account creation.",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the new account."
                  },
                  didDoc: {
                    type: "unknown",
                    description: "Complete DID document."
                  }
                }
              }
            },
            errors: [
              {
                name: "InvalidHandle"
              },
              {
                name: "InvalidPassword"
              },
              {
                name: "InvalidInviteCode"
              },
              {
                name: "HandleNotAvailable"
              },
              {
                name: "UnsupportedDomain"
              },
              {
                name: "UnresolvableDid"
              },
              {
                name: "IncompatibleDidDoc"
              }
            ]
          }
        }
      },
      ComAtprotoServerCreateAppPassword: {
        lexicon: 1,
        id: "com.atproto.server.createAppPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Create an App Password.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    type: "string",
                    description: "A short name for the App Password, to help distinguish them."
                  },
                  privileged: {
                    type: "boolean",
                    description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:com.atproto.server.createAppPassword#appPassword"
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          },
          appPassword: {
            type: "object",
            required: ["name", "password", "createdAt"],
            properties: {
              name: {
                type: "string"
              },
              password: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              privileged: {
                type: "boolean"
              }
            }
          }
        }
      },
      ComAtprotoServerCreateInviteCode: {
        lexicon: 1,
        id: "com.atproto.server.createInviteCode",
        defs: {
          main: {
            type: "procedure",
            description: "Create an invite code.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["useCount"],
                properties: {
                  useCount: {
                    type: "integer"
                  },
                  forAccount: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["code"],
                properties: {
                  code: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerCreateInviteCodes: {
        lexicon: 1,
        id: "com.atproto.server.createInviteCodes",
        defs: {
          main: {
            type: "procedure",
            description: "Create invite codes.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codeCount", "useCount"],
                properties: {
                  codeCount: {
                    type: "integer",
                    default: 1
                  },
                  useCount: {
                    type: "integer"
                  },
                  forAccounts: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codes"],
                properties: {
                  codes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                    }
                  }
                }
              }
            }
          },
          accountCodes: {
            type: "object",
            required: ["account", "codes"],
            properties: {
              account: {
                type: "string"
              },
              codes: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            }
          }
        }
      },
      ComAtprotoServerCreateSession: {
        lexicon: 1,
        id: "com.atproto.server.createSession",
        defs: {
          main: {
            type: "procedure",
            description: "Create an authentication session.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["identifier", "password"],
                properties: {
                  identifier: {
                    type: "string",
                    description: "Handle or other identifier supported by the server for the authenticating user."
                  },
                  password: {
                    type: "string"
                  },
                  authFactorToken: {
                    type: "string"
                  },
                  allowTakendown: {
                    type: "boolean",
                    description: "When true, instead of throwing error for takendown accounts, a valid response with a narrow scoped token will be returned"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown"
                  },
                  email: {
                    type: "string"
                  },
                  emailConfirmed: {
                    type: "boolean"
                  },
                  emailAuthFactor: {
                    type: "boolean"
                  },
                  active: {
                    type: "boolean"
                  },
                  status: {
                    type: "string",
                    description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                    knownValues: ["takendown", "suspended", "deactivated"]
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              },
              {
                name: "AuthFactorTokenRequired"
              }
            ]
          }
        }
      },
      ComAtprotoServerDeactivateAccount: {
        lexicon: 1,
        id: "com.atproto.server.deactivateAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  deleteAfter: {
                    type: "string",
                    format: "datetime",
                    description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerDefs: {
        lexicon: 1,
        id: "com.atproto.server.defs",
        defs: {
          inviteCode: {
            type: "object",
            required: [
              "code",
              "available",
              "disabled",
              "forAccount",
              "createdBy",
              "createdAt",
              "uses"
            ],
            properties: {
              code: {
                type: "string"
              },
              available: {
                type: "integer"
              },
              disabled: {
                type: "boolean"
              },
              forAccount: {
                type: "string"
              },
              createdBy: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              uses: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCodeUse"
                }
              }
            }
          },
          inviteCodeUse: {
            type: "object",
            required: ["usedBy", "usedAt"],
            properties: {
              usedBy: {
                type: "string",
                format: "did"
              },
              usedAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      },
      ComAtprotoServerDeleteAccount: {
        lexicon: 1,
        id: "com.atproto.server.deleteAccount",
        defs: {
          main: {
            type: "procedure",
            description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "password", "token"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  password: {
                    type: "string"
                  },
                  token: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              }
            ]
          }
        }
      },
      ComAtprotoServerDeleteSession: {
        lexicon: 1,
        id: "com.atproto.server.deleteSession",
        defs: {
          main: {
            type: "procedure",
            description: "Delete the current session. Requires auth."
          }
        }
      },
      ComAtprotoServerDescribeServer: {
        lexicon: 1,
        id: "com.atproto.server.describeServer",
        defs: {
          main: {
            type: "query",
            description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "availableUserDomains"],
                properties: {
                  inviteCodeRequired: {
                    type: "boolean",
                    description: "If true, an invite code must be supplied to create an account on this instance."
                  },
                  phoneVerificationRequired: {
                    type: "boolean",
                    description: "If true, a phone verification token must be supplied to create an account on this instance."
                  },
                  availableUserDomains: {
                    type: "array",
                    description: "List of domain suffixes that can be used in account handles.",
                    items: {
                      type: "string"
                    }
                  },
                  links: {
                    type: "ref",
                    description: "URLs of service policy documents.",
                    ref: "lex:com.atproto.server.describeServer#links"
                  },
                  contact: {
                    type: "ref",
                    description: "Contact information",
                    ref: "lex:com.atproto.server.describeServer#contact"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          },
          links: {
            type: "object",
            properties: {
              privacyPolicy: {
                type: "string",
                format: "uri"
              },
              termsOfService: {
                type: "string",
                format: "uri"
              }
            }
          },
          contact: {
            type: "object",
            properties: {
              email: {
                type: "string"
              }
            }
          }
        }
      },
      ComAtprotoServerGetAccountInviteCodes: {
        lexicon: 1,
        id: "com.atproto.server.getAccountInviteCodes",
        defs: {
          main: {
            type: "query",
            description: "Get all invite codes for the current account. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                includeUsed: {
                  type: "boolean",
                  default: !0
                },
                createAvailable: {
                  type: "boolean",
                  default: !0,
                  description: "Controls whether any new 'earned' but not 'created' invites should be created."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["codes"],
                properties: {
                  codes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.defs#inviteCode"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "DuplicateCreate"
              }
            ]
          }
        }
      },
      ComAtprotoServerGetServiceAuth: {
        lexicon: 1,
        id: "com.atproto.server.getServiceAuth",
        defs: {
          main: {
            type: "query",
            description: "Get a signed token on behalf of the requesting DID for the requested service.",
            parameters: {
              type: "params",
              required: ["aud"],
              properties: {
                aud: {
                  type: "string",
                  format: "did",
                  description: "The DID of the service that the token will be used to authenticate with"
                },
                exp: {
                  type: "integer",
                  description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
                },
                lxm: {
                  type: "string",
                  format: "nsid",
                  description: "Lexicon (XRPC) method to bind the requested token to"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["token"],
                properties: {
                  token: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "BadExpiration",
                description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
              }
            ]
          }
        }
      },
      ComAtprotoServerGetSession: {
        lexicon: 1,
        id: "com.atproto.server.getSession",
        defs: {
          main: {
            type: "query",
            description: "Get information about the current auth session. Requires auth.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle", "did"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  email: {
                    type: "string"
                  },
                  emailConfirmed: {
                    type: "boolean"
                  },
                  emailAuthFactor: {
                    type: "boolean"
                  },
                  didDoc: {
                    type: "unknown"
                  },
                  active: {
                    type: "boolean"
                  },
                  status: {
                    type: "string",
                    description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                    knownValues: ["takendown", "suspended", "deactivated"]
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerListAppPasswords: {
        lexicon: 1,
        id: "com.atproto.server.listAppPasswords",
        defs: {
          main: {
            type: "query",
            description: "List all App Passwords.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["passwords"],
                properties: {
                  passwords: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          },
          appPassword: {
            type: "object",
            required: ["name", "createdAt"],
            properties: {
              name: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              privileged: {
                type: "boolean"
              }
            }
          }
        }
      },
      ComAtprotoServerRefreshSession: {
        lexicon: 1,
        id: "com.atproto.server.refreshSession",
        defs: {
          main: {
            type: "procedure",
            description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accessJwt", "refreshJwt", "handle", "did"],
                properties: {
                  accessJwt: {
                    type: "string"
                  },
                  refreshJwt: {
                    type: "string"
                  },
                  handle: {
                    type: "string",
                    format: "handle"
                  },
                  did: {
                    type: "string",
                    format: "did"
                  },
                  didDoc: {
                    type: "unknown"
                  },
                  active: {
                    type: "boolean"
                  },
                  status: {
                    type: "string",
                    description: "Hosting status of the account. If not specified, then assume 'active'.",
                    knownValues: ["takendown", "suspended", "deactivated"]
                  }
                }
              }
            },
            errors: [
              {
                name: "AccountTakedown"
              }
            ]
          }
        }
      },
      ComAtprotoServerRequestAccountDelete: {
        lexicon: 1,
        id: "com.atproto.server.requestAccountDelete",
        defs: {
          main: {
            type: "procedure",
            description: "Initiate a user account deletion via email."
          }
        }
      },
      ComAtprotoServerRequestEmailConfirmation: {
        lexicon: 1,
        id: "com.atproto.server.requestEmailConfirmation",
        defs: {
          main: {
            type: "procedure",
            description: "Request an email with a code to confirm ownership of email."
          }
        }
      },
      ComAtprotoServerRequestEmailUpdate: {
        lexicon: 1,
        id: "com.atproto.server.requestEmailUpdate",
        defs: {
          main: {
            type: "procedure",
            description: "Request a token in order to update email.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["tokenRequired"],
                properties: {
                  tokenRequired: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerRequestPasswordReset: {
        lexicon: 1,
        id: "com.atproto.server.requestPasswordReset",
        defs: {
          main: {
            type: "procedure",
            description: "Initiate a user account password reset via email.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["email"],
                properties: {
                  email: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerReserveSigningKey: {
        lexicon: 1,
        id: "com.atproto.server.reserveSigningKey",
        defs: {
          main: {
            type: "procedure",
            description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID to reserve a key for."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["signingKey"],
                properties: {
                  signingKey: {
                    type: "string",
                    description: "The public key for the reserved signing key, in did:key serialization."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerResetPassword: {
        lexicon: 1,
        id: "com.atproto.server.resetPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Reset a user account password using a token.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["token", "password"],
                properties: {
                  token: {
                    type: "string"
                  },
                  password: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              }
            ]
          }
        }
      },
      ComAtprotoServerRevokeAppPassword: {
        lexicon: 1,
        id: "com.atproto.server.revokeAppPassword",
        defs: {
          main: {
            type: "procedure",
            description: "Revoke an App Password by name.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoServerUpdateEmail: {
        lexicon: 1,
        id: "com.atproto.server.updateEmail",
        defs: {
          main: {
            type: "procedure",
            description: "Update an account's email.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["email"],
                properties: {
                  email: {
                    type: "string"
                  },
                  emailAuthFactor: {
                    type: "boolean"
                  },
                  token: {
                    type: "string",
                    description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                  }
                }
              }
            },
            errors: [
              {
                name: "ExpiredToken"
              },
              {
                name: "InvalidToken"
              },
              {
                name: "TokenRequired"
              }
            ]
          }
        }
      },
      ComAtprotoSyncDefs: {
        lexicon: 1,
        id: "com.atproto.sync.defs",
        defs: {
          hostStatus: {
            type: "string",
            knownValues: ["active", "idle", "offline", "throttled", "banned"]
          }
        }
      },
      ComAtprotoSyncGetBlob: {
        lexicon: 1,
        id: "com.atproto.sync.getBlob",
        defs: {
          main: {
            type: "query",
            description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
            parameters: {
              type: "params",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the account."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "The CID of the blob to fetch"
                }
              }
            },
            output: {
              encoding: "*/*"
            },
            errors: [
              {
                name: "BlobNotFound"
              },
              {
                name: "RepoNotFound"
              },
              {
                name: "RepoTakendown"
              },
              {
                name: "RepoSuspended"
              },
              {
                name: "RepoDeactivated"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetBlocks: {
        lexicon: 1,
        id: "com.atproto.sync.getBlocks",
        defs: {
          main: {
            type: "query",
            description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
            parameters: {
              type: "params",
              required: ["did", "cids"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            },
            errors: [
              {
                name: "BlockNotFound"
              },
              {
                name: "RepoNotFound"
              },
              {
                name: "RepoTakendown"
              },
              {
                name: "RepoSuspended"
              },
              {
                name: "RepoDeactivated"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetCheckout: {
        lexicon: 1,
        id: "com.atproto.sync.getCheckout",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            }
          }
        }
      },
      ComAtprotoSyncGetHead: {
        lexicon: 1,
        id: "com.atproto.sync.getHead",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["root"],
                properties: {
                  root: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            },
            errors: [
              {
                name: "HeadNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetHostStatus: {
        lexicon: 1,
        id: "com.atproto.sync.getHostStatus",
        defs: {
          main: {
            type: "query",
            description: "Returns information about a specified upstream host, as consumed by the server. Implemented by relays.",
            parameters: {
              type: "params",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the host (eg, PDS or relay) being queried."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["hostname"],
                properties: {
                  hostname: {
                    type: "string"
                  },
                  seq: {
                    type: "integer",
                    description: "Recent repo stream event sequence number. May be delayed from actual stream processing (eg, persisted cursor not in-memory cursor)."
                  },
                  accountCount: {
                    type: "integer",
                    description: "Number of accounts on the server which are associated with the upstream host. Note that the upstream may actually have more accounts."
                  },
                  status: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.defs#hostStatus"
                  }
                }
              }
            },
            errors: [
              {
                name: "HostNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetLatestCommit: {
        lexicon: 1,
        id: "com.atproto.sync.getLatestCommit",
        defs: {
          main: {
            type: "query",
            description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["cid", "rev"],
                properties: {
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  rev: {
                    type: "string",
                    format: "tid"
                  }
                }
              }
            },
            errors: [
              {
                name: "RepoNotFound"
              },
              {
                name: "RepoTakendown"
              },
              {
                name: "RepoSuspended"
              },
              {
                name: "RepoDeactivated"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetRecord: {
        lexicon: 1,
        id: "com.atproto.sync.getRecord",
        defs: {
          main: {
            type: "query",
            description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
            parameters: {
              type: "params",
              required: ["did", "collection", "rkey"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string",
                  description: "Record Key",
                  format: "record-key"
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            },
            errors: [
              {
                name: "RecordNotFound"
              },
              {
                name: "RepoNotFound"
              },
              {
                name: "RepoTakendown"
              },
              {
                name: "RepoSuspended"
              },
              {
                name: "RepoDeactivated"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetRepo: {
        lexicon: 1,
        id: "com.atproto.sync.getRepo",
        defs: {
          main: {
            type: "query",
            description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                since: {
                  type: "string",
                  format: "tid",
                  description: "The revision ('rev') of the repo to create a diff from."
                }
              }
            },
            output: {
              encoding: "application/vnd.ipld.car"
            },
            errors: [
              {
                name: "RepoNotFound"
              },
              {
                name: "RepoTakendown"
              },
              {
                name: "RepoSuspended"
              },
              {
                name: "RepoDeactivated"
              }
            ]
          }
        }
      },
      ComAtprotoSyncGetRepoStatus: {
        lexicon: 1,
        id: "com.atproto.sync.getRepoStatus",
        defs: {
          main: {
            type: "query",
            description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "active"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  active: {
                    type: "boolean"
                  },
                  status: {
                    type: "string",
                    description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                    knownValues: [
                      "takendown",
                      "suspended",
                      "deleted",
                      "deactivated",
                      "desynchronized",
                      "throttled"
                    ]
                  },
                  rev: {
                    type: "string",
                    format: "tid",
                    description: "Optional field, the current rev of the repo, if active=true"
                  }
                }
              }
            },
            errors: [
              {
                name: "RepoNotFound"
              }
            ]
          }
        }
      },
      ComAtprotoSyncListBlobs: {
        lexicon: 1,
        id: "com.atproto.sync.listBlobs",
        defs: {
          main: {
            type: "query",
            description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the repo."
                },
                since: {
                  type: "string",
                  format: "tid",
                  description: "Optional revision of the repo to list blobs since."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 500
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["cids"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "RepoNotFound"
              },
              {
                name: "RepoTakendown"
              },
              {
                name: "RepoSuspended"
              },
              {
                name: "RepoDeactivated"
              }
            ]
          }
        }
      },
      ComAtprotoSyncListHosts: {
        lexicon: 1,
        id: "com.atproto.sync.listHosts",
        defs: {
          main: {
            type: "query",
            description: "Enumerates upstream hosts (eg, PDS or relay instances) that this service consumes from. Implemented by relays.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 200
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["hosts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hosts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.sync.listHosts#host"
                    },
                    description: "Sort order is not formally specified. Recommended order is by time host was first seen by the server, with oldest first."
                  }
                }
              }
            }
          },
          host: {
            type: "object",
            required: ["hostname"],
            properties: {
              hostname: {
                type: "string",
                description: "hostname of server; not a URL (no scheme)"
              },
              seq: {
                type: "integer",
                description: "Recent repo stream event sequence number. May be delayed from actual stream processing (eg, persisted cursor not in-memory cursor)."
              },
              accountCount: {
                type: "integer"
              },
              status: {
                type: "ref",
                ref: "lex:com.atproto.sync.defs#hostStatus"
              }
            }
          }
        }
      },
      ComAtprotoSyncListRepos: {
        lexicon: 1,
        id: "com.atproto.sync.listRepos",
        defs: {
          main: {
            type: "query",
            description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 500
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repos"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  repos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.sync.listRepos#repo"
                    }
                  }
                }
              }
            }
          },
          repo: {
            type: "object",
            required: ["did", "head", "rev"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              head: {
                type: "string",
                format: "cid",
                description: "Current repo commit CID"
              },
              rev: {
                type: "string",
                format: "tid"
              },
              active: {
                type: "boolean"
              },
              status: {
                type: "string",
                description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                knownValues: [
                  "takendown",
                  "suspended",
                  "deleted",
                  "deactivated",
                  "desynchronized",
                  "throttled"
                ]
              }
            }
          }
        }
      },
      ComAtprotoSyncListReposByCollection: {
        lexicon: 1,
        id: "com.atproto.sync.listReposByCollection",
        defs: {
          main: {
            type: "query",
            description: "Enumerates all the DIDs which have records with the given collection NSID.",
            parameters: {
              type: "params",
              required: ["collection"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                limit: {
                  type: "integer",
                  description: "Maximum size of response set. Recommend setting a large maximum (1000+) when enumerating large DID lists.",
                  minimum: 1,
                  maximum: 2e3,
                  default: 500
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repos"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  repos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.sync.listReposByCollection#repo"
                    }
                  }
                }
              }
            }
          },
          repo: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          }
        }
      },
      ComAtprotoSyncNotifyOfUpdate: {
        lexicon: 1,
        id: "com.atproto.sync.notifyOfUpdate",
        defs: {
          main: {
            type: "procedure",
            description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay. DEPRECATED: just use com.atproto.sync.requestCrawl",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["hostname"],
                properties: {
                  hostname: {
                    type: "string",
                    description: "Hostname of the current service (usually a PDS) that is notifying of update."
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoSyncRequestCrawl: {
        lexicon: 1,
        id: "com.atproto.sync.requestCrawl",
        defs: {
          main: {
            type: "procedure",
            description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["hostname"],
                properties: {
                  hostname: {
                    type: "string",
                    description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                  }
                }
              }
            },
            errors: [
              {
                name: "HostBanned"
              }
            ]
          }
        }
      },
      ComAtprotoSyncSubscribeRepos: {
        lexicon: 1,
        id: "com.atproto.sync.subscribeRepos",
        defs: {
          main: {
            type: "subscription",
            description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
            parameters: {
              type: "params",
              properties: {
                cursor: {
                  type: "integer",
                  description: "The last known event seq number to backfill from."
                }
              }
            },
            message: {
              schema: {
                type: "union",
                refs: [
                  "lex:com.atproto.sync.subscribeRepos#commit",
                  "lex:com.atproto.sync.subscribeRepos#sync",
                  "lex:com.atproto.sync.subscribeRepos#identity",
                  "lex:com.atproto.sync.subscribeRepos#account",
                  "lex:com.atproto.sync.subscribeRepos#info"
                ]
              }
            },
            errors: [
              {
                name: "FutureCursor"
              },
              {
                name: "ConsumerTooSlow",
                description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
              }
            ]
          },
          commit: {
            type: "object",
            description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
            required: [
              "seq",
              "rebase",
              "tooBig",
              "repo",
              "commit",
              "rev",
              "since",
              "blocks",
              "ops",
              "blobs",
              "time"
            ],
            nullable: ["since"],
            properties: {
              seq: {
                type: "integer",
                description: "The stream sequence number of this message."
              },
              rebase: {
                type: "boolean",
                description: "DEPRECATED -- unused"
              },
              tooBig: {
                type: "boolean",
                description: "DEPRECATED -- replaced by #sync event and data limits. Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
              },
              repo: {
                type: "string",
                format: "did",
                description: "The repo this event comes from. Note that all other message types name this field 'did'."
              },
              commit: {
                type: "cid-link",
                description: "Repo commit object CID."
              },
              rev: {
                type: "string",
                format: "tid",
                description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
              },
              since: {
                type: "string",
                format: "tid",
                description: "The rev of the last emitted commit from this repo (if any)."
              },
              blocks: {
                type: "bytes",
                description: "CAR file containing relevant blocks, as a diff since the previous repo state. The commit must be included as a block, and the commit block CID must be the first entry in the CAR header 'roots' list.",
                maxLength: 2e6
              },
              ops: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                  description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
                },
                maxLength: 200
              },
              blobs: {
                type: "array",
                items: {
                  type: "cid-link",
                  description: "DEPRECATED -- will soon always be empty. List of new blobs (by CID) referenced by records in this commit."
                }
              },
              prevData: {
                type: "cid-link",
                description: "The root CID of the MST tree for the previous commit from this repo (indicated by the 'since' revision field in this message). Corresponds to the 'data' field in the repo commit object. NOTE: this field is effectively required for the 'inductive' version of firehose."
              },
              time: {
                type: "string",
                format: "datetime",
                description: "Timestamp of when this message was originally broadcast."
              }
            }
          },
          sync: {
            type: "object",
            description: "Updates the repo to a new state, without necessarily including that state on the firehose. Used to recover from broken commit streams, data loss incidents, or in situations where upstream host does not know recent state of the repository.",
            required: ["seq", "did", "blocks", "rev", "time"],
            properties: {
              seq: {
                type: "integer",
                description: "The stream sequence number of this message."
              },
              did: {
                type: "string",
                format: "did",
                description: "The account this repo event corresponds to. Must match that in the commit object."
              },
              blocks: {
                type: "bytes",
                description: "CAR file containing the commit, as a block. The CAR header must include the commit block CID as the first 'root'.",
                maxLength: 1e4
              },
              rev: {
                type: "string",
                description: "The rev of the commit. This value must match that in the commit object."
              },
              time: {
                type: "string",
                format: "datetime",
                description: "Timestamp of when this message was originally broadcast."
              }
            }
          },
          identity: {
            type: "object",
            description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
            required: ["seq", "did", "time"],
            properties: {
              seq: {
                type: "integer"
              },
              did: {
                type: "string",
                format: "did"
              },
              time: {
                type: "string",
                format: "datetime"
              },
              handle: {
                type: "string",
                format: "handle",
                description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
              }
            }
          },
          account: {
            type: "object",
            description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
            required: ["seq", "did", "time", "active"],
            properties: {
              seq: {
                type: "integer"
              },
              did: {
                type: "string",
                format: "did"
              },
              time: {
                type: "string",
                format: "datetime"
              },
              active: {
                type: "boolean",
                description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
              },
              status: {
                type: "string",
                description: "If active=false, this optional field indicates a reason for why the account is not active.",
                knownValues: [
                  "takendown",
                  "suspended",
                  "deleted",
                  "deactivated",
                  "desynchronized",
                  "throttled"
                ]
              }
            }
          },
          info: {
            type: "object",
            required: ["name"],
            properties: {
              name: {
                type: "string",
                knownValues: ["OutdatedCursor"]
              },
              message: {
                type: "string"
              }
            }
          },
          repoOp: {
            type: "object",
            description: "A repo operation, ie a mutation of a single record.",
            required: ["action", "path", "cid"],
            nullable: ["cid"],
            properties: {
              action: {
                type: "string",
                knownValues: ["create", "update", "delete"]
              },
              path: {
                type: "string"
              },
              cid: {
                type: "cid-link",
                description: "For creates and updates, the new record CID. For deletions, null."
              },
              prev: {
                type: "cid-link",
                description: "For updates and deletes, the previous record CID (required for inductive firehose). For creations, field should not be defined."
              }
            }
          }
        }
      },
      ComAtprotoTempAddReservedHandle: {
        lexicon: 1,
        id: "com.atproto.temp.addReservedHandle",
        defs: {
          main: {
            type: "procedure",
            description: "Add a handle to the set of reserved handles.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {}
              }
            }
          }
        }
      },
      ComAtprotoTempCheckSignupQueue: {
        lexicon: 1,
        id: "com.atproto.temp.checkSignupQueue",
        defs: {
          main: {
            type: "query",
            description: "Check accounts location in signup queue.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["activated"],
                properties: {
                  activated: {
                    type: "boolean"
                  },
                  placeInQueue: {
                    type: "integer"
                  },
                  estimatedTimeMs: {
                    type: "integer"
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoTempFetchLabels: {
        lexicon: 1,
        id: "com.atproto.temp.fetchLabels",
        defs: {
          main: {
            type: "query",
            description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
            parameters: {
              type: "params",
              properties: {
                since: {
                  type: "integer"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 250,
                  default: 50
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["labels"],
                properties: {
                  labels: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.label.defs#label"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ComAtprotoTempRequestPhoneVerification: {
        lexicon: 1,
        id: "com.atproto.temp.requestPhoneVerification",
        defs: {
          main: {
            type: "procedure",
            description: "Request a verification code to be sent to the supplied phone number",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["phoneNumber"],
                properties: {
                  phoneNumber: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorDefs: {
        lexicon: 1,
        id: "app.bsky.actor.defs",
        defs: {
          profileViewBasic: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              associated: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileAssociated"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              verification: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#verificationState"
              }
            }
          },
          profileView: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              associated: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileAssociated"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              verification: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#verificationState"
              }
            }
          },
          profileViewDetailed: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              banner: {
                type: "string",
                format: "uri"
              },
              followersCount: {
                type: "integer"
              },
              followsCount: {
                type: "integer"
              },
              postsCount: {
                type: "integer"
              },
              associated: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileAssociated"
              },
              joinedViaStarterPack: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              pinnedPost: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              verification: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#verificationState"
              }
            }
          },
          profileAssociated: {
            type: "object",
            properties: {
              lists: {
                type: "integer"
              },
              feedgens: {
                type: "integer"
              },
              starterPacks: {
                type: "integer"
              },
              labeler: {
                type: "boolean"
              },
              chat: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
              }
            }
          },
          profileAssociatedChat: {
            type: "object",
            required: ["allowIncoming"],
            properties: {
              allowIncoming: {
                type: "string",
                knownValues: ["all", "none", "following"]
              }
            }
          },
          viewerState: {
            type: "object",
            description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
            properties: {
              muted: {
                type: "boolean"
              },
              mutedByList: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              },
              blockedBy: {
                type: "boolean"
              },
              blocking: {
                type: "string",
                format: "at-uri"
              },
              blockingByList: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              },
              following: {
                type: "string",
                format: "at-uri"
              },
              followedBy: {
                type: "string",
                format: "at-uri"
              },
              knownFollowers: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#knownFollowers"
              }
            }
          },
          knownFollowers: {
            type: "object",
            description: "The subject's followers whom you also follow",
            required: ["count", "followers"],
            properties: {
              count: {
                type: "integer"
              },
              followers: {
                type: "array",
                minLength: 0,
                maxLength: 5,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                }
              }
            }
          },
          verificationState: {
            type: "object",
            description: "Represents the verification information about the user this object is attached to.",
            required: ["verifications", "verifiedStatus", "trustedVerifierStatus"],
            properties: {
              verifications: {
                type: "array",
                description: "All verifications issued by trusted verifiers on behalf of this user. Verifications by untrusted verifiers are not included.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#verificationView"
                }
              },
              verifiedStatus: {
                type: "string",
                description: "The user's status as a verified account.",
                knownValues: ["valid", "invalid", "none"]
              },
              trustedVerifierStatus: {
                type: "string",
                description: "The user's status as a trusted verifier.",
                knownValues: ["valid", "invalid", "none"]
              }
            }
          },
          verificationView: {
            type: "object",
            description: "An individual verification for an associated subject.",
            required: ["issuer", "uri", "isValid", "createdAt"],
            properties: {
              issuer: {
                type: "string",
                description: "The user who issued this verification.",
                format: "did"
              },
              uri: {
                type: "string",
                description: "The AT-URI of the verification record.",
                format: "at-uri"
              },
              isValid: {
                type: "boolean",
                description: "True if the verification passes validation, otherwise false."
              },
              createdAt: {
                type: "string",
                description: "Timestamp when the verification was created.",
                format: "datetime"
              }
            }
          },
          preferences: {
            type: "array",
            items: {
              type: "union",
              refs: [
                "lex:app.bsky.actor.defs#adultContentPref",
                "lex:app.bsky.actor.defs#contentLabelPref",
                "lex:app.bsky.actor.defs#savedFeedsPref",
                "lex:app.bsky.actor.defs#savedFeedsPrefV2",
                "lex:app.bsky.actor.defs#personalDetailsPref",
                "lex:app.bsky.actor.defs#feedViewPref",
                "lex:app.bsky.actor.defs#threadViewPref",
                "lex:app.bsky.actor.defs#interestsPref",
                "lex:app.bsky.actor.defs#mutedWordsPref",
                "lex:app.bsky.actor.defs#hiddenPostsPref",
                "lex:app.bsky.actor.defs#bskyAppStatePref",
                "lex:app.bsky.actor.defs#labelersPref",
                "lex:app.bsky.actor.defs#postInteractionSettingsPref",
                "lex:app.bsky.actor.defs#verificationPrefs"
              ]
            }
          },
          adultContentPref: {
            type: "object",
            required: ["enabled"],
            properties: {
              enabled: {
                type: "boolean",
                default: !1
              }
            }
          },
          contentLabelPref: {
            type: "object",
            required: ["label", "visibility"],
            properties: {
              labelerDid: {
                type: "string",
                description: "Which labeler does this preference apply to? If undefined, applies globally.",
                format: "did"
              },
              label: {
                type: "string"
              },
              visibility: {
                type: "string",
                knownValues: ["ignore", "show", "warn", "hide"]
              }
            }
          },
          savedFeed: {
            type: "object",
            required: ["id", "type", "value", "pinned"],
            properties: {
              id: {
                type: "string"
              },
              type: {
                type: "string",
                knownValues: ["feed", "list", "timeline"]
              },
              value: {
                type: "string"
              },
              pinned: {
                type: "boolean"
              }
            }
          },
          savedFeedsPrefV2: {
            type: "object",
            required: ["items"],
            properties: {
              items: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#savedFeed"
                }
              }
            }
          },
          savedFeedsPref: {
            type: "object",
            required: ["pinned", "saved"],
            properties: {
              pinned: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              },
              saved: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              },
              timelineIndex: {
                type: "integer"
              }
            }
          },
          personalDetailsPref: {
            type: "object",
            properties: {
              birthDate: {
                type: "string",
                format: "datetime",
                description: "The birth date of account owner."
              }
            }
          },
          feedViewPref: {
            type: "object",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                description: "The URI of the feed, or an identifier which describes the feed."
              },
              hideReplies: {
                type: "boolean",
                description: "Hide replies in the feed."
              },
              hideRepliesByUnfollowed: {
                type: "boolean",
                description: "Hide replies in the feed if they are not by followed users.",
                default: !0
              },
              hideRepliesByLikeCount: {
                type: "integer",
                description: "Hide replies in the feed if they do not have this number of likes."
              },
              hideReposts: {
                type: "boolean",
                description: "Hide reposts in the feed."
              },
              hideQuotePosts: {
                type: "boolean",
                description: "Hide quote posts in the feed."
              }
            }
          },
          threadViewPref: {
            type: "object",
            properties: {
              sort: {
                type: "string",
                description: "Sorting mode for threads.",
                knownValues: [
                  "oldest",
                  "newest",
                  "most-likes",
                  "random",
                  "hotness"
                ]
              },
              prioritizeFollowedUsers: {
                type: "boolean",
                description: "Show followed users at the top of all replies."
              }
            }
          },
          interestsPref: {
            type: "object",
            required: ["tags"],
            properties: {
              tags: {
                type: "array",
                maxLength: 100,
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "A list of tags which describe the account owner's interests gathered during onboarding."
              }
            }
          },
          mutedWordTarget: {
            type: "string",
            knownValues: ["content", "tag"],
            maxLength: 640,
            maxGraphemes: 64
          },
          mutedWord: {
            type: "object",
            description: "A word that the account owner has muted.",
            required: ["value", "targets"],
            properties: {
              id: {
                type: "string"
              },
              value: {
                type: "string",
                description: "The muted word itself.",
                maxLength: 1e4,
                maxGraphemes: 1e3
              },
              targets: {
                type: "array",
                description: "The intended targets of the muted word.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#mutedWordTarget"
                }
              },
              actorTarget: {
                type: "string",
                description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
                knownValues: ["all", "exclude-following"],
                default: "all"
              },
              expiresAt: {
                type: "string",
                format: "datetime",
                description: "The date and time at which the muted word will expire and no longer be applied."
              }
            }
          },
          mutedWordsPref: {
            type: "object",
            required: ["items"],
            properties: {
              items: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#mutedWord"
                },
                description: "A list of words the account owner has muted."
              }
            }
          },
          hiddenPostsPref: {
            type: "object",
            required: ["items"],
            properties: {
              items: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                description: "A list of URIs of posts the account owner has hidden."
              }
            }
          },
          labelersPref: {
            type: "object",
            required: ["labelers"],
            properties: {
              labelers: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#labelerPrefItem"
                }
              }
            }
          },
          labelerPrefItem: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          bskyAppStatePref: {
            description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
            type: "object",
            properties: {
              activeProgressGuide: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
              },
              queuedNudges: {
                description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
                type: "array",
                maxLength: 1e3,
                items: {
                  type: "string",
                  maxLength: 100
                }
              },
              nuxs: {
                description: "Storage for NUXs the user has encountered.",
                type: "array",
                maxLength: 100,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#nux"
                }
              }
            }
          },
          bskyAppProgressGuide: {
            description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
            type: "object",
            required: ["guide"],
            properties: {
              guide: {
                type: "string",
                maxLength: 100
              }
            }
          },
          nux: {
            type: "object",
            description: "A new user experiences (NUX) storage object",
            required: ["id", "completed"],
            properties: {
              id: {
                type: "string",
                maxLength: 100
              },
              completed: {
                type: "boolean",
                default: !1
              },
              data: {
                description: "Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.",
                type: "string",
                maxLength: 3e3,
                maxGraphemes: 300
              },
              expiresAt: {
                type: "string",
                format: "datetime",
                description: "The date and time at which the NUX will expire and should be considered completed."
              }
            }
          },
          verificationPrefs: {
            type: "object",
            description: "Preferences for how verified accounts appear in the app.",
            required: [],
            properties: {
              hideBadges: {
                description: "Hide the blue check badges for verified accounts and trusted verifiers.",
                type: "boolean",
                default: !1
              }
            }
          },
          postInteractionSettingsPref: {
            type: "object",
            description: "Default post interaction settings for the account. These values should be applied as default values when creating new posts. These refs should mirror the threadgate and postgate records exactly.",
            required: [],
            properties: {
              threadgateAllowRules: {
                description: "Matches threadgate record. List of rules defining who can reply to this users posts. If value is an empty array, no one can reply. If value is undefined, anyone can reply.",
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.threadgate#mentionRule",
                    "lex:app.bsky.feed.threadgate#followerRule",
                    "lex:app.bsky.feed.threadgate#followingRule",
                    "lex:app.bsky.feed.threadgate#listRule"
                  ]
                }
              },
              postgateEmbeddingRules: {
                description: "Matches postgate record. List of rules defining who can embed this users posts. If value is an empty array or is undefined, no particular rules apply and anyone can embed.",
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: ["lex:app.bsky.feed.postgate#disableRule"]
                }
              }
            }
          }
        }
      },
      AppBskyActorGetPreferences: {
        lexicon: 1,
        id: "app.bsky.actor.getPreferences",
        defs: {
          main: {
            type: "query",
            description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
            parameters: {
              type: "params",
              properties: {}
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["preferences"],
                properties: {
                  preferences: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#preferences"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorGetProfile: {
        lexicon: 1,
        id: "app.bsky.actor.getProfile",
        defs: {
          main: {
            type: "query",
            description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier",
                  description: "Handle or DID of account to fetch profile of."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewDetailed"
              }
            }
          }
        }
      },
      AppBskyActorGetProfiles: {
        lexicon: 1,
        id: "app.bsky.actor.getProfiles",
        defs: {
          main: {
            type: "query",
            description: "Get detailed profile views of multiple actors.",
            parameters: {
              type: "params",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-identifier"
                  },
                  maxLength: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["profiles"],
                properties: {
                  profiles: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorGetSuggestions: {
        lexicon: 1,
        id: "app.bsky.actor.getSuggestions",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  },
                  recId: {
                    type: "integer",
                    description: "Snowflake for this recommendation, use when submitting recommendation events."
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorProfile: {
        lexicon: 1,
        id: "app.bsky.actor.profile",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a Bluesky account profile.",
            key: "literal:self",
            record: {
              type: "object",
              properties: {
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  description: "Free-form profile description text.",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "blob",
                  description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                banner: {
                  type: "blob",
                  description: "Larger horizontal image to display behind profile view.",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                labels: {
                  type: "union",
                  description: "Self-label values, specific to the Bluesky application, on the overall account.",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                joinedViaStarterPack: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                pinnedPost: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyActorPutPreferences: {
        lexicon: 1,
        id: "app.bsky.actor.putPreferences",
        defs: {
          main: {
            type: "procedure",
            description: "Set the private preferences attached to the account.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["preferences"],
                properties: {
                  preferences: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#preferences"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorSearchActors: {
        lexicon: 1,
        id: "app.bsky.actor.searchActors",
        defs: {
          main: {
            type: "query",
            description: "Find actors (profiles) matching search criteria. Does not require auth.",
            parameters: {
              type: "params",
              properties: {
                term: {
                  type: "string",
                  description: "DEPRECATED: use 'q' instead."
                },
                q: {
                  type: "string",
                  description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyActorSearchActorsTypeahead: {
        lexicon: 1,
        id: "app.bsky.actor.searchActorsTypeahead",
        defs: {
          main: {
            type: "query",
            description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
            parameters: {
              type: "params",
              properties: {
                term: {
                  type: "string",
                  description: "DEPRECATED: use 'q' instead."
                },
                q: {
                  type: "string",
                  description: "Search query prefix; not a full query string."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileViewBasic"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyEmbedDefs: {
        lexicon: 1,
        id: "app.bsky.embed.defs",
        defs: {
          aspectRatio: {
            type: "object",
            description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
            required: ["width", "height"],
            properties: {
              width: {
                type: "integer",
                minimum: 1
              },
              height: {
                type: "integer",
                minimum: 1
              }
            }
          }
        }
      },
      AppBskyEmbedExternal: {
        lexicon: 1,
        id: "app.bsky.embed.external",
        defs: {
          main: {
            type: "object",
            description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
            required: ["external"],
            properties: {
              external: {
                type: "ref",
                ref: "lex:app.bsky.embed.external#external"
              }
            }
          },
          external: {
            type: "object",
            required: ["uri", "title", "description"],
            properties: {
              uri: {
                type: "string",
                format: "uri"
              },
              title: {
                type: "string"
              },
              description: {
                type: "string"
              },
              thumb: {
                type: "blob",
                accept: ["image/*"],
                maxSize: 1e6
              }
            }
          },
          view: {
            type: "object",
            required: ["external"],
            properties: {
              external: {
                type: "ref",
                ref: "lex:app.bsky.embed.external#viewExternal"
              }
            }
          },
          viewExternal: {
            type: "object",
            required: ["uri", "title", "description"],
            properties: {
              uri: {
                type: "string",
                format: "uri"
              },
              title: {
                type: "string"
              },
              description: {
                type: "string"
              },
              thumb: {
                type: "string",
                format: "uri"
              }
            }
          }
        }
      },
      AppBskyEmbedImages: {
        lexicon: 1,
        id: "app.bsky.embed.images",
        description: "A set of images embedded in a Bluesky record (eg, a post).",
        defs: {
          main: {
            type: "object",
            required: ["images"],
            properties: {
              images: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#image"
                },
                maxLength: 4
              }
            }
          },
          image: {
            type: "object",
            required: ["image", "alt"],
            properties: {
              image: {
                type: "blob",
                accept: ["image/*"],
                maxSize: 1e6
              },
              alt: {
                type: "string",
                description: "Alt text description of the image, for accessibility."
              },
              aspectRatio: {
                type: "ref",
                ref: "lex:app.bsky.embed.defs#aspectRatio"
              }
            }
          },
          view: {
            type: "object",
            required: ["images"],
            properties: {
              images: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.images#viewImage"
                },
                maxLength: 4
              }
            }
          },
          viewImage: {
            type: "object",
            required: ["thumb", "fullsize", "alt"],
            properties: {
              thumb: {
                type: "string",
                format: "uri",
                description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
              },
              fullsize: {
                type: "string",
                format: "uri",
                description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
              },
              alt: {
                type: "string",
                description: "Alt text description of the image, for accessibility."
              },
              aspectRatio: {
                type: "ref",
                ref: "lex:app.bsky.embed.defs#aspectRatio"
              }
            }
          }
        }
      },
      AppBskyEmbedRecord: {
        lexicon: 1,
        id: "app.bsky.embed.record",
        description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
        defs: {
          main: {
            type: "object",
            required: ["record"],
            properties: {
              record: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              }
            }
          },
          view: {
            type: "object",
            required: ["record"],
            properties: {
              record: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.record#viewRecord",
                  "lex:app.bsky.embed.record#viewNotFound",
                  "lex:app.bsky.embed.record#viewBlocked",
                  "lex:app.bsky.embed.record#viewDetached",
                  "lex:app.bsky.feed.defs#generatorView",
                  "lex:app.bsky.graph.defs#listView",
                  "lex:app.bsky.labeler.defs#labelerView",
                  "lex:app.bsky.graph.defs#starterPackViewBasic"
                ]
              }
            }
          },
          viewRecord: {
            type: "object",
            required: ["uri", "cid", "author", "value", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              value: {
                type: "unknown",
                description: "The record data itself."
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              replyCount: {
                type: "integer"
              },
              repostCount: {
                type: "integer"
              },
              likeCount: {
                type: "integer"
              },
              quoteCount: {
                type: "integer"
              },
              embeds: {
                type: "array",
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.video#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          viewNotFound: {
            type: "object",
            required: ["uri", "notFound"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              notFound: {
                type: "boolean",
                const: !0
              }
            }
          },
          viewBlocked: {
            type: "object",
            required: ["uri", "blocked", "author"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              blocked: {
                type: "boolean",
                const: !0
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#blockedAuthor"
              }
            }
          },
          viewDetached: {
            type: "object",
            required: ["uri", "detached"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              detached: {
                type: "boolean",
                const: !0
              }
            }
          }
        }
      },
      AppBskyEmbedRecordWithMedia: {
        lexicon: 1,
        id: "app.bsky.embed.recordWithMedia",
        description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
        defs: {
          main: {
            type: "object",
            required: ["record", "media"],
            properties: {
              record: {
                type: "ref",
                ref: "lex:app.bsky.embed.record"
              },
              media: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images",
                  "lex:app.bsky.embed.video",
                  "lex:app.bsky.embed.external"
                ]
              }
            }
          },
          view: {
            type: "object",
            required: ["record", "media"],
            properties: {
              record: {
                type: "ref",
                ref: "lex:app.bsky.embed.record#view"
              },
              media: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.video#view",
                  "lex:app.bsky.embed.external#view"
                ]
              }
            }
          }
        }
      },
      AppBskyEmbedVideo: {
        lexicon: 1,
        id: "app.bsky.embed.video",
        description: "A video embedded in a Bluesky record (eg, a post).",
        defs: {
          main: {
            type: "object",
            required: ["video"],
            properties: {
              video: {
                type: "blob",
                description: "The mp4 video file. May be up to 100mb, formerly limited to 50mb.",
                accept: ["video/mp4"],
                maxSize: 1e8
              },
              captions: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.video#caption"
                },
                maxLength: 20
              },
              alt: {
                type: "string",
                description: "Alt text description of the video, for accessibility.",
                maxGraphemes: 1e3,
                maxLength: 1e4
              },
              aspectRatio: {
                type: "ref",
                ref: "lex:app.bsky.embed.defs#aspectRatio"
              }
            }
          },
          caption: {
            type: "object",
            required: ["lang", "file"],
            properties: {
              lang: {
                type: "string",
                format: "language"
              },
              file: {
                type: "blob",
                accept: ["text/vtt"],
                maxSize: 2e4
              }
            }
          },
          view: {
            type: "object",
            required: ["cid", "playlist"],
            properties: {
              cid: {
                type: "string",
                format: "cid"
              },
              playlist: {
                type: "string",
                format: "uri"
              },
              thumbnail: {
                type: "string",
                format: "uri"
              },
              alt: {
                type: "string",
                maxGraphemes: 1e3,
                maxLength: 1e4
              },
              aspectRatio: {
                type: "ref",
                ref: "lex:app.bsky.embed.defs#aspectRatio"
              }
            }
          }
        }
      },
      AppBskyFeedDefs: {
        lexicon: 1,
        id: "app.bsky.feed.defs",
        defs: {
          postView: {
            type: "object",
            required: ["uri", "cid", "author", "record", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              record: {
                type: "unknown"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.video#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              },
              replyCount: {
                type: "integer"
              },
              repostCount: {
                type: "integer"
              },
              likeCount: {
                type: "integer"
              },
              quoteCount: {
                type: "integer"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              threadgate: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#threadgateView"
              }
            }
          },
          viewerState: {
            type: "object",
            description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
            properties: {
              repost: {
                type: "string",
                format: "at-uri"
              },
              like: {
                type: "string",
                format: "at-uri"
              },
              threadMuted: {
                type: "boolean"
              },
              replyDisabled: {
                type: "boolean"
              },
              embeddingDisabled: {
                type: "boolean"
              },
              pinned: {
                type: "boolean"
              }
            }
          },
          threadContext: {
            type: "object",
            description: "Metadata about this post within the context of the thread it is in.",
            properties: {
              rootAuthorLike: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          feedViewPost: {
            type: "object",
            required: ["post"],
            properties: {
              post: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#postView"
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#replyRef"
              },
              reason: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#reasonRepost",
                  "lex:app.bsky.feed.defs#reasonPin"
                ]
              },
              feedContext: {
                type: "string",
                description: "Context provided by feed generator that may be passed back alongside interactions.",
                maxLength: 2e3
              }
            }
          },
          replyRef: {
            type: "object",
            required: ["root", "parent"],
            properties: {
              root: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#postView",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              },
              parent: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#postView",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              },
              grandparentAuthor: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic",
                description: "When parent is a reply to another post, this is the author of that post."
              }
            }
          },
          reasonRepost: {
            type: "object",
            required: ["by", "indexedAt"],
            properties: {
              by: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          reasonPin: {
            type: "object",
            properties: {}
          },
          threadViewPost: {
            type: "object",
            required: ["post"],
            properties: {
              post: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#postView"
              },
              parent: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              },
              replies: {
                type: "array",
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              },
              threadContext: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#threadContext"
              }
            }
          },
          notFoundPost: {
            type: "object",
            required: ["uri", "notFound"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              notFound: {
                type: "boolean",
                const: !0
              }
            }
          },
          blockedPost: {
            type: "object",
            required: ["uri", "blocked", "author"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              blocked: {
                type: "boolean",
                const: !0
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#blockedAuthor"
              }
            }
          },
          blockedAuthor: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              }
            }
          },
          generatorView: {
            type: "object",
            required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              did: {
                type: "string",
                format: "did"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              displayName: {
                type: "string"
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              likeCount: {
                type: "integer",
                minimum: 0
              },
              acceptsInteractions: {
                type: "boolean"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#generatorViewerState"
              },
              contentMode: {
                type: "string",
                knownValues: [
                  "app.bsky.feed.defs#contentModeUnspecified",
                  "app.bsky.feed.defs#contentModeVideo"
                ]
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          generatorViewerState: {
            type: "object",
            properties: {
              like: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          skeletonFeedPost: {
            type: "object",
            required: ["post"],
            properties: {
              post: {
                type: "string",
                format: "at-uri"
              },
              reason: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#skeletonReasonRepost",
                  "lex:app.bsky.feed.defs#skeletonReasonPin"
                ]
              },
              feedContext: {
                type: "string",
                description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
                maxLength: 2e3
              }
            }
          },
          skeletonReasonRepost: {
            type: "object",
            required: ["repost"],
            properties: {
              repost: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          skeletonReasonPin: {
            type: "object",
            properties: {}
          },
          threadgateView: {
            type: "object",
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              record: {
                type: "unknown"
              },
              lists: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                }
              }
            }
          },
          interaction: {
            type: "object",
            properties: {
              item: {
                type: "string",
                format: "at-uri"
              },
              event: {
                type: "string",
                knownValues: [
                  "app.bsky.feed.defs#requestLess",
                  "app.bsky.feed.defs#requestMore",
                  "app.bsky.feed.defs#clickthroughItem",
                  "app.bsky.feed.defs#clickthroughAuthor",
                  "app.bsky.feed.defs#clickthroughReposter",
                  "app.bsky.feed.defs#clickthroughEmbed",
                  "app.bsky.feed.defs#interactionSeen",
                  "app.bsky.feed.defs#interactionLike",
                  "app.bsky.feed.defs#interactionRepost",
                  "app.bsky.feed.defs#interactionReply",
                  "app.bsky.feed.defs#interactionQuote",
                  "app.bsky.feed.defs#interactionShare"
                ]
              },
              feedContext: {
                type: "string",
                description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
                maxLength: 2e3
              }
            }
          },
          requestLess: {
            type: "token",
            description: "Request that less content like the given feed item be shown in the feed"
          },
          requestMore: {
            type: "token",
            description: "Request that more content like the given feed item be shown in the feed"
          },
          clickthroughItem: {
            type: "token",
            description: "User clicked through to the feed item"
          },
          clickthroughAuthor: {
            type: "token",
            description: "User clicked through to the author of the feed item"
          },
          clickthroughReposter: {
            type: "token",
            description: "User clicked through to the reposter of the feed item"
          },
          clickthroughEmbed: {
            type: "token",
            description: "User clicked through to the embedded content of the feed item"
          },
          contentModeUnspecified: {
            type: "token",
            description: "Declares the feed generator returns any types of posts."
          },
          contentModeVideo: {
            type: "token",
            description: "Declares the feed generator returns posts containing app.bsky.embed.video embeds."
          },
          interactionSeen: {
            type: "token",
            description: "Feed item was seen by user"
          },
          interactionLike: {
            type: "token",
            description: "User liked the feed item"
          },
          interactionRepost: {
            type: "token",
            description: "User reposted the feed item"
          },
          interactionReply: {
            type: "token",
            description: "User replied to the feed item"
          },
          interactionQuote: {
            type: "token",
            description: "User quoted the feed item"
          },
          interactionShare: {
            type: "token",
            description: "User shared the feed item"
          }
        }
      },
      AppBskyFeedDescribeFeedGenerator: {
        lexicon: 1,
        id: "app.bsky.feed.describeFeedGenerator",
        defs: {
          main: {
            type: "query",
            description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "feeds"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                    }
                  },
                  links: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                  }
                }
              }
            }
          },
          feed: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          links: {
            type: "object",
            properties: {
              privacyPolicy: {
                type: "string"
              },
              termsOfService: {
                type: "string"
              }
            }
          }
        }
      },
      AppBskyFeedGenerator: {
        lexicon: 1,
        id: "app.bsky.feed.generator",
        defs: {
          main: {
            type: "record",
            description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
            key: "any",
            record: {
              type: "object",
              required: ["did", "displayName", "createdAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 24,
                  maxLength: 240
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "blob",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                acceptsInteractions: {
                  type: "boolean",
                  description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
                },
                labels: {
                  type: "union",
                  description: "Self-label values",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                contentMode: {
                  type: "string",
                  knownValues: [
                    "app.bsky.feed.defs#contentModeUnspecified",
                    "app.bsky.feed.defs#contentModeVideo"
                  ]
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetActorFeeds: {
        lexicon: 1,
        id: "app.bsky.feed.getActorFeeds",
        defs: {
          main: {
            type: "query",
            description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetActorLikes: {
        lexicon: 1,
        id: "app.bsky.feed.getActorLikes",
        defs: {
          main: {
            type: "query",
            description: "Get a list of posts liked by an actor. Requires auth, actor must be the requesting account.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BlockedActor"
              },
              {
                name: "BlockedByActor"
              }
            ]
          }
        }
      },
      AppBskyFeedGetAuthorFeed: {
        lexicon: 1,
        id: "app.bsky.feed.getAuthorFeed",
        defs: {
          main: {
            type: "query",
            description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                filter: {
                  type: "string",
                  description: "Combinations of post/repost types to include in response.",
                  knownValues: [
                    "posts_with_replies",
                    "posts_no_replies",
                    "posts_with_media",
                    "posts_and_author_threads",
                    "posts_with_video"
                  ],
                  default: "posts_with_replies"
                },
                includePins: {
                  type: "boolean",
                  default: !1
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BlockedActor"
              },
              {
                name: "BlockedByActor"
              }
            ]
          }
        }
      },
      AppBskyFeedGetFeed: {
        lexicon: 1,
        id: "app.bsky.feed.getFeed",
        defs: {
          main: {
            type: "query",
            description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
            parameters: {
              type: "params",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  format: "at-uri"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownFeed"
              }
            ]
          }
        }
      },
      AppBskyFeedGetFeedGenerator: {
        lexicon: 1,
        id: "app.bsky.feed.getFeedGenerator",
        defs: {
          main: {
            type: "query",
            description: "Get information about a feed generator. Implemented by AppView.",
            parameters: {
              type: "params",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  format: "at-uri",
                  description: "AT-URI of the feed generator record."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["view", "isOnline", "isValid"],
                properties: {
                  view: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  },
                  isOnline: {
                    type: "boolean",
                    description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                  },
                  isValid: {
                    type: "boolean",
                    description: "Indicates whether the feed generator service is compatible with the record declaration."
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetFeedGenerators: {
        lexicon: 1,
        id: "app.bsky.feed.getFeedGenerators",
        defs: {
          main: {
            type: "query",
            description: "Get information about a list of feed generators.",
            parameters: {
              type: "params",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetFeedSkeleton: {
        lexicon: 1,
        id: "app.bsky.feed.getFeedSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
            parameters: {
              type: "params",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference to feed generator record describing the specific feed being requested."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownFeed"
              }
            ]
          }
        }
      },
      AppBskyFeedGetLikes: {
        lexicon: 1,
        id: "app.bsky.feed.getLikes",
        defs: {
          main: {
            type: "query",
            description: "Get like records which reference a subject (by AT-URI and CID).",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri",
                  description: "AT-URI of the subject (eg, a post record)."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "CID of the subject record (aka, specific version of record), to filter likes."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "likes"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  cursor: {
                    type: "string"
                  },
                  likes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.getLikes#like"
                    }
                  }
                }
              }
            }
          },
          like: {
            type: "object",
            required: ["indexedAt", "createdAt", "actor"],
            properties: {
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              actor: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              }
            }
          }
        }
      },
      AppBskyFeedGetListFeed: {
        lexicon: 1,
        id: "app.bsky.feed.getListFeed",
        defs: {
          main: {
            type: "query",
            description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
            parameters: {
              type: "params",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to the list record."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "UnknownList"
              }
            ]
          }
        }
      },
      AppBskyFeedGetPostThread: {
        lexicon: 1,
        id: "app.bsky.feed.getPostThread",
        defs: {
          main: {
            type: "query",
            description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to post record."
                },
                depth: {
                  type: "integer",
                  description: "How many levels of reply depth should be included in response.",
                  default: 6,
                  minimum: 0,
                  maximum: 1e3
                },
                parentHeight: {
                  type: "integer",
                  description: "How many levels of parent (and grandparent, etc) post to include.",
                  default: 80,
                  minimum: 0,
                  maximum: 1e3
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["thread"],
                properties: {
                  thread: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  },
                  threadgate: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#threadgateView"
                  }
                }
              }
            },
            errors: [
              {
                name: "NotFound"
              }
            ]
          }
        }
      },
      AppBskyFeedGetPosts: {
        lexicon: 1,
        id: "app.bsky.feed.getPosts",
        defs: {
          main: {
            type: "query",
            description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
            parameters: {
              type: "params",
              required: ["uris"],
              properties: {
                uris: {
                  type: "array",
                  description: "List of post AT-URIs to return hydrated views for.",
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  maxLength: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["posts"],
                properties: {
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#postView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetQuotes: {
        lexicon: 1,
        id: "app.bsky.feed.getQuotes",
        defs: {
          main: {
            type: "query",
            description: "Get a list of quotes for a given post.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) of post record"
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "If supplied, filters to quotes of specific version (by CID) of the post record."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "posts"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  cursor: {
                    type: "string"
                  },
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#postView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetRepostedBy: {
        lexicon: 1,
        id: "app.bsky.feed.getRepostedBy",
        defs: {
          main: {
            type: "query",
            description: "Get a list of reposts for a given post.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) of post record"
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "If supplied, filters to reposts of specific version (by CID) of the post record."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["uri", "repostedBy"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  },
                  cursor: {
                    type: "string"
                  },
                  repostedBy: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetSuggestedFeeds: {
        lexicon: 1,
        id: "app.bsky.feed.getSuggestedFeeds",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested feeds (feed generators) for the requesting account.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedGetTimeline: {
        lexicon: 1,
        id: "app.bsky.feed.getTimeline",
        defs: {
          main: {
            type: "query",
            description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
            parameters: {
              type: "params",
              properties: {
                algorithm: {
                  type: "string",
                  description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feed"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feed: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#feedViewPost"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyFeedLike: {
        lexicon: 1,
        id: "app.bsky.feed.like",
        defs: {
          main: {
            type: "record",
            description: "Record declaring a 'like' of a piece of subject content.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyFeedPost: {
        lexicon: 1,
        id: "app.bsky.feed.post",
        defs: {
          main: {
            type: "record",
            description: "Record containing a Bluesky post.",
            key: "tid",
            record: {
              type: "object",
              required: ["text", "createdAt"],
              properties: {
                text: {
                  type: "string",
                  maxLength: 3e3,
                  maxGraphemes: 300,
                  description: "The primary post content. May be an empty string, if there are embeds."
                },
                entities: {
                  type: "array",
                  description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#entity"
                  }
                },
                facets: {
                  type: "array",
                  description: "Annotations of text (mentions, URLs, hashtags, etc)",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#replyRef"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images",
                    "lex:app.bsky.embed.video",
                    "lex:app.bsky.embed.external",
                    "lex:app.bsky.embed.record",
                    "lex:app.bsky.embed.recordWithMedia"
                  ]
                },
                langs: {
                  type: "array",
                  description: "Indicates human language of post primary text content.",
                  maxLength: 3,
                  items: {
                    type: "string",
                    format: "language"
                  }
                },
                labels: {
                  type: "union",
                  description: "Self-label values for this post. Effectively content warnings.",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                tags: {
                  type: "array",
                  description: "Additional hashtags, in addition to any included in post text and facets.",
                  maxLength: 8,
                  items: {
                    type: "string",
                    maxLength: 640,
                    maxGraphemes: 64
                  }
                },
                createdAt: {
                  type: "string",
                  format: "datetime",
                  description: "Client-declared timestamp when this post was originally created."
                }
              }
            }
          },
          replyRef: {
            type: "object",
            required: ["root", "parent"],
            properties: {
              root: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              parent: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              }
            }
          },
          entity: {
            type: "object",
            description: "Deprecated: use facets instead.",
            required: ["index", "type", "value"],
            properties: {
              index: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#textSlice"
              },
              type: {
                type: "string",
                description: "Expected values are 'mention' and 'link'."
              },
              value: {
                type: "string"
              }
            }
          },
          textSlice: {
            type: "object",
            description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
            required: ["start", "end"],
            properties: {
              start: {
                type: "integer",
                minimum: 0
              },
              end: {
                type: "integer",
                minimum: 0
              }
            }
          }
        }
      },
      AppBskyFeedPostgate: {
        lexicon: 1,
        id: "app.bsky.feed.postgate",
        defs: {
          main: {
            type: "record",
            key: "tid",
            description: "Record defining interaction rules for a post. The record key (rkey) of the postgate record must match the record key of the post, and that record must be in the same repository.",
            record: {
              type: "object",
              required: ["post", "createdAt"],
              properties: {
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                post: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to the post record."
                },
                detachedEmbeddingUris: {
                  type: "array",
                  maxLength: 50,
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  description: "List of AT-URIs embedding this post that the author has detached from."
                },
                embeddingRules: {
                  description: "List of rules defining who can embed this post. If value is an empty array or is undefined, no particular rules apply and anyone can embed.",
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: ["lex:app.bsky.feed.postgate#disableRule"]
                  }
                }
              }
            }
          },
          disableRule: {
            type: "object",
            description: "Disables embedding of this post.",
            properties: {}
          }
        }
      },
      AppBskyFeedRepost: {
        lexicon: 1,
        id: "app.bsky.feed.repost",
        defs: {
          main: {
            description: "Record representing a 'repost' of an existing Bluesky post.",
            type: "record",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyFeedSearchPosts: {
        lexicon: 1,
        id: "app.bsky.feed.searchPosts",
        defs: {
          main: {
            type: "query",
            description: "Find posts matching search criteria, returning views of those posts.",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                sort: {
                  type: "string",
                  knownValues: ["top", "latest"],
                  default: "latest",
                  description: "Specifies the ranking order of results."
                },
                since: {
                  type: "string",
                  description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
                },
                until: {
                  type: "string",
                  description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
                },
                mentions: {
                  type: "string",
                  format: "at-identifier",
                  description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
                },
                author: {
                  type: "string",
                  format: "at-identifier",
                  description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
                },
                lang: {
                  type: "string",
                  format: "language",
                  description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
                },
                domain: {
                  type: "string",
                  description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
                },
                url: {
                  type: "string",
                  format: "uri",
                  description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
                },
                tag: {
                  type: "array",
                  items: {
                    type: "string",
                    maxLength: 640,
                    maxGraphemes: 64
                  },
                  description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["posts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#postView"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      },
      AppBskyFeedSendInteractions: {
        lexicon: 1,
        id: "app.bsky.feed.sendInteractions",
        defs: {
          main: {
            type: "procedure",
            description: "Send information about interactions with feed items back to the feed generator that served them.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["interactions"],
                properties: {
                  interactions: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#interaction"
                    }
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {}
              }
            }
          }
        }
      },
      AppBskyFeedThreadgate: {
        lexicon: 1,
        id: "app.bsky.feed.threadgate",
        defs: {
          main: {
            type: "record",
            key: "tid",
            description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository.",
            record: {
              type: "object",
              required: ["post", "createdAt"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to the post record."
                },
                allow: {
                  description: "List of rules defining who can reply to this post. If value is an empty array, no one can reply. If value is undefined, anyone can reply.",
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.threadgate#mentionRule",
                      "lex:app.bsky.feed.threadgate#followerRule",
                      "lex:app.bsky.feed.threadgate#followingRule",
                      "lex:app.bsky.feed.threadgate#listRule"
                    ]
                  }
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                hiddenReplies: {
                  type: "array",
                  maxLength: 50,
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  description: "List of hidden reply URIs."
                }
              }
            }
          },
          mentionRule: {
            type: "object",
            description: "Allow replies from actors mentioned in your post.",
            properties: {}
          },
          followerRule: {
            type: "object",
            description: "Allow replies from actors who follow you.",
            properties: {}
          },
          followingRule: {
            type: "object",
            description: "Allow replies from actors you follow.",
            properties: {}
          },
          listRule: {
            type: "object",
            description: "Allow replies from actors on a list.",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri"
              }
            }
          }
        }
      },
      AppBskyGraphBlock: {
        lexicon: 1,
        id: "app.bsky.graph.block",
        defs: {
          main: {
            type: "record",
            description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "did",
                  description: "DID of the account to be blocked."
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphDefs: {
        lexicon: 1,
        id: "app.bsky.graph.defs",
        defs: {
          listViewBasic: {
            type: "object",
            required: ["uri", "cid", "name", "purpose"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1
              },
              purpose: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              listItemCount: {
                type: "integer",
                minimum: 0
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          listView: {
            type: "object",
            required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1
              },
              purpose: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              listItemCount: {
                type: "integer",
                minimum: 0
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          listItemView: {
            type: "object",
            required: ["uri", "subject"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              subject: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              }
            }
          },
          starterPackView: {
            type: "object",
            required: ["uri", "cid", "record", "creator", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              record: {
                type: "unknown"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              list: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              },
              listItemsSample: {
                type: "array",
                maxLength: 12,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listItemView"
                }
              },
              feeds: {
                type: "array",
                maxLength: 3,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorView"
                }
              },
              joinedWeekCount: {
                type: "integer",
                minimum: 0
              },
              joinedAllTimeCount: {
                type: "integer",
                minimum: 0
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          starterPackViewBasic: {
            type: "object",
            required: ["uri", "cid", "record", "creator", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              record: {
                type: "unknown"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              },
              listItemCount: {
                type: "integer",
                minimum: 0
              },
              joinedWeekCount: {
                type: "integer",
                minimum: 0
              },
              joinedAllTimeCount: {
                type: "integer",
                minimum: 0
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          listPurpose: {
            type: "string",
            knownValues: [
              "app.bsky.graph.defs#modlist",
              "app.bsky.graph.defs#curatelist",
              "app.bsky.graph.defs#referencelist"
            ]
          },
          modlist: {
            type: "token",
            description: "A list of actors to apply an aggregate moderation action (mute/block) on."
          },
          curatelist: {
            type: "token",
            description: "A list of actors used for curation purposes such as list feeds or interaction gating."
          },
          referencelist: {
            type: "token",
            description: "A list of actors used for only for reference purposes such as within a starter pack."
          },
          listViewerState: {
            type: "object",
            properties: {
              muted: {
                type: "boolean"
              },
              blocked: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          notFoundActor: {
            type: "object",
            description: "indicates that a handle or DID could not be resolved",
            required: ["actor", "notFound"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              notFound: {
                type: "boolean",
                const: !0
              }
            }
          },
          relationship: {
            type: "object",
            description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              following: {
                type: "string",
                format: "at-uri",
                description: "if the actor follows this DID, this is the AT-URI of the follow record"
              },
              followedBy: {
                type: "string",
                format: "at-uri",
                description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
              }
            }
          }
        }
      },
      AppBskyGraphFollow: {
        lexicon: 1,
        id: "app.bsky.graph.follow",
        defs: {
          main: {
            type: "record",
            description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetActorStarterPacks: {
        lexicon: 1,
        id: "app.bsky.graph.getActorStarterPacks",
        defs: {
          main: {
            type: "query",
            description: "Get a list of starter packs created by the actor.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPacks"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  starterPacks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetBlocks: {
        lexicon: 1,
        id: "app.bsky.graph.getBlocks",
        defs: {
          main: {
            type: "query",
            description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["blocks"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  blocks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetFollowers: {
        lexicon: 1,
        id: "app.bsky.graph.getFollowers",
        defs: {
          main: {
            type: "query",
            description: "Enumerates accounts which follow a specified account (actor).",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject", "followers"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  },
                  cursor: {
                    type: "string"
                  },
                  followers: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetFollows: {
        lexicon: 1,
        id: "app.bsky.graph.getFollows",
        defs: {
          main: {
            type: "query",
            description: "Enumerates accounts which a specified account (actor) follows.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject", "follows"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  },
                  cursor: {
                    type: "string"
                  },
                  follows: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetKnownFollowers: {
        lexicon: 1,
        id: "app.bsky.graph.getKnownFollowers",
        defs: {
          main: {
            type: "query",
            description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject", "followers"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  },
                  cursor: {
                    type: "string"
                  },
                  followers: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetList: {
        lexicon: 1,
        id: "app.bsky.graph.getList",
        defs: {
          main: {
            type: "query",
            description: "Gets a 'view' (with additional context) of a specified list.",
            parameters: {
              type: "params",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) of the list record to hydrate."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["list", "items"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  list: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  },
                  items: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listItemView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetListBlocks: {
        lexicon: 1,
        id: "app.bsky.graph.getListBlocks",
        defs: {
          main: {
            type: "query",
            description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["lists"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  lists: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetListMutes: {
        lexicon: 1,
        id: "app.bsky.graph.getListMutes",
        defs: {
          main: {
            type: "query",
            description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["lists"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  lists: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetLists: {
        lexicon: 1,
        id: "app.bsky.graph.getLists",
        defs: {
          main: {
            type: "query",
            description: "Enumerates the lists created by a specified account (actor).",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier",
                  description: "The account (actor) to enumerate lists from."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["lists"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  lists: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetMutes: {
        lexicon: 1,
        id: "app.bsky.graph.getMutes",
        defs: {
          main: {
            type: "query",
            description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["mutes"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  mutes: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetRelationships: {
        lexicon: 1,
        id: "app.bsky.graph.getRelationships",
        defs: {
          main: {
            type: "query",
            description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier",
                  description: "Primary account requesting relationships for."
                },
                others: {
                  type: "array",
                  description: "List of 'other' accounts to be related back to the primary.",
                  maxLength: 30,
                  items: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["relationships"],
                properties: {
                  actor: {
                    type: "string",
                    format: "did"
                  },
                  relationships: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.graph.defs#relationship",
                        "lex:app.bsky.graph.defs#notFoundActor"
                      ]
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "ActorNotFound",
                description: "the primary actor at-identifier could not be resolved"
              }
            ]
          }
        }
      },
      AppBskyGraphGetStarterPack: {
        lexicon: 1,
        id: "app.bsky.graph.getStarterPack",
        defs: {
          main: {
            type: "query",
            description: "Gets a view of a starter pack.",
            parameters: {
              type: "params",
              required: ["starterPack"],
              properties: {
                starterPack: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) of the starter pack record."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPack"],
                properties: {
                  starterPack: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackView"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetStarterPacks: {
        lexicon: 1,
        id: "app.bsky.graph.getStarterPacks",
        defs: {
          main: {
            type: "query",
            description: "Get views for a list of starter packs.",
            parameters: {
              type: "params",
              required: ["uris"],
              properties: {
                uris: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  maxLength: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPacks"],
                properties: {
                  starterPacks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphGetSuggestedFollowsByActor: {
        lexicon: 1,
        id: "app.bsky.graph.getSuggestedFollowsByActor",
        defs: {
          main: {
            type: "query",
            description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["suggestions"],
                properties: {
                  suggestions: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  },
                  isFallback: {
                    type: "boolean",
                    description: "If true, response has fallen-back to generic results, and is not scoped using relativeToDid",
                    default: !1
                  },
                  recId: {
                    type: "integer",
                    description: "Snowflake for this recommendation, use when submitting recommendation events."
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphList: {
        lexicon: 1,
        id: "app.bsky.graph.list",
        defs: {
          main: {
            type: "record",
            description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
            key: "tid",
            record: {
              type: "object",
              required: ["name", "purpose", "createdAt"],
              properties: {
                purpose: {
                  type: "ref",
                  description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1,
                  description: "Display name for list; can not be empty."
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "blob",
                  accept: ["image/png", "image/jpeg"],
                  maxSize: 1e6
                },
                labels: {
                  type: "union",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphListblock: {
        lexicon: 1,
        id: "app.bsky.graph.listblock",
        defs: {
          main: {
            type: "record",
            description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to the mod list record."
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphListitem: {
        lexicon: 1,
        id: "app.bsky.graph.listitem",
        defs: {
          main: {
            type: "record",
            description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "list", "createdAt"],
              properties: {
                subject: {
                  type: "string",
                  format: "did",
                  description: "The account which is included on the list."
                },
                list: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyGraphMuteActor: {
        lexicon: 1,
        id: "app.bsky.graph.muteActor",
        defs: {
          main: {
            type: "procedure",
            description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphMuteActorList: {
        lexicon: 1,
        id: "app.bsky.graph.muteActorList",
        defs: {
          main: {
            type: "procedure",
            description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphMuteThread: {
        lexicon: 1,
        id: "app.bsky.graph.muteThread",
        defs: {
          main: {
            type: "procedure",
            description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["root"],
                properties: {
                  root: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphSearchStarterPacks: {
        lexicon: 1,
        id: "app.bsky.graph.searchStarterPacks",
        defs: {
          main: {
            type: "query",
            description: "Find starter packs matching search criteria. Does not require auth.",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPacks"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  starterPacks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphStarterpack: {
        lexicon: 1,
        id: "app.bsky.graph.starterpack",
        defs: {
          main: {
            type: "record",
            description: "Record defining a starter pack of actors and feeds for new users.",
            key: "tid",
            record: {
              type: "object",
              required: ["name", "list", "createdAt"],
              properties: {
                name: {
                  type: "string",
                  maxGraphemes: 50,
                  maxLength: 500,
                  minLength: 1,
                  description: "Display name for starter pack; can not be empty."
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                list: {
                  type: "string",
                  format: "at-uri",
                  description: "Reference (AT-URI) to the list record."
                },
                feeds: {
                  type: "array",
                  maxLength: 3,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.starterpack#feedItem"
                  }
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          },
          feedItem: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          }
        }
      },
      AppBskyGraphUnmuteActor: {
        lexicon: 1,
        id: "app.bsky.graph.unmuteActor",
        defs: {
          main: {
            type: "procedure",
            description: "Unmutes the specified account. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphUnmuteActorList: {
        lexicon: 1,
        id: "app.bsky.graph.unmuteActorList",
        defs: {
          main: {
            type: "procedure",
            description: "Unmutes the specified list of accounts. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphUnmuteThread: {
        lexicon: 1,
        id: "app.bsky.graph.unmuteThread",
        defs: {
          main: {
            type: "procedure",
            description: "Unmutes the specified thread. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["root"],
                properties: {
                  root: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyGraphVerification: {
        lexicon: 1,
        id: "app.bsky.graph.verification",
        defs: {
          main: {
            type: "record",
            description: "Record declaring a verification relationship between two accounts. Verifications are only considered valid by an app if issued by an account the app considers trusted.",
            key: "tid",
            record: {
              type: "object",
              required: ["subject", "handle", "displayName", "createdAt"],
              properties: {
                subject: {
                  description: "DID of the subject the verification applies to.",
                  type: "string",
                  format: "did"
                },
                handle: {
                  description: "Handle of the subject the verification applies to at the moment of verifying, which might not be the same at the time of viewing. The verification is only valid if the current handle matches the one at the time of verifying.",
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  description: "Display name of the subject the verification applies to at the moment of verifying, which might not be the same at the time of viewing. The verification is only valid if the current displayName matches the one at the time of verifying.",
                  type: "string"
                },
                createdAt: {
                  description: "Date of when the verification was created.",
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      },
      AppBskyLabelerDefs: {
        lexicon: 1,
        id: "app.bsky.labeler.defs",
        defs: {
          labelerView: {
            type: "object",
            required: ["uri", "cid", "creator", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              likeCount: {
                type: "integer",
                minimum: 0
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          },
          labelerViewDetailed: {
            type: "object",
            required: ["uri", "cid", "creator", "policies", "indexedAt"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              creator: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              policies: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerPolicies"
              },
              likeCount: {
                type: "integer",
                minimum: 0
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerViewerState"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              reasonTypes: {
                description: "The set of report reason 'codes' which are in-scope for this service to review and action. These usually align to policy categories. If not defined (distinct from empty array), all reason types are allowed.",
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                }
              },
              subjectTypes: {
                description: "The set of subject types (account, record, etc) this service accepts reports on.",
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#subjectType"
                }
              },
              subjectCollections: {
                type: "array",
                description: "Set of record types (collection NSIDs) which can be reported to this service. If not defined (distinct from empty array), default is any record type.",
                items: {
                  type: "string",
                  format: "nsid"
                }
              }
            }
          },
          labelerViewerState: {
            type: "object",
            properties: {
              like: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          labelerPolicies: {
            type: "object",
            required: ["labelValues"],
            properties: {
              labelValues: {
                type: "array",
                description: "The label values which this labeler publishes. May include global or custom labels.",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#labelValue"
                }
              },
              labelValueDefinitions: {
                type: "array",
                description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#labelValueDefinition"
                }
              }
            }
          }
        }
      },
      AppBskyLabelerGetServices: {
        lexicon: 1,
        id: "app.bsky.labeler.getServices",
        defs: {
          main: {
            type: "query",
            description: "Get information about a list of labeler services.",
            parameters: {
              type: "params",
              required: ["dids"],
              properties: {
                dids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                },
                detailed: {
                  type: "boolean",
                  default: !1
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["views"],
                properties: {
                  views: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.labeler.defs#labelerView",
                        "lex:app.bsky.labeler.defs#labelerViewDetailed"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyLabelerService: {
        lexicon: 1,
        id: "app.bsky.labeler.service",
        defs: {
          main: {
            type: "record",
            description: "A declaration of the existence of labeler service.",
            key: "literal:self",
            record: {
              type: "object",
              required: ["policies", "createdAt"],
              properties: {
                policies: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerPolicies"
                },
                labels: {
                  type: "union",
                  refs: ["lex:com.atproto.label.defs#selfLabels"]
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                reasonTypes: {
                  description: "The set of report reason 'codes' which are in-scope for this service to review and action. These usually align to policy categories. If not defined (distinct from empty array), all reason types are allowed.",
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.moderation.defs#reasonType"
                  }
                },
                subjectTypes: {
                  description: "The set of subject types (account, record, etc) this service accepts reports on.",
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.moderation.defs#subjectType"
                  }
                },
                subjectCollections: {
                  type: "array",
                  description: "Set of record types (collection NSIDs) which can be reported to this service. If not defined (distinct from empty array), default is any record type.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationDefs: {
        lexicon: 1,
        id: "app.bsky.notification.defs",
        defs: {
          recordDeleted: {
            type: "object",
            properties: {}
          }
        }
      },
      AppBskyNotificationGetUnreadCount: {
        lexicon: 1,
        id: "app.bsky.notification.getUnreadCount",
        defs: {
          main: {
            type: "query",
            description: "Count the number of unread notifications for the requesting account. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                priority: {
                  type: "boolean"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["count"],
                properties: {
                  count: {
                    type: "integer"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationListNotifications: {
        lexicon: 1,
        id: "app.bsky.notification.listNotifications",
        defs: {
          main: {
            type: "query",
            description: "Enumerate notifications for the requesting account. Requires auth.",
            parameters: {
              type: "params",
              properties: {
                reasons: {
                  description: "Notification reasons to include in response.",
                  type: "array",
                  items: {
                    type: "string",
                    description: "A reason that matches the reason property of #notification."
                  }
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                priority: {
                  type: "boolean"
                },
                cursor: {
                  type: "string"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["notifications"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  notifications: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.notification.listNotifications#notification"
                    }
                  },
                  priority: {
                    type: "boolean"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          },
          notification: {
            type: "object",
            required: [
              "uri",
              "cid",
              "author",
              "reason",
              "record",
              "isRead",
              "indexedAt"
            ],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              author: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileView"
              },
              reason: {
                type: "string",
                description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', 'starterpack-joined', 'verified', and 'unverified'.",
                knownValues: [
                  "like",
                  "repost",
                  "follow",
                  "mention",
                  "reply",
                  "quote",
                  "starterpack-joined",
                  "verified",
                  "unverified"
                ]
              },
              reasonSubject: {
                type: "string",
                format: "at-uri"
              },
              record: {
                type: "unknown"
              },
              isRead: {
                type: "boolean"
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              }
            }
          }
        }
      },
      AppBskyNotificationPutPreferences: {
        lexicon: 1,
        id: "app.bsky.notification.putPreferences",
        defs: {
          main: {
            type: "procedure",
            description: "Set notification-related preferences for an account. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["priority"],
                properties: {
                  priority: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationRegisterPush: {
        lexicon: 1,
        id: "app.bsky.notification.registerPush",
        defs: {
          main: {
            type: "procedure",
            description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["serviceDid", "token", "platform", "appId"],
                properties: {
                  serviceDid: {
                    type: "string",
                    format: "did"
                  },
                  token: {
                    type: "string"
                  },
                  platform: {
                    type: "string",
                    knownValues: ["ios", "android", "web"]
                  },
                  appId: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyNotificationUpdateSeen: {
        lexicon: 1,
        id: "app.bsky.notification.updateSeen",
        defs: {
          main: {
            type: "procedure",
            description: "Notify server that the requesting account has seen notifications. Requires auth.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["seenAt"],
                properties: {
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyRichtextFacet: {
        lexicon: 1,
        id: "app.bsky.richtext.facet",
        defs: {
          main: {
            type: "object",
            description: "Annotation of a sub-string within rich text.",
            required: ["index", "features"],
            properties: {
              index: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet#byteSlice"
              },
              features: {
                type: "array",
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.richtext.facet#mention",
                    "lex:app.bsky.richtext.facet#link",
                    "lex:app.bsky.richtext.facet#tag"
                  ]
                }
              }
            }
          },
          mention: {
            type: "object",
            description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          link: {
            type: "object",
            description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "uri"
              }
            }
          },
          tag: {
            type: "object",
            description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
            required: ["tag"],
            properties: {
              tag: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              }
            }
          },
          byteSlice: {
            type: "object",
            description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
            required: ["byteStart", "byteEnd"],
            properties: {
              byteStart: {
                type: "integer",
                minimum: 0
              },
              byteEnd: {
                type: "integer",
                minimum: 0
              }
            }
          }
        }
      },
      AppBskyUnspeccedDefs: {
        lexicon: 1,
        id: "app.bsky.unspecced.defs",
        defs: {
          skeletonSearchPost: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          skeletonSearchActor: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          skeletonSearchStarterPack: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          trendingTopic: {
            type: "object",
            required: ["topic", "link"],
            properties: {
              topic: {
                type: "string"
              },
              displayName: {
                type: "string"
              },
              description: {
                type: "string"
              },
              link: {
                type: "string"
              }
            }
          },
          skeletonTrend: {
            type: "object",
            required: [
              "topic",
              "displayName",
              "link",
              "startedAt",
              "postCount",
              "dids"
            ],
            properties: {
              topic: {
                type: "string"
              },
              displayName: {
                type: "string"
              },
              link: {
                type: "string"
              },
              startedAt: {
                type: "string",
                format: "datetime"
              },
              postCount: {
                type: "integer"
              },
              status: {
                type: "string",
                knownValues: ["hot"]
              },
              category: {
                type: "string"
              },
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          trendView: {
            type: "object",
            required: [
              "topic",
              "displayName",
              "link",
              "startedAt",
              "postCount",
              "actors"
            ],
            properties: {
              topic: {
                type: "string"
              },
              displayName: {
                type: "string"
              },
              link: {
                type: "string"
              },
              startedAt: {
                type: "string",
                format: "datetime"
              },
              postCount: {
                type: "integer"
              },
              status: {
                type: "string",
                knownValues: ["hot"]
              },
              category: {
                type: "string"
              },
              actors: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetConfig: {
        lexicon: 1,
        id: "app.bsky.unspecced.getConfig",
        defs: {
          main: {
            type: "query",
            description: "Get miscellaneous runtime configuration.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: [],
                properties: {
                  checkEmailConfirmed: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetPopularFeedGenerators: {
        lexicon: 1,
        id: "app.bsky.unspecced.getPopularFeedGenerators",
        defs: {
          main: {
            type: "query",
            description: "An unspecced view of globally popular feed generators.",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                query: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestedFeeds: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestedFeeds",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested feeds",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestedFeedsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestedFeedsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get a skeleton of suggested feeds. Intended to be called and hydrated by app.bsky.unspecced.getSuggestedFeeds",
            parameters: {
              type: "params",
              properties: {
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries)."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestedStarterPacks: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestedStarterPacks",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested starterpacks",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPacks"],
                properties: {
                  starterPacks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#starterPackView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestedStarterPacksSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestedStarterPacksSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get a skeleton of suggested starterpacks. Intended to be called and hydrated by app.bsky.unspecced.getSuggestedStarterpacks",
            parameters: {
              type: "params",
              properties: {
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries)."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPacks"],
                properties: {
                  starterPacks: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestedUsers: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestedUsers",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggested users",
            parameters: {
              type: "params",
              properties: {
                category: {
                  type: "string",
                  description: "Category of users to get suggestions for."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 50,
                  default: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestedUsersSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestedUsersSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get a skeleton of suggested users. Intended to be called and hydrated by app.bsky.unspecced.getSuggestedUsers",
            parameters: {
              type: "params",
              properties: {
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries)."
                },
                category: {
                  type: "string",
                  description: "Category of users to get suggestions for."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 50,
                  default: 25
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetSuggestionsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.getSuggestionsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
            parameters: {
              type: "params",
              properties: {
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                relativeToDid: {
                  type: "string",
                  format: "did",
                  description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                    }
                  },
                  relativeToDid: {
                    type: "string",
                    format: "did",
                    description: "DID of the account these suggestions are relative to. If this is returned undefined, suggestions are based on the viewer."
                  },
                  recId: {
                    type: "integer",
                    description: "Snowflake for this recommendation, use when submitting recommendation events."
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetTaggedSuggestions: {
        lexicon: 1,
        id: "app.bsky.unspecced.getTaggedSuggestions",
        defs: {
          main: {
            type: "query",
            description: "Get a list of suggestions (feeds and users) tagged with categories",
            parameters: {
              type: "params",
              properties: {}
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["suggestions"],
                properties: {
                  suggestions: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                    }
                  }
                }
              }
            }
          },
          suggestion: {
            type: "object",
            required: ["tag", "subjectType", "subject"],
            properties: {
              tag: {
                type: "string"
              },
              subjectType: {
                type: "string",
                knownValues: ["actor", "feed"]
              },
              subject: {
                type: "string",
                format: "uri"
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetTrendingTopics: {
        lexicon: 1,
        id: "app.bsky.unspecced.getTrendingTopics",
        defs: {
          main: {
            type: "query",
            description: "Get a list of trending topics",
            parameters: {
              type: "params",
              properties: {
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["topics", "suggested"],
                properties: {
                  topics: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#trendingTopic"
                    }
                  },
                  suggested: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#trendingTopic"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetTrends: {
        lexicon: 1,
        id: "app.bsky.unspecced.getTrends",
        defs: {
          main: {
            type: "query",
            description: "Get the current trends on the network",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["trends"],
                properties: {
                  trends: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#trendView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedGetTrendsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.getTrendsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Get the skeleton of trends on the network. Intended to be called and then hydrated through app.bsky.unspecced.getTrends",
            parameters: {
              type: "params",
              properties: {
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries)."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 25,
                  default: 10
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["trends"],
                properties: {
                  trends: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonTrend"
                    }
                  }
                }
              }
            }
          }
        }
      },
      AppBskyUnspeccedSearchActorsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.searchActorsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Backend Actors (profile) search, returns only skeleton.",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                },
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                },
                typeahead: {
                  type: "boolean",
                  description: "If true, acts as fast/simple 'typeahead' query."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actors"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  actors: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      },
      AppBskyUnspeccedSearchPostsSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.searchPostsSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Backend Posts search, returns only skeleton",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                sort: {
                  type: "string",
                  knownValues: ["top", "latest"],
                  default: "latest",
                  description: "Specifies the ranking order of results."
                },
                since: {
                  type: "string",
                  description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
                },
                until: {
                  type: "string",
                  description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
                },
                mentions: {
                  type: "string",
                  format: "at-identifier",
                  description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
                },
                author: {
                  type: "string",
                  format: "at-identifier",
                  description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
                },
                lang: {
                  type: "string",
                  format: "language",
                  description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
                },
                domain: {
                  type: "string",
                  description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
                },
                url: {
                  type: "string",
                  format: "uri",
                  description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
                },
                tag: {
                  type: "array",
                  items: {
                    type: "string",
                    maxLength: 640,
                    maxGraphemes: 64
                  },
                  description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
                },
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["posts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  posts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      },
      AppBskyUnspeccedSearchStarterPacksSkeleton: {
        lexicon: 1,
        id: "app.bsky.unspecced.searchStarterPacksSkeleton",
        defs: {
          main: {
            type: "query",
            description: "Backend Starter Pack search, returns only skeleton.",
            parameters: {
              type: "params",
              required: ["q"],
              properties: {
                q: {
                  type: "string",
                  description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                },
                viewer: {
                  type: "string",
                  format: "did",
                  description: "DID of the account making the request (not included for public/unauthenticated queries)."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 25
                },
                cursor: {
                  type: "string",
                  description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["starterPacks"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  hitsTotal: {
                    type: "integer",
                    description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                  },
                  starterPacks: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.unspecced.defs#skeletonSearchStarterPack"
                    }
                  }
                }
              }
            },
            errors: [
              {
                name: "BadQueryString"
              }
            ]
          }
        }
      },
      AppBskyVideoDefs: {
        lexicon: 1,
        id: "app.bsky.video.defs",
        defs: {
          jobStatus: {
            type: "object",
            required: ["jobId", "did", "state"],
            properties: {
              jobId: {
                type: "string"
              },
              did: {
                type: "string",
                format: "did"
              },
              state: {
                type: "string",
                description: "The state of the video processing job. All values not listed as a known value indicate that the job is in process.",
                knownValues: ["JOB_STATE_COMPLETED", "JOB_STATE_FAILED"]
              },
              progress: {
                type: "integer",
                minimum: 0,
                maximum: 100,
                description: "Progress within the current processing state."
              },
              blob: {
                type: "blob"
              },
              error: {
                type: "string"
              },
              message: {
                type: "string"
              }
            }
          }
        }
      },
      AppBskyVideoGetJobStatus: {
        lexicon: 1,
        id: "app.bsky.video.getJobStatus",
        defs: {
          main: {
            type: "query",
            description: "Get status details for a video processing job.",
            parameters: {
              type: "params",
              required: ["jobId"],
              properties: {
                jobId: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["jobStatus"],
                properties: {
                  jobStatus: {
                    type: "ref",
                    ref: "lex:app.bsky.video.defs#jobStatus"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyVideoGetUploadLimits: {
        lexicon: 1,
        id: "app.bsky.video.getUploadLimits",
        defs: {
          main: {
            type: "query",
            description: "Get video upload limits for the authenticated user.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["canUpload"],
                properties: {
                  canUpload: {
                    type: "boolean"
                  },
                  remainingDailyVideos: {
                    type: "integer"
                  },
                  remainingDailyBytes: {
                    type: "integer"
                  },
                  message: {
                    type: "string"
                  },
                  error: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      AppBskyVideoUploadVideo: {
        lexicon: 1,
        id: "app.bsky.video.uploadVideo",
        defs: {
          main: {
            type: "procedure",
            description: "Upload a video to be processed then stored on the PDS.",
            input: {
              encoding: "video/mp4"
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["jobStatus"],
                properties: {
                  jobStatus: {
                    type: "ref",
                    ref: "lex:app.bsky.video.defs#jobStatus"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyActorDeclaration: {
        lexicon: 1,
        id: "chat.bsky.actor.declaration",
        defs: {
          main: {
            type: "record",
            description: "A declaration of a Bluesky chat account.",
            key: "literal:self",
            record: {
              type: "object",
              required: ["allowIncoming"],
              properties: {
                allowIncoming: {
                  type: "string",
                  knownValues: ["all", "none", "following"]
                }
              }
            }
          }
        }
      },
      ChatBskyActorDefs: {
        lexicon: 1,
        id: "chat.bsky.actor.defs",
        defs: {
          profileViewBasic: {
            type: "object",
            required: ["did", "handle"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              avatar: {
                type: "string",
                format: "uri"
              },
              associated: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileAssociated"
              },
              viewer: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#viewerState"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              chatDisabled: {
                type: "boolean",
                description: "Set to true when the actor cannot actively participate in conversations"
              },
              verification: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#verificationState"
              }
            }
          }
        }
      },
      ChatBskyActorDeleteAccount: {
        lexicon: 1,
        id: "chat.bsky.actor.deleteAccount",
        defs: {
          main: {
            type: "procedure",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {}
              }
            }
          }
        }
      },
      ChatBskyActorExportAccountData: {
        lexicon: 1,
        id: "chat.bsky.actor.exportAccountData",
        defs: {
          main: {
            type: "query",
            output: {
              encoding: "application/jsonl"
            }
          }
        }
      },
      ChatBskyConvoAcceptConvo: {
        lexicon: 1,
        id: "chat.bsky.convo.acceptConvo",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  rev: {
                    description: "Rev when the convo was accepted. If not present, the convo was already accepted.",
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoAddReaction: {
        lexicon: 1,
        id: "chat.bsky.convo.addReaction",
        defs: {
          main: {
            type: "procedure",
            description: "Adds an emoji reaction to a message. Requires authentication. It is idempotent, so multiple calls from the same user with the same emoji result in a single reaction.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId", "messageId", "value"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  messageId: {
                    type: "string"
                  },
                  value: {
                    type: "string",
                    minLength: 1,
                    maxLength: 64,
                    minGraphemes: 1,
                    maxGraphemes: 1
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["message"],
                properties: {
                  message: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageView"
                  }
                }
              }
            },
            errors: [
              {
                name: "ReactionMessageDeleted",
                description: "Indicates that the message has been deleted and reactions can no longer be added/removed."
              },
              {
                name: "ReactionLimitReached",
                description: "Indicates that the message has the maximum number of reactions allowed for a single user, and the requested reaction wasn't yet present. If it was already present, the request will not fail since it is idempotent."
              },
              {
                name: "ReactionInvalidValue",
                description: "Indicates the value for the reaction is not acceptable. In general, this means it is not an emoji."
              }
            ]
          }
        }
      },
      ChatBskyConvoDefs: {
        lexicon: 1,
        id: "chat.bsky.convo.defs",
        defs: {
          messageRef: {
            type: "object",
            required: ["did", "messageId", "convoId"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              convoId: {
                type: "string"
              },
              messageId: {
                type: "string"
              }
            }
          },
          messageInput: {
            type: "object",
            required: ["text"],
            properties: {
              text: {
                type: "string",
                maxLength: 1e4,
                maxGraphemes: 1e3
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              embed: {
                type: "union",
                refs: ["lex:app.bsky.embed.record"]
              }
            }
          },
          messageView: {
            type: "object",
            required: ["id", "rev", "text", "sender", "sentAt"],
            properties: {
              id: {
                type: "string"
              },
              rev: {
                type: "string"
              },
              text: {
                type: "string",
                maxLength: 1e4,
                maxGraphemes: 1e3
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              embed: {
                type: "union",
                refs: ["lex:app.bsky.embed.record#view"]
              },
              reactions: {
                type: "array",
                description: "Reactions to this message, in ascending order of creation time.",
                items: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#reactionView"
                }
              },
              sender: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#messageViewSender"
              },
              sentAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          deletedMessageView: {
            type: "object",
            required: ["id", "rev", "sender", "sentAt"],
            properties: {
              id: {
                type: "string"
              },
              rev: {
                type: "string"
              },
              sender: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#messageViewSender"
              },
              sentAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          messageViewSender: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          reactionView: {
            type: "object",
            required: ["value", "sender", "createdAt"],
            properties: {
              value: {
                type: "string"
              },
              sender: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#reactionViewSender"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          reactionViewSender: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          messageAndReactionView: {
            type: "object",
            required: ["message", "reaction"],
            properties: {
              message: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#messageView"
              },
              reaction: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#reactionView"
              }
            }
          },
          convoView: {
            type: "object",
            required: ["id", "rev", "members", "muted", "unreadCount"],
            properties: {
              id: {
                type: "string"
              },
              rev: {
                type: "string"
              },
              members: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:chat.bsky.actor.defs#profileViewBasic"
                }
              },
              lastMessage: {
                type: "union",
                refs: [
                  "lex:chat.bsky.convo.defs#messageView",
                  "lex:chat.bsky.convo.defs#deletedMessageView"
                ]
              },
              lastReaction: {
                type: "union",
                refs: ["lex:chat.bsky.convo.defs#messageAndReactionView"]
              },
              muted: {
                type: "boolean"
              },
              status: {
                type: "string",
                knownValues: ["request", "accepted"]
              },
              unreadCount: {
                type: "integer"
              }
            }
          },
          logBeginConvo: {
            type: "object",
            required: ["rev", "convoId"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              }
            }
          },
          logAcceptConvo: {
            type: "object",
            required: ["rev", "convoId"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              }
            }
          },
          logLeaveConvo: {
            type: "object",
            required: ["rev", "convoId"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              }
            }
          },
          logMuteConvo: {
            type: "object",
            required: ["rev", "convoId"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              }
            }
          },
          logUnmuteConvo: {
            type: "object",
            required: ["rev", "convoId"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              }
            }
          },
          logCreateMessage: {
            type: "object",
            required: ["rev", "convoId", "message"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              },
              message: {
                type: "union",
                refs: [
                  "lex:chat.bsky.convo.defs#messageView",
                  "lex:chat.bsky.convo.defs#deletedMessageView"
                ]
              }
            }
          },
          logDeleteMessage: {
            type: "object",
            required: ["rev", "convoId", "message"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              },
              message: {
                type: "union",
                refs: [
                  "lex:chat.bsky.convo.defs#messageView",
                  "lex:chat.bsky.convo.defs#deletedMessageView"
                ]
              }
            }
          },
          logReadMessage: {
            type: "object",
            required: ["rev", "convoId", "message"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              },
              message: {
                type: "union",
                refs: [
                  "lex:chat.bsky.convo.defs#messageView",
                  "lex:chat.bsky.convo.defs#deletedMessageView"
                ]
              }
            }
          },
          logAddReaction: {
            type: "object",
            required: ["rev", "convoId", "message", "reaction"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              },
              message: {
                type: "union",
                refs: [
                  "lex:chat.bsky.convo.defs#messageView",
                  "lex:chat.bsky.convo.defs#deletedMessageView"
                ]
              },
              reaction: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#reactionView"
              }
            }
          },
          logRemoveReaction: {
            type: "object",
            required: ["rev", "convoId", "message", "reaction"],
            properties: {
              rev: {
                type: "string"
              },
              convoId: {
                type: "string"
              },
              message: {
                type: "union",
                refs: [
                  "lex:chat.bsky.convo.defs#messageView",
                  "lex:chat.bsky.convo.defs#deletedMessageView"
                ]
              },
              reaction: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#reactionView"
              }
            }
          }
        }
      },
      ChatBskyConvoDeleteMessageForSelf: {
        lexicon: 1,
        id: "chat.bsky.convo.deleteMessageForSelf",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId", "messageId"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  messageId: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#deletedMessageView"
              }
            }
          }
        }
      },
      ChatBskyConvoGetConvo: {
        lexicon: 1,
        id: "chat.bsky.convo.getConvo",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convo"],
                properties: {
                  convo: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoGetConvoAvailability: {
        lexicon: 1,
        id: "chat.bsky.convo.getConvoAvailability",
        defs: {
          main: {
            type: "query",
            description: "Get whether the requester and the other members can chat. If an existing convo is found for these members, it is returned.",
            parameters: {
              type: "params",
              required: ["members"],
              properties: {
                members: {
                  type: "array",
                  minLength: 1,
                  maxLength: 10,
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["canChat"],
                properties: {
                  canChat: {
                    type: "boolean"
                  },
                  convo: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoGetConvoForMembers: {
        lexicon: 1,
        id: "chat.bsky.convo.getConvoForMembers",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              required: ["members"],
              properties: {
                members: {
                  type: "array",
                  minLength: 1,
                  maxLength: 10,
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convo"],
                properties: {
                  convo: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoGetLog: {
        lexicon: 1,
        id: "chat.bsky.convo.getLog",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              required: [],
              properties: {
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["logs"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  logs: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:chat.bsky.convo.defs#logBeginConvo",
                        "lex:chat.bsky.convo.defs#logAcceptConvo",
                        "lex:chat.bsky.convo.defs#logLeaveConvo",
                        "lex:chat.bsky.convo.defs#logMuteConvo",
                        "lex:chat.bsky.convo.defs#logUnmuteConvo",
                        "lex:chat.bsky.convo.defs#logCreateMessage",
                        "lex:chat.bsky.convo.defs#logDeleteMessage",
                        "lex:chat.bsky.convo.defs#logReadMessage",
                        "lex:chat.bsky.convo.defs#logAddReaction",
                        "lex:chat.bsky.convo.defs#logRemoveReaction"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoGetMessages: {
        lexicon: 1,
        id: "chat.bsky.convo.getMessages",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["messages"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  messages: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:chat.bsky.convo.defs#messageView",
                        "lex:chat.bsky.convo.defs#deletedMessageView"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoLeaveConvo: {
        lexicon: 1,
        id: "chat.bsky.convo.leaveConvo",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId", "rev"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  rev: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoListConvos: {
        lexicon: 1,
        id: "chat.bsky.convo.listConvos",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                readState: {
                  type: "string",
                  knownValues: ["unread"]
                },
                status: {
                  type: "string",
                  knownValues: ["request", "accepted"]
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convos"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  convos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoMuteConvo: {
        lexicon: 1,
        id: "chat.bsky.convo.muteConvo",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convo"],
                properties: {
                  convo: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoRemoveReaction: {
        lexicon: 1,
        id: "chat.bsky.convo.removeReaction",
        defs: {
          main: {
            type: "procedure",
            description: "Removes an emoji reaction from a message. Requires authentication. It is idempotent, so multiple calls from the same user with the same emoji result in that reaction not being present, even if it already wasn't.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId", "messageId", "value"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  messageId: {
                    type: "string"
                  },
                  value: {
                    type: "string",
                    minLength: 1,
                    maxLength: 64,
                    minGraphemes: 1,
                    maxGraphemes: 1
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["message"],
                properties: {
                  message: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageView"
                  }
                }
              }
            },
            errors: [
              {
                name: "ReactionMessageDeleted",
                description: "Indicates that the message has been deleted and reactions can no longer be added/removed."
              },
              {
                name: "ReactionInvalidValue",
                description: "Indicates the value for the reaction is not acceptable. In general, this means it is not an emoji."
              }
            ]
          }
        }
      },
      ChatBskyConvoSendMessage: {
        lexicon: 1,
        id: "chat.bsky.convo.sendMessage",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId", "message"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  message: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageInput"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#messageView"
              }
            }
          }
        }
      },
      ChatBskyConvoSendMessageBatch: {
        lexicon: 1,
        id: "chat.bsky.convo.sendMessageBatch",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["items"],
                properties: {
                  items: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                    }
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["items"],
                properties: {
                  items: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#messageView"
                    }
                  }
                }
              }
            }
          },
          batchItem: {
            type: "object",
            required: ["convoId", "message"],
            properties: {
              convoId: {
                type: "string"
              },
              message: {
                type: "ref",
                ref: "lex:chat.bsky.convo.defs#messageInput"
              }
            }
          }
        }
      },
      ChatBskyConvoUnmuteConvo: {
        lexicon: 1,
        id: "chat.bsky.convo.unmuteConvo",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convo"],
                properties: {
                  convo: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoUpdateAllRead: {
        lexicon: 1,
        id: "chat.bsky.convo.updateAllRead",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "string",
                    knownValues: ["request", "accepted"]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["updatedCount"],
                properties: {
                  updatedCount: {
                    description: "The count of updated convos.",
                    type: "integer"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyConvoUpdateRead: {
        lexicon: 1,
        id: "chat.bsky.convo.updateRead",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  messageId: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["convo"],
                properties: {
                  convo: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyModerationGetActorMetadata: {
        lexicon: 1,
        id: "chat.bsky.moderation.getActorMetadata",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["day", "month", "all"],
                properties: {
                  day: {
                    type: "ref",
                    ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                  },
                  month: {
                    type: "ref",
                    ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                  },
                  all: {
                    type: "ref",
                    ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                  }
                }
              }
            }
          },
          metadata: {
            type: "object",
            required: [
              "messagesSent",
              "messagesReceived",
              "convos",
              "convosStarted"
            ],
            properties: {
              messagesSent: {
                type: "integer"
              },
              messagesReceived: {
                type: "integer"
              },
              convos: {
                type: "integer"
              },
              convosStarted: {
                type: "integer"
              }
            }
          }
        }
      },
      ChatBskyModerationGetMessageContext: {
        lexicon: 1,
        id: "chat.bsky.moderation.getMessageContext",
        defs: {
          main: {
            type: "query",
            parameters: {
              type: "params",
              required: ["messageId"],
              properties: {
                convoId: {
                  type: "string",
                  description: "Conversation that the message is from. NOTE: this field will eventually be required."
                },
                messageId: {
                  type: "string"
                },
                before: {
                  type: "integer",
                  default: 5
                },
                after: {
                  type: "integer",
                  default: 5
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["messages"],
                properties: {
                  messages: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:chat.bsky.convo.defs#messageView",
                        "lex:chat.bsky.convo.defs#deletedMessageView"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      },
      ChatBskyModerationUpdateActorAccess: {
        lexicon: 1,
        id: "chat.bsky.moderation.updateActorAccess",
        defs: {
          main: {
            type: "procedure",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["actor", "allowAccess"],
                properties: {
                  actor: {
                    type: "string",
                    format: "did"
                  },
                  allowAccess: {
                    type: "boolean"
                  },
                  ref: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneCommunicationCreateTemplate: {
        lexicon: 1,
        id: "tools.ozone.communication.createTemplate",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to create a new, re-usable communication (email for now) template.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subject", "contentMarkdown", "name"],
                properties: {
                  name: {
                    type: "string",
                    description: "Name of the template."
                  },
                  contentMarkdown: {
                    type: "string",
                    description: "Content of the template, markdown supported, can contain variable placeholders."
                  },
                  subject: {
                    type: "string",
                    description: "Subject of the message, used in emails."
                  },
                  lang: {
                    type: "string",
                    format: "language",
                    description: "Message language."
                  },
                  createdBy: {
                    type: "string",
                    format: "did",
                    description: "DID of the user who is creating the template."
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.communication.defs#templateView"
              }
            },
            errors: [
              {
                name: "DuplicateTemplateName"
              }
            ]
          }
        }
      },
      ToolsOzoneCommunicationDefs: {
        lexicon: 1,
        id: "tools.ozone.communication.defs",
        defs: {
          templateView: {
            type: "object",
            required: [
              "id",
              "name",
              "contentMarkdown",
              "disabled",
              "lastUpdatedBy",
              "createdAt",
              "updatedAt"
            ],
            properties: {
              id: {
                type: "string"
              },
              name: {
                type: "string",
                description: "Name of the template."
              },
              subject: {
                type: "string",
                description: "Content of the template, can contain markdown and variable placeholders."
              },
              contentMarkdown: {
                type: "string",
                description: "Subject of the message, used in emails."
              },
              disabled: {
                type: "boolean"
              },
              lang: {
                type: "string",
                format: "language",
                description: "Message language."
              },
              lastUpdatedBy: {
                type: "string",
                format: "did",
                description: "DID of the user who last updated the template."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              updatedAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      },
      ToolsOzoneCommunicationDeleteTemplate: {
        lexicon: 1,
        id: "tools.ozone.communication.deleteTemplate",
        defs: {
          main: {
            type: "procedure",
            description: "Delete a communication template.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["id"],
                properties: {
                  id: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneCommunicationListTemplates: {
        lexicon: 1,
        id: "tools.ozone.communication.listTemplates",
        defs: {
          main: {
            type: "query",
            description: "Get list of all communication templates.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["communicationTemplates"],
                properties: {
                  communicationTemplates: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.communication.defs#templateView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneCommunicationUpdateTemplate: {
        lexicon: 1,
        id: "tools.ozone.communication.updateTemplate",
        defs: {
          main: {
            type: "procedure",
            description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["id"],
                properties: {
                  id: {
                    type: "string",
                    description: "ID of the template to be updated."
                  },
                  name: {
                    type: "string",
                    description: "Name of the template."
                  },
                  lang: {
                    type: "string",
                    format: "language",
                    description: "Message language."
                  },
                  contentMarkdown: {
                    type: "string",
                    description: "Content of the template, markdown supported, can contain variable placeholders."
                  },
                  subject: {
                    type: "string",
                    description: "Subject of the message, used in emails."
                  },
                  updatedBy: {
                    type: "string",
                    format: "did",
                    description: "DID of the user who is updating the template."
                  },
                  disabled: {
                    type: "boolean"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.communication.defs#templateView"
              }
            },
            errors: [
              {
                name: "DuplicateTemplateName"
              }
            ]
          }
        }
      },
      ToolsOzoneHostingGetAccountHistory: {
        lexicon: 1,
        id: "tools.ozone.hosting.getAccountHistory",
        defs: {
          main: {
            type: "query",
            description: "Get account history, e.g. log of updated email addresses or other identity information.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                events: {
                  type: "array",
                  items: {
                    type: "string",
                    knownValues: [
                      "accountCreated",
                      "emailUpdated",
                      "emailConfirmed",
                      "passwordUpdated",
                      "handleUpdated"
                    ]
                  }
                },
                cursor: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["events"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  events: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.hosting.getAccountHistory#event"
                    }
                  }
                }
              }
            }
          },
          event: {
            type: "object",
            required: ["details", "createdBy", "createdAt"],
            properties: {
              details: {
                type: "union",
                refs: [
                  "lex:tools.ozone.hosting.getAccountHistory#accountCreated",
                  "lex:tools.ozone.hosting.getAccountHistory#emailUpdated",
                  "lex:tools.ozone.hosting.getAccountHistory#emailConfirmed",
                  "lex:tools.ozone.hosting.getAccountHistory#passwordUpdated",
                  "lex:tools.ozone.hosting.getAccountHistory#handleUpdated"
                ]
              },
              createdBy: {
                type: "string"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          accountCreated: {
            type: "object",
            required: [],
            properties: {
              email: {
                type: "string"
              },
              handle: {
                type: "string",
                format: "handle"
              }
            }
          },
          emailUpdated: {
            type: "object",
            required: ["email"],
            properties: {
              email: {
                type: "string"
              }
            }
          },
          emailConfirmed: {
            type: "object",
            required: ["email"],
            properties: {
              email: {
                type: "string"
              }
            }
          },
          passwordUpdated: {
            type: "object",
            required: [],
            properties: {}
          },
          handleUpdated: {
            type: "object",
            required: ["handle"],
            properties: {
              handle: {
                type: "string",
                format: "handle"
              }
            }
          }
        }
      },
      ToolsOzoneModerationDefs: {
        lexicon: 1,
        id: "tools.ozone.moderation.defs",
        defs: {
          modEventView: {
            type: "object",
            required: [
              "id",
              "event",
              "subject",
              "subjectBlobCids",
              "createdBy",
              "createdAt"
            ],
            properties: {
              id: {
                type: "integer"
              },
              event: {
                type: "union",
                refs: [
                  "lex:tools.ozone.moderation.defs#modEventTakedown",
                  "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                  "lex:tools.ozone.moderation.defs#modEventComment",
                  "lex:tools.ozone.moderation.defs#modEventReport",
                  "lex:tools.ozone.moderation.defs#modEventLabel",
                  "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                  "lex:tools.ozone.moderation.defs#modEventEscalate",
                  "lex:tools.ozone.moderation.defs#modEventMute",
                  "lex:tools.ozone.moderation.defs#modEventUnmute",
                  "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                  "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                  "lex:tools.ozone.moderation.defs#modEventEmail",
                  "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                  "lex:tools.ozone.moderation.defs#modEventDivert",
                  "lex:tools.ozone.moderation.defs#modEventTag",
                  "lex:tools.ozone.moderation.defs#accountEvent",
                  "lex:tools.ozone.moderation.defs#identityEvent",
                  "lex:tools.ozone.moderation.defs#recordEvent",
                  "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                ]
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoRef",
                  "lex:com.atproto.repo.strongRef",
                  "lex:chat.bsky.convo.defs#messageRef"
                ]
              },
              subjectBlobCids: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              creatorHandle: {
                type: "string"
              },
              subjectHandle: {
                type: "string"
              }
            }
          },
          modEventViewDetail: {
            type: "object",
            required: [
              "id",
              "event",
              "subject",
              "subjectBlobs",
              "createdBy",
              "createdAt"
            ],
            properties: {
              id: {
                type: "integer"
              },
              event: {
                type: "union",
                refs: [
                  "lex:tools.ozone.moderation.defs#modEventTakedown",
                  "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                  "lex:tools.ozone.moderation.defs#modEventComment",
                  "lex:tools.ozone.moderation.defs#modEventReport",
                  "lex:tools.ozone.moderation.defs#modEventLabel",
                  "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                  "lex:tools.ozone.moderation.defs#modEventEscalate",
                  "lex:tools.ozone.moderation.defs#modEventMute",
                  "lex:tools.ozone.moderation.defs#modEventUnmute",
                  "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                  "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                  "lex:tools.ozone.moderation.defs#modEventEmail",
                  "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                  "lex:tools.ozone.moderation.defs#modEventDivert",
                  "lex:tools.ozone.moderation.defs#modEventTag",
                  "lex:tools.ozone.moderation.defs#accountEvent",
                  "lex:tools.ozone.moderation.defs#identityEvent",
                  "lex:tools.ozone.moderation.defs#recordEvent",
                  "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                ]
              },
              subject: {
                type: "union",
                refs: [
                  "lex:tools.ozone.moderation.defs#repoView",
                  "lex:tools.ozone.moderation.defs#repoViewNotFound",
                  "lex:tools.ozone.moderation.defs#recordView",
                  "lex:tools.ozone.moderation.defs#recordViewNotFound"
                ]
              },
              subjectBlobs: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#blobView"
                }
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          subjectStatusView: {
            type: "object",
            required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
            properties: {
              id: {
                type: "integer"
              },
              subject: {
                type: "union",
                refs: [
                  "lex:com.atproto.admin.defs#repoRef",
                  "lex:com.atproto.repo.strongRef"
                ]
              },
              hosting: {
                type: "union",
                refs: [
                  "lex:tools.ozone.moderation.defs#accountHosting",
                  "lex:tools.ozone.moderation.defs#recordHosting"
                ]
              },
              subjectBlobCids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              },
              subjectRepoHandle: {
                type: "string"
              },
              updatedAt: {
                type: "string",
                format: "datetime",
                description: "Timestamp referencing when the last update was made to the moderation status of the subject"
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
              },
              reviewState: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
              },
              comment: {
                type: "string",
                description: "Sticky comment on the subject."
              },
              priorityScore: {
                type: "integer",
                description: "Numeric value representing the level of priority. Higher score means higher priority.",
                minimum: 0,
                maximum: 100
              },
              muteUntil: {
                type: "string",
                format: "datetime"
              },
              muteReportingUntil: {
                type: "string",
                format: "datetime"
              },
              lastReviewedBy: {
                type: "string",
                format: "did"
              },
              lastReviewedAt: {
                type: "string",
                format: "datetime"
              },
              lastReportedAt: {
                type: "string",
                format: "datetime"
              },
              lastAppealedAt: {
                type: "string",
                format: "datetime",
                description: "Timestamp referencing when the author of the subject appealed a moderation action"
              },
              takendown: {
                type: "boolean"
              },
              appealed: {
                type: "boolean",
                description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
              },
              suspendUntil: {
                type: "string",
                format: "datetime"
              },
              tags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              accountStats: {
                description: "Statistics related to the account subject",
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#accountStats"
              },
              recordsStats: {
                description: "Statistics related to the record subjects authored by the subject's account",
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#recordsStats"
              }
            }
          },
          subjectView: {
            description: "Detailed view of a subject. For record subjects, the author's repo and profile will be returned.",
            type: "object",
            required: ["type", "subject"],
            properties: {
              type: {
                type: "ref",
                ref: "lex:com.atproto.moderation.defs#subjectType"
              },
              subject: {
                type: "string"
              },
              status: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
              },
              repo: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
              },
              profile: {
                type: "union",
                refs: []
              },
              record: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
              }
            }
          },
          accountStats: {
            description: "Statistics about a particular account subject",
            type: "object",
            properties: {
              reportCount: {
                description: "Total number of reports on the account",
                type: "integer"
              },
              appealCount: {
                description: "Total number of appeals against a moderation action on the account",
                type: "integer"
              },
              suspendCount: {
                description: "Number of times the account was suspended",
                type: "integer"
              },
              escalateCount: {
                description: "Number of times the account was escalated",
                type: "integer"
              },
              takedownCount: {
                description: "Number of times the account was taken down",
                type: "integer"
              }
            }
          },
          recordsStats: {
            description: "Statistics about a set of record subject items",
            type: "object",
            properties: {
              totalReports: {
                description: "Cumulative sum of the number of reports on the items in the set",
                type: "integer"
              },
              reportedCount: {
                description: "Number of items that were reported at least once",
                type: "integer"
              },
              escalatedCount: {
                description: "Number of items that were escalated at least once",
                type: "integer"
              },
              appealedCount: {
                description: "Number of items that were appealed at least once",
                type: "integer"
              },
              subjectCount: {
                description: "Total number of item in the set",
                type: "integer"
              },
              pendingCount: {
                description: 'Number of item currently in "reviewOpen" or "reviewEscalated" state',
                type: "integer"
              },
              processedCount: {
                description: 'Number of item currently in "reviewNone" or "reviewClosed" state',
                type: "integer"
              },
              takendownCount: {
                description: "Number of item currently taken down",
                type: "integer"
              }
            }
          },
          subjectReviewState: {
            type: "string",
            knownValues: [
              "lex:tools.ozone.moderation.defs#reviewOpen",
              "lex:tools.ozone.moderation.defs#reviewEscalated",
              "lex:tools.ozone.moderation.defs#reviewClosed",
              "lex:tools.ozone.moderation.defs#reviewNone"
            ]
          },
          reviewOpen: {
            type: "token",
            description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
          },
          reviewEscalated: {
            type: "token",
            description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
          },
          reviewClosed: {
            type: "token",
            description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
          },
          reviewNone: {
            type: "token",
            description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
          },
          modEventTakedown: {
            type: "object",
            description: "Take down a subject permanently or temporarily",
            properties: {
              comment: {
                type: "string"
              },
              durationInHours: {
                type: "integer",
                description: "Indicates how long the takedown should be in effect before automatically expiring."
              },
              acknowledgeAccountSubjects: {
                type: "boolean",
                description: "If true, all other reports on content authored by this account will be resolved (acknowledged)."
              },
              policies: {
                type: "array",
                maxLength: 5,
                items: {
                  type: "string"
                },
                description: "Names/Keywords of the policies that drove the decision."
              }
            }
          },
          modEventReverseTakedown: {
            type: "object",
            description: "Revert take down action on a subject",
            properties: {
              comment: {
                type: "string",
                description: "Describe reasoning behind the reversal."
              }
            }
          },
          modEventResolveAppeal: {
            type: "object",
            description: "Resolve appeal on a subject",
            properties: {
              comment: {
                type: "string",
                description: "Describe resolution."
              }
            }
          },
          modEventComment: {
            type: "object",
            description: "Add a comment to a subject. An empty comment will clear any previously set sticky comment.",
            properties: {
              comment: {
                type: "string"
              },
              sticky: {
                type: "boolean",
                description: "Make the comment persistent on the subject"
              }
            }
          },
          modEventReport: {
            type: "object",
            description: "Report a subject",
            required: ["reportType"],
            properties: {
              comment: {
                type: "string"
              },
              isReporterMuted: {
                type: "boolean",
                description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
              },
              reportType: {
                type: "ref",
                ref: "lex:com.atproto.moderation.defs#reasonType"
              }
            }
          },
          modEventLabel: {
            type: "object",
            description: "Apply/Negate labels on a subject",
            required: ["createLabelVals", "negateLabelVals"],
            properties: {
              comment: {
                type: "string"
              },
              createLabelVals: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              negateLabelVals: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              durationInHours: {
                type: "integer",
                description: "Indicates how long the label will remain on the subject. Only applies on labels that are being added."
              }
            }
          },
          modEventPriorityScore: {
            type: "object",
            description: "Set priority score of the subject. Higher score means higher priority.",
            required: ["score"],
            properties: {
              comment: {
                type: "string"
              },
              score: {
                type: "integer",
                minimum: 0,
                maximum: 100
              }
            }
          },
          modEventAcknowledge: {
            type: "object",
            properties: {
              comment: {
                type: "string"
              },
              acknowledgeAccountSubjects: {
                type: "boolean",
                description: "If true, all other reports on content authored by this account will be resolved (acknowledged)."
              }
            }
          },
          modEventEscalate: {
            type: "object",
            properties: {
              comment: {
                type: "string"
              }
            }
          },
          modEventMute: {
            type: "object",
            description: "Mute incoming reports on a subject",
            required: ["durationInHours"],
            properties: {
              comment: {
                type: "string"
              },
              durationInHours: {
                type: "integer",
                description: "Indicates how long the subject should remain muted."
              }
            }
          },
          modEventUnmute: {
            type: "object",
            description: "Unmute action on a subject",
            properties: {
              comment: {
                type: "string",
                description: "Describe reasoning behind the reversal."
              }
            }
          },
          modEventMuteReporter: {
            type: "object",
            description: "Mute incoming reports from an account",
            properties: {
              comment: {
                type: "string"
              },
              durationInHours: {
                type: "integer",
                description: "Indicates how long the account should remain muted. Falsy value here means a permanent mute."
              }
            }
          },
          modEventUnmuteReporter: {
            type: "object",
            description: "Unmute incoming reports from an account",
            properties: {
              comment: {
                type: "string",
                description: "Describe reasoning behind the reversal."
              }
            }
          },
          modEventEmail: {
            type: "object",
            description: "Keep a log of outgoing email to a user",
            required: ["subjectLine"],
            properties: {
              subjectLine: {
                type: "string",
                description: "The subject line of the email sent to the user."
              },
              content: {
                type: "string",
                description: "The content of the email sent to the user."
              },
              comment: {
                type: "string",
                description: "Additional comment about the outgoing comm."
              }
            }
          },
          modEventDivert: {
            type: "object",
            description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
            properties: {
              comment: {
                type: "string"
              }
            }
          },
          modEventTag: {
            type: "object",
            description: "Add/Remove a tag on a subject",
            required: ["add", "remove"],
            properties: {
              add: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "Tags to be added to the subject. If already exists, won't be duplicated."
              },
              remove: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
              },
              comment: {
                type: "string",
                description: "Additional comment about added/removed tags."
              }
            }
          },
          accountEvent: {
            type: "object",
            description: "Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
            required: ["timestamp", "active"],
            properties: {
              comment: {
                type: "string"
              },
              active: {
                type: "boolean",
                description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
              },
              status: {
                type: "string",
                knownValues: [
                  "unknown",
                  "deactivated",
                  "deleted",
                  "takendown",
                  "suspended",
                  "tombstoned"
                ]
              },
              timestamp: {
                type: "string",
                format: "datetime"
              }
            }
          },
          identityEvent: {
            type: "object",
            description: "Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
            required: ["timestamp"],
            properties: {
              comment: {
                type: "string"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              pdsHost: {
                type: "string",
                format: "uri"
              },
              tombstone: {
                type: "boolean"
              },
              timestamp: {
                type: "string",
                format: "datetime"
              }
            }
          },
          recordEvent: {
            type: "object",
            description: "Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
            required: ["timestamp", "op"],
            properties: {
              comment: {
                type: "string"
              },
              op: {
                type: "string",
                knownValues: ["create", "update", "delete"]
              },
              cid: {
                type: "string",
                format: "cid"
              },
              timestamp: {
                type: "string",
                format: "datetime"
              }
            }
          },
          repoView: {
            type: "object",
            required: [
              "did",
              "handle",
              "relatedRecords",
              "indexedAt",
              "moderation"
            ],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              email: {
                type: "string"
              },
              relatedRecords: {
                type: "array",
                items: {
                  type: "unknown"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#moderation"
              },
              invitedBy: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              },
              invitesDisabled: {
                type: "boolean"
              },
              inviteNote: {
                type: "string"
              },
              deactivatedAt: {
                type: "string",
                format: "datetime"
              },
              threatSignatures: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#threatSignature"
                }
              }
            }
          },
          repoViewDetail: {
            type: "object",
            required: [
              "did",
              "handle",
              "relatedRecords",
              "indexedAt",
              "moderation"
            ],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              handle: {
                type: "string",
                format: "handle"
              },
              email: {
                type: "string"
              },
              relatedRecords: {
                type: "array",
                items: {
                  type: "unknown"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#moderationDetail"
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              invitedBy: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              },
              invites: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                }
              },
              invitesDisabled: {
                type: "boolean"
              },
              inviteNote: {
                type: "string"
              },
              emailConfirmedAt: {
                type: "string",
                format: "datetime"
              },
              deactivatedAt: {
                type: "string",
                format: "datetime"
              },
              threatSignatures: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#threatSignature"
                }
              }
            }
          },
          repoViewNotFound: {
            type: "object",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          recordView: {
            type: "object",
            required: [
              "uri",
              "cid",
              "value",
              "blobCids",
              "indexedAt",
              "moderation",
              "repo"
            ],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              value: {
                type: "unknown"
              },
              blobCids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#moderation"
              },
              repo: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#repoView"
              }
            }
          },
          recordViewDetail: {
            type: "object",
            required: [
              "uri",
              "cid",
              "value",
              "blobs",
              "indexedAt",
              "moderation",
              "repo"
            ],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              },
              value: {
                type: "unknown"
              },
              blobs: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#blobView"
                }
              },
              labels: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:com.atproto.label.defs#label"
                }
              },
              indexedAt: {
                type: "string",
                format: "datetime"
              },
              moderation: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#moderationDetail"
              },
              repo: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#repoView"
              }
            }
          },
          recordViewNotFound: {
            type: "object",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              }
            }
          },
          moderation: {
            type: "object",
            properties: {
              subjectStatus: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
              }
            }
          },
          moderationDetail: {
            type: "object",
            properties: {
              subjectStatus: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
              }
            }
          },
          blobView: {
            type: "object",
            required: ["cid", "mimeType", "size", "createdAt"],
            properties: {
              cid: {
                type: "string",
                format: "cid"
              },
              mimeType: {
                type: "string"
              },
              size: {
                type: "integer"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              details: {
                type: "union",
                refs: [
                  "lex:tools.ozone.moderation.defs#imageDetails",
                  "lex:tools.ozone.moderation.defs#videoDetails"
                ]
              },
              moderation: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#moderation"
              }
            }
          },
          imageDetails: {
            type: "object",
            required: ["width", "height"],
            properties: {
              width: {
                type: "integer"
              },
              height: {
                type: "integer"
              }
            }
          },
          videoDetails: {
            type: "object",
            required: ["width", "height", "length"],
            properties: {
              width: {
                type: "integer"
              },
              height: {
                type: "integer"
              },
              length: {
                type: "integer"
              }
            }
          },
          accountHosting: {
            type: "object",
            required: ["status"],
            properties: {
              status: {
                type: "string",
                knownValues: [
                  "takendown",
                  "suspended",
                  "deleted",
                  "deactivated",
                  "unknown"
                ]
              },
              updatedAt: {
                type: "string",
                format: "datetime"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              deletedAt: {
                type: "string",
                format: "datetime"
              },
              deactivatedAt: {
                type: "string",
                format: "datetime"
              },
              reactivatedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          recordHosting: {
            type: "object",
            required: ["status"],
            properties: {
              status: {
                type: "string",
                knownValues: ["deleted", "unknown"]
              },
              updatedAt: {
                type: "string",
                format: "datetime"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              deletedAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          reporterStats: {
            type: "object",
            required: [
              "did",
              "accountReportCount",
              "recordReportCount",
              "reportedAccountCount",
              "reportedRecordCount",
              "takendownAccountCount",
              "takendownRecordCount",
              "labeledAccountCount",
              "labeledRecordCount"
            ],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              accountReportCount: {
                type: "integer",
                description: "The total number of reports made by the user on accounts."
              },
              recordReportCount: {
                type: "integer",
                description: "The total number of reports made by the user on records."
              },
              reportedAccountCount: {
                type: "integer",
                description: "The total number of accounts reported by the user."
              },
              reportedRecordCount: {
                type: "integer",
                description: "The total number of records reported by the user."
              },
              takendownAccountCount: {
                type: "integer",
                description: "The total number of accounts taken down as a result of the user's reports."
              },
              takendownRecordCount: {
                type: "integer",
                description: "The total number of records taken down as a result of the user's reports."
              },
              labeledAccountCount: {
                type: "integer",
                description: "The total number of accounts labeled as a result of the user's reports."
              },
              labeledRecordCount: {
                type: "integer",
                description: "The total number of records labeled as a result of the user's reports."
              }
            }
          }
        }
      },
      ToolsOzoneModerationEmitEvent: {
        lexicon: 1,
        id: "tools.ozone.moderation.emitEvent",
        defs: {
          main: {
            type: "procedure",
            description: "Take a moderation action on an actor.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["event", "subject", "createdBy"],
                properties: {
                  event: {
                    type: "union",
                    refs: [
                      "lex:tools.ozone.moderation.defs#modEventTakedown",
                      "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                      "lex:tools.ozone.moderation.defs#modEventEscalate",
                      "lex:tools.ozone.moderation.defs#modEventComment",
                      "lex:tools.ozone.moderation.defs#modEventLabel",
                      "lex:tools.ozone.moderation.defs#modEventReport",
                      "lex:tools.ozone.moderation.defs#modEventMute",
                      "lex:tools.ozone.moderation.defs#modEventUnmute",
                      "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                      "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                      "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                      "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                      "lex:tools.ozone.moderation.defs#modEventEmail",
                      "lex:tools.ozone.moderation.defs#modEventDivert",
                      "lex:tools.ozone.moderation.defs#modEventTag",
                      "lex:tools.ozone.moderation.defs#accountEvent",
                      "lex:tools.ozone.moderation.defs#identityEvent",
                      "lex:tools.ozone.moderation.defs#recordEvent",
                      "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                    ]
                  },
                  subject: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.admin.defs#repoRef",
                      "lex:com.atproto.repo.strongRef"
                    ]
                  },
                  subjectBlobCids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#modEventView"
              }
            },
            errors: [
              {
                name: "SubjectHasAction"
              }
            ]
          }
        }
      },
      ToolsOzoneModerationGetEvent: {
        lexicon: 1,
        id: "tools.ozone.moderation.getEvent",
        defs: {
          main: {
            type: "query",
            description: "Get details about a moderation event.",
            parameters: {
              type: "params",
              required: ["id"],
              properties: {
                id: {
                  type: "integer"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
              }
            }
          }
        }
      },
      ToolsOzoneModerationGetRecord: {
        lexicon: 1,
        id: "tools.ozone.moderation.getRecord",
        defs: {
          main: {
            type: "query",
            description: "Get details about a record.",
            parameters: {
              type: "params",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
              }
            },
            errors: [
              {
                name: "RecordNotFound"
              }
            ]
          }
        }
      },
      ToolsOzoneModerationGetRecords: {
        lexicon: 1,
        id: "tools.ozone.moderation.getRecords",
        defs: {
          main: {
            type: "query",
            description: "Get details about some records.",
            parameters: {
              type: "params",
              required: ["uris"],
              properties: {
                uris: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["records"],
                properties: {
                  records: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:tools.ozone.moderation.defs#recordViewDetail",
                        "lex:tools.ozone.moderation.defs#recordViewNotFound"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneModerationGetRepo: {
        lexicon: 1,
        id: "tools.ozone.moderation.getRepo",
        defs: {
          main: {
            type: "query",
            description: "Get details about a repository.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
              }
            },
            errors: [
              {
                name: "RepoNotFound"
              }
            ]
          }
        }
      },
      ToolsOzoneModerationGetReporterStats: {
        lexicon: 1,
        id: "tools.ozone.moderation.getReporterStats",
        defs: {
          main: {
            type: "query",
            description: "Get reporter stats for a list of users.",
            parameters: {
              type: "params",
              required: ["dids"],
              properties: {
                dids: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["stats"],
                properties: {
                  stats: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.moderation.defs#reporterStats"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneModerationGetRepos: {
        lexicon: 1,
        id: "tools.ozone.moderation.getRepos",
        defs: {
          main: {
            type: "query",
            description: "Get details about some repositories.",
            parameters: {
              type: "params",
              required: ["dids"],
              properties: {
                dids: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repos"],
                properties: {
                  repos: {
                    type: "array",
                    items: {
                      type: "union",
                      refs: [
                        "lex:tools.ozone.moderation.defs#repoViewDetail",
                        "lex:tools.ozone.moderation.defs#repoViewNotFound"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneModerationGetSubjects: {
        lexicon: 1,
        id: "tools.ozone.moderation.getSubjects",
        defs: {
          main: {
            type: "query",
            description: "Get details about subjects.",
            parameters: {
              type: "params",
              required: ["subjects"],
              properties: {
                subjects: {
                  type: "array",
                  maxLength: 100,
                  minLength: 1,
                  items: {
                    type: "string"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subjects"],
                properties: {
                  subjects: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.moderation.defs#subjectView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneModerationQueryEvents: {
        lexicon: 1,
        id: "tools.ozone.moderation.queryEvents",
        defs: {
          main: {
            type: "query",
            description: "List moderation events related to a subject.",
            parameters: {
              type: "params",
              properties: {
                types: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                sortDirection: {
                  type: "string",
                  default: "desc",
                  enum: ["asc", "desc"],
                  description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                },
                createdAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Retrieve events created after a given timestamp"
                },
                createdBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Retrieve events created before a given timestamp"
                },
                subject: {
                  type: "string",
                  format: "uri"
                },
                collections: {
                  type: "array",
                  maxLength: 20,
                  description: "If specified, only events where the subject belongs to the given collections will be returned. When subjectType is set to 'account', this will be ignored.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                subjectType: {
                  type: "string",
                  description: "If specified, only events where the subject is of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored.",
                  knownValues: ["account", "record"]
                },
                includeAllUserRecords: {
                  type: "boolean",
                  default: !1,
                  description: "If true, events on all record types (posts, lists, profile etc.) or records from given 'collections' param, owned by the did are returned."
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                hasComment: {
                  type: "boolean",
                  description: "If true, only events with comments are returned"
                },
                comment: {
                  type: "string",
                  description: "If specified, only events with comments containing the keyword are returned. Apply || separator to use multiple keywords and match using OR condition."
                },
                addedLabels: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "If specified, only events where all of these labels were added are returned"
                },
                removedLabels: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "If specified, only events where all of these labels were removed are returned"
                },
                addedTags: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "If specified, only events where all of these tags were added are returned"
                },
                removedTags: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "If specified, only events where all of these tags were removed are returned"
                },
                reportTypes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                policies: {
                  type: "array",
                  items: {
                    type: "string",
                    description: "If specified, only events where the action policies match any of the given policies are returned"
                  }
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["events"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  events: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.moderation.defs#modEventView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneModerationQueryStatuses: {
        lexicon: 1,
        id: "tools.ozone.moderation.queryStatuses",
        defs: {
          main: {
            type: "query",
            description: "View moderation statuses of subjects (record or repo).",
            parameters: {
              type: "params",
              properties: {
                queueCount: {
                  type: "integer",
                  description: "Number of queues being used by moderators. Subjects will be split among all queues."
                },
                queueIndex: {
                  type: "integer",
                  description: "Index of the queue to fetch subjects from. Works only when queueCount value is specified."
                },
                queueSeed: {
                  type: "string",
                  description: "A seeder to shuffle/balance the queue items."
                },
                includeAllUserRecords: {
                  type: "boolean",
                  description: "All subjects, or subjects from given 'collections' param, belonging to the account specified in the 'subject' param will be returned."
                },
                subject: {
                  type: "string",
                  format: "uri",
                  description: "The subject to get the status for."
                },
                comment: {
                  type: "string",
                  description: "Search subjects by keyword from comments"
                },
                reportedAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reported after a given timestamp"
                },
                reportedBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reported before a given timestamp"
                },
                reviewedAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reviewed after a given timestamp"
                },
                hostingDeletedAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects where the associated record/account was deleted after a given timestamp"
                },
                hostingDeletedBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects where the associated record/account was deleted before a given timestamp"
                },
                hostingUpdatedAfter: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects where the associated record/account was updated after a given timestamp"
                },
                hostingUpdatedBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects where the associated record/account was updated before a given timestamp"
                },
                hostingStatuses: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Search subjects by the status of the associated record/account"
                },
                reviewedBefore: {
                  type: "string",
                  format: "datetime",
                  description: "Search subjects reviewed before a given timestamp"
                },
                includeMuted: {
                  type: "boolean",
                  description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                },
                onlyMuted: {
                  type: "boolean",
                  description: "When set to true, only muted subjects and reporters will be returned."
                },
                reviewState: {
                  type: "string",
                  description: "Specify when fetching subjects in a certain state"
                },
                ignoreSubjects: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "uri"
                  }
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did",
                  description: "Get all subject statuses that were reviewed by a specific moderator"
                },
                sortField: {
                  type: "string",
                  default: "lastReportedAt",
                  enum: [
                    "lastReviewedAt",
                    "lastReportedAt",
                    "reportedRecordsCount",
                    "takendownRecordsCount",
                    "priorityScore"
                  ]
                },
                sortDirection: {
                  type: "string",
                  default: "desc",
                  enum: ["asc", "desc"]
                },
                takendown: {
                  type: "boolean",
                  description: "Get subjects that were taken down"
                },
                appealed: {
                  type: "boolean",
                  description: "Get subjects in unresolved appealed status"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                tags: {
                  type: "array",
                  maxLength: 25,
                  items: {
                    type: "string",
                    description: "Items in this array are applied with OR filters. To apply AND filter, put all tags in the same string and separate using && characters"
                  }
                },
                excludeTags: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                cursor: {
                  type: "string"
                },
                collections: {
                  type: "array",
                  maxLength: 20,
                  description: "If specified, subjects belonging to the given collections will be returned. When subjectType is set to 'account', this will be ignored.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                subjectType: {
                  type: "string",
                  description: "If specified, subjects of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored.",
                  knownValues: ["account", "record"]
                },
                minAccountSuspendCount: {
                  type: "integer",
                  description: "If specified, only subjects that belong to an account that has at least this many suspensions will be returned."
                },
                minReportedRecordsCount: {
                  type: "integer",
                  description: "If specified, only subjects that belong to an account that has at least this many reported records will be returned."
                },
                minTakendownRecordsCount: {
                  type: "integer",
                  description: "If specified, only subjects that belong to an account that has at least this many taken down records will be returned."
                },
                minPriorityScore: {
                  minimum: 0,
                  maximum: 100,
                  type: "integer",
                  description: "If specified, only subjects that have priority score value above the given value will be returned."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["subjectStatuses"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  subjectStatuses: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneModerationSearchRepos: {
        lexicon: 1,
        id: "tools.ozone.moderation.searchRepos",
        defs: {
          main: {
            type: "query",
            description: "Find repositories based on a search term.",
            parameters: {
              type: "params",
              properties: {
                term: {
                  type: "string",
                  description: "DEPRECATED: use 'q' instead"
                },
                q: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["repos"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  repos: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.moderation.defs#repoView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneServerGetConfig: {
        lexicon: 1,
        id: "tools.ozone.server.getConfig",
        defs: {
          main: {
            type: "query",
            description: "Get details about ozone's server configuration.",
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {
                  appview: {
                    type: "ref",
                    ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                  },
                  pds: {
                    type: "ref",
                    ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                  },
                  blobDivert: {
                    type: "ref",
                    ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                  },
                  chat: {
                    type: "ref",
                    ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                  },
                  viewer: {
                    type: "ref",
                    ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                  }
                }
              }
            }
          },
          serviceConfig: {
            type: "object",
            properties: {
              url: {
                type: "string",
                format: "uri"
              }
            }
          },
          viewerConfig: {
            type: "object",
            properties: {
              role: {
                type: "string",
                knownValues: [
                  "tools.ozone.team.defs#roleAdmin",
                  "tools.ozone.team.defs#roleModerator",
                  "tools.ozone.team.defs#roleTriage"
                ]
              }
            }
          }
        }
      },
      ToolsOzoneSetAddValues: {
        lexicon: 1,
        id: "tools.ozone.set.addValues",
        defs: {
          main: {
            type: "procedure",
            description: "Add values to a specific set. Attempting to add values to a set that does not exist will result in an error.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name", "values"],
                properties: {
                  name: {
                    type: "string",
                    description: "Name of the set to add values to"
                  },
                  values: {
                    type: "array",
                    minLength: 1,
                    maxLength: 1e3,
                    items: {
                      type: "string"
                    },
                    description: "Array of string values to add to the set"
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneSetDefs: {
        lexicon: 1,
        id: "tools.ozone.set.defs",
        defs: {
          set: {
            type: "object",
            required: ["name"],
            properties: {
              name: {
                type: "string",
                minLength: 3,
                maxLength: 128
              },
              description: {
                type: "string",
                maxGraphemes: 1024,
                maxLength: 10240
              }
            }
          },
          setView: {
            type: "object",
            required: ["name", "setSize", "createdAt", "updatedAt"],
            properties: {
              name: {
                type: "string",
                minLength: 3,
                maxLength: 128
              },
              description: {
                type: "string",
                maxGraphemes: 1024,
                maxLength: 10240
              },
              setSize: {
                type: "integer"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              updatedAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      },
      ToolsOzoneSetDeleteSet: {
        lexicon: 1,
        id: "tools.ozone.set.deleteSet",
        defs: {
          main: {
            type: "procedure",
            description: "Delete an entire set. Attempting to delete a set that does not exist will result in an error.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    type: "string",
                    description: "Name of the set to delete"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {}
              }
            },
            errors: [
              {
                name: "SetNotFound",
                description: "set with the given name does not exist"
              }
            ]
          }
        }
      },
      ToolsOzoneSetDeleteValues: {
        lexicon: 1,
        id: "tools.ozone.set.deleteValues",
        defs: {
          main: {
            type: "procedure",
            description: "Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["name", "values"],
                properties: {
                  name: {
                    type: "string",
                    description: "Name of the set to delete values from"
                  },
                  values: {
                    type: "array",
                    minLength: 1,
                    items: {
                      type: "string"
                    },
                    description: "Array of string values to delete from the set"
                  }
                }
              }
            },
            errors: [
              {
                name: "SetNotFound",
                description: "set with the given name does not exist"
              }
            ]
          }
        }
      },
      ToolsOzoneSetGetValues: {
        lexicon: 1,
        id: "tools.ozone.set.getValues",
        defs: {
          main: {
            type: "query",
            description: "Get a specific set and its values",
            parameters: {
              type: "params",
              required: ["name"],
              properties: {
                name: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 1e3,
                  default: 100
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["set", "values"],
                properties: {
                  set: {
                    type: "ref",
                    ref: "lex:tools.ozone.set.defs#setView"
                  },
                  values: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  cursor: {
                    type: "string"
                  }
                }
              }
            },
            errors: [
              {
                name: "SetNotFound",
                description: "set with the given name does not exist"
              }
            ]
          }
        }
      },
      ToolsOzoneSetQuerySets: {
        lexicon: 1,
        id: "tools.ozone.set.querySets",
        defs: {
          main: {
            type: "query",
            description: "Query available sets",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                namePrefix: {
                  type: "string"
                },
                sortBy: {
                  type: "string",
                  enum: ["name", "createdAt", "updatedAt"],
                  default: "name"
                },
                sortDirection: {
                  type: "string",
                  default: "asc",
                  enum: ["asc", "desc"],
                  description: "Defaults to ascending order of name field."
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["sets"],
                properties: {
                  sets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.set.defs#setView"
                    }
                  },
                  cursor: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneSetUpsertSet: {
        lexicon: 1,
        id: "tools.ozone.set.upsertSet",
        defs: {
          main: {
            type: "procedure",
            description: "Create or update set metadata",
            input: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.set.defs#set"
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.set.defs#setView"
              }
            }
          }
        }
      },
      ToolsOzoneSettingDefs: {
        lexicon: 1,
        id: "tools.ozone.setting.defs",
        defs: {
          option: {
            type: "object",
            required: [
              "key",
              "value",
              "did",
              "scope",
              "createdBy",
              "lastUpdatedBy"
            ],
            properties: {
              key: {
                type: "string",
                format: "nsid"
              },
              did: {
                type: "string",
                format: "did"
              },
              value: {
                type: "unknown"
              },
              description: {
                type: "string",
                maxGraphemes: 1024,
                maxLength: 10240
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              updatedAt: {
                type: "string",
                format: "datetime"
              },
              managerRole: {
                type: "string",
                knownValues: [
                  "tools.ozone.team.defs#roleModerator",
                  "tools.ozone.team.defs#roleTriage",
                  "tools.ozone.team.defs#roleAdmin"
                ]
              },
              scope: {
                type: "string",
                knownValues: ["instance", "personal"]
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              lastUpdatedBy: {
                type: "string",
                format: "did"
              }
            }
          }
        }
      },
      ToolsOzoneSettingListOptions: {
        lexicon: 1,
        id: "tools.ozone.setting.listOptions",
        defs: {
          main: {
            type: "query",
            description: "List settings with optional filtering",
            parameters: {
              type: "params",
              properties: {
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                },
                scope: {
                  type: "string",
                  knownValues: ["instance", "personal"],
                  default: "instance"
                },
                prefix: {
                  type: "string",
                  description: "Filter keys by prefix"
                },
                keys: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "string",
                    format: "nsid"
                  },
                  description: "Filter for only the specified keys. Ignored if prefix is provided"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["options"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  options: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.setting.defs#option"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneSettingRemoveOptions: {
        lexicon: 1,
        id: "tools.ozone.setting.removeOptions",
        defs: {
          main: {
            type: "procedure",
            description: "Delete settings by key",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["keys", "scope"],
                properties: {
                  keys: {
                    type: "array",
                    minLength: 1,
                    maxLength: 200,
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  scope: {
                    type: "string",
                    knownValues: ["instance", "personal"]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                properties: {}
              }
            }
          }
        }
      },
      ToolsOzoneSettingUpsertOption: {
        lexicon: 1,
        id: "tools.ozone.setting.upsertOption",
        defs: {
          main: {
            type: "procedure",
            description: "Create or update setting option",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["key", "scope", "value"],
                properties: {
                  key: {
                    type: "string",
                    format: "nsid"
                  },
                  scope: {
                    type: "string",
                    knownValues: ["instance", "personal"]
                  },
                  value: {
                    type: "unknown"
                  },
                  description: {
                    type: "string",
                    maxLength: 2e3
                  },
                  managerRole: {
                    type: "string",
                    knownValues: [
                      "tools.ozone.team.defs#roleModerator",
                      "tools.ozone.team.defs#roleTriage",
                      "tools.ozone.team.defs#roleAdmin"
                    ]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["option"],
                properties: {
                  option: {
                    type: "ref",
                    ref: "lex:tools.ozone.setting.defs#option"
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneSignatureDefs: {
        lexicon: 1,
        id: "tools.ozone.signature.defs",
        defs: {
          sigDetail: {
            type: "object",
            required: ["property", "value"],
            properties: {
              property: {
                type: "string"
              },
              value: {
                type: "string"
              }
            }
          }
        }
      },
      ToolsOzoneSignatureFindCorrelation: {
        lexicon: 1,
        id: "tools.ozone.signature.findCorrelation",
        defs: {
          main: {
            type: "query",
            description: "Find all correlated threat signatures between 2 or more accounts.",
            parameters: {
              type: "params",
              required: ["dids"],
              properties: {
                dids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["details"],
                properties: {
                  details: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.signature.defs#sigDetail"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneSignatureFindRelatedAccounts: {
        lexicon: 1,
        id: "tools.ozone.signature.findRelatedAccounts",
        defs: {
          main: {
            type: "query",
            description: "Get accounts that share some matching threat signatures with the root account.",
            parameters: {
              type: "params",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                cursor: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accounts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  accounts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.signature.findRelatedAccounts#relatedAccount"
                    }
                  }
                }
              }
            }
          },
          relatedAccount: {
            type: "object",
            required: ["account"],
            properties: {
              account: {
                type: "ref",
                ref: "lex:com.atproto.admin.defs#accountView"
              },
              similarities: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:tools.ozone.signature.defs#sigDetail"
                }
              }
            }
          }
        }
      },
      ToolsOzoneSignatureSearchAccounts: {
        lexicon: 1,
        id: "tools.ozone.signature.searchAccounts",
        defs: {
          main: {
            type: "query",
            description: "Search for accounts that match one or more threat signature values.",
            parameters: {
              type: "params",
              required: ["values"],
              properties: {
                values: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                cursor: {
                  type: "string"
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["accounts"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  accounts: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#accountView"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneTeamAddMember: {
        lexicon: 1,
        id: "tools.ozone.team.addMember",
        defs: {
          main: {
            type: "procedure",
            description: "Add a member to the ozone team. Requires admin role.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did", "role"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  role: {
                    type: "string",
                    knownValues: [
                      "tools.ozone.team.defs#roleAdmin",
                      "tools.ozone.team.defs#roleModerator",
                      "tools.ozone.team.defs#roleTriage"
                    ]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.team.defs#member"
              }
            },
            errors: [
              {
                name: "MemberAlreadyExists",
                description: "Member already exists in the team."
              }
            ]
          }
        }
      },
      ToolsOzoneTeamDefs: {
        lexicon: 1,
        id: "tools.ozone.team.defs",
        defs: {
          member: {
            type: "object",
            required: ["did", "role"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              disabled: {
                type: "boolean"
              },
              profile: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewDetailed"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              },
              updatedAt: {
                type: "string",
                format: "datetime"
              },
              lastUpdatedBy: {
                type: "string"
              },
              role: {
                type: "string",
                knownValues: [
                  "lex:tools.ozone.team.defs#roleAdmin",
                  "lex:tools.ozone.team.defs#roleModerator",
                  "lex:tools.ozone.team.defs#roleTriage"
                ]
              }
            }
          },
          roleAdmin: {
            type: "token",
            description: "Admin role. Highest level of access, can perform all actions."
          },
          roleModerator: {
            type: "token",
            description: "Moderator role. Can perform most actions."
          },
          roleTriage: {
            type: "token",
            description: "Triage role. Mostly intended for monitoring and escalating issues."
          }
        }
      },
      ToolsOzoneTeamDeleteMember: {
        lexicon: 1,
        id: "tools.ozone.team.deleteMember",
        defs: {
          main: {
            type: "procedure",
            description: "Delete a member from ozone team. Requires admin role.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            },
            errors: [
              {
                name: "MemberNotFound",
                description: "The member being deleted does not exist"
              },
              {
                name: "CannotDeleteSelf",
                description: "You can not delete yourself from the team"
              }
            ]
          }
        }
      },
      ToolsOzoneTeamListMembers: {
        lexicon: 1,
        id: "tools.ozone.team.listMembers",
        defs: {
          main: {
            type: "query",
            description: "List all members with access to the ozone service.",
            parameters: {
              type: "params",
              properties: {
                q: {
                  type: "string"
                },
                disabled: {
                  type: "boolean"
                },
                roles: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                limit: {
                  type: "integer",
                  minimum: 1,
                  maximum: 100,
                  default: 50
                },
                cursor: {
                  type: "string"
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["members"],
                properties: {
                  cursor: {
                    type: "string"
                  },
                  members: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:tools.ozone.team.defs#member"
                    }
                  }
                }
              }
            }
          }
        }
      },
      ToolsOzoneTeamUpdateMember: {
        lexicon: 1,
        id: "tools.ozone.team.updateMember",
        defs: {
          main: {
            type: "procedure",
            description: "Update a member in the ozone service. Requires admin role.",
            input: {
              encoding: "application/json",
              schema: {
                type: "object",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  disabled: {
                    type: "boolean"
                  },
                  role: {
                    type: "string",
                    knownValues: [
                      "tools.ozone.team.defs#roleAdmin",
                      "tools.ozone.team.defs#roleModerator",
                      "tools.ozone.team.defs#roleTriage"
                    ]
                  }
                }
              }
            },
            output: {
              encoding: "application/json",
              schema: {
                type: "ref",
                ref: "lex:tools.ozone.team.defs#member"
              }
            },
            errors: [
              {
                name: "MemberNotFound",
                description: "The member being updated does not exist in the team"
              }
            ]
          }
        }
      }
    }, r.schemas = Object.values(r.schemaDict), r.lexicons = new t.Lexicons(r.schemas);
    function n(s, o, e, l) {
      return (l ? i.is$typed : i.maybe$typed)(s, o, e) ? r.lexicons.validate(`${o}#${e}`, s) : {
        success: !1,
        error: new t.ValidationError(`Must be an object with "${e === "main" ? o : `${o}#${e}`}" $type property`)
      };
    }
    r.ids = {
      ComAtprotoAdminDefs: "com.atproto.admin.defs",
      ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
      ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
      ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
      ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
      ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
      ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
      ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
      ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
      ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
      ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
      ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
      ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
      ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
      ComAtprotoAdminUpdateAccountSigningKey: "com.atproto.admin.updateAccountSigningKey",
      ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
      ComAtprotoIdentityDefs: "com.atproto.identity.defs",
      ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
      ComAtprotoIdentityRefreshIdentity: "com.atproto.identity.refreshIdentity",
      ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
      ComAtprotoIdentityResolveDid: "com.atproto.identity.resolveDid",
      ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
      ComAtprotoIdentityResolveIdentity: "com.atproto.identity.resolveIdentity",
      ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
      ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
      ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
      ComAtprotoLabelDefs: "com.atproto.label.defs",
      ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
      ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
      ComAtprotoLexiconSchema: "com.atproto.lexicon.schema",
      ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
      ComAtprotoModerationDefs: "com.atproto.moderation.defs",
      ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
      ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
      ComAtprotoRepoDefs: "com.atproto.repo.defs",
      ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
      ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
      ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
      ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
      ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
      ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
      ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
      ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
      ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
      ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
      ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
      ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
      ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
      ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
      ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
      ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
      ComAtprotoServerCreateSession: "com.atproto.server.createSession",
      ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
      ComAtprotoServerDefs: "com.atproto.server.defs",
      ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
      ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
      ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
      ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
      ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
      ComAtprotoServerGetSession: "com.atproto.server.getSession",
      ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
      ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
      ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
      ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
      ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
      ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
      ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
      ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
      ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
      ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
      ComAtprotoSyncDefs: "com.atproto.sync.defs",
      ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
      ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
      ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
      ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
      ComAtprotoSyncGetHostStatus: "com.atproto.sync.getHostStatus",
      ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
      ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
      ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
      ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
      ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
      ComAtprotoSyncListHosts: "com.atproto.sync.listHosts",
      ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
      ComAtprotoSyncListReposByCollection: "com.atproto.sync.listReposByCollection",
      ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
      ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
      ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
      ComAtprotoTempAddReservedHandle: "com.atproto.temp.addReservedHandle",
      ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
      ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
      ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
      AppBskyActorDefs: "app.bsky.actor.defs",
      AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
      AppBskyActorGetProfile: "app.bsky.actor.getProfile",
      AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
      AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
      AppBskyActorProfile: "app.bsky.actor.profile",
      AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
      AppBskyActorSearchActors: "app.bsky.actor.searchActors",
      AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
      AppBskyEmbedDefs: "app.bsky.embed.defs",
      AppBskyEmbedExternal: "app.bsky.embed.external",
      AppBskyEmbedImages: "app.bsky.embed.images",
      AppBskyEmbedRecord: "app.bsky.embed.record",
      AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
      AppBskyEmbedVideo: "app.bsky.embed.video",
      AppBskyFeedDefs: "app.bsky.feed.defs",
      AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
      AppBskyFeedGenerator: "app.bsky.feed.generator",
      AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
      AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
      AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
      AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
      AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
      AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
      AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
      AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
      AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
      AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
      AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
      AppBskyFeedGetQuotes: "app.bsky.feed.getQuotes",
      AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
      AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
      AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
      AppBskyFeedLike: "app.bsky.feed.like",
      AppBskyFeedPost: "app.bsky.feed.post",
      AppBskyFeedPostgate: "app.bsky.feed.postgate",
      AppBskyFeedRepost: "app.bsky.feed.repost",
      AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
      AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
      AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
      AppBskyGraphBlock: "app.bsky.graph.block",
      AppBskyGraphDefs: "app.bsky.graph.defs",
      AppBskyGraphFollow: "app.bsky.graph.follow",
      AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
      AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
      AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
      AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
      AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
      AppBskyGraphGetList: "app.bsky.graph.getList",
      AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
      AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
      AppBskyGraphGetLists: "app.bsky.graph.getLists",
      AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
      AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
      AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
      AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
      AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
      AppBskyGraphList: "app.bsky.graph.list",
      AppBskyGraphListblock: "app.bsky.graph.listblock",
      AppBskyGraphListitem: "app.bsky.graph.listitem",
      AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
      AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
      AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
      AppBskyGraphSearchStarterPacks: "app.bsky.graph.searchStarterPacks",
      AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
      AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
      AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
      AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
      AppBskyGraphVerification: "app.bsky.graph.verification",
      AppBskyLabelerDefs: "app.bsky.labeler.defs",
      AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
      AppBskyLabelerService: "app.bsky.labeler.service",
      AppBskyNotificationDefs: "app.bsky.notification.defs",
      AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
      AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
      AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
      AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
      AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
      AppBskyRichtextFacet: "app.bsky.richtext.facet",
      AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
      AppBskyUnspeccedGetConfig: "app.bsky.unspecced.getConfig",
      AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
      AppBskyUnspeccedGetSuggestedFeeds: "app.bsky.unspecced.getSuggestedFeeds",
      AppBskyUnspeccedGetSuggestedFeedsSkeleton: "app.bsky.unspecced.getSuggestedFeedsSkeleton",
      AppBskyUnspeccedGetSuggestedStarterPacks: "app.bsky.unspecced.getSuggestedStarterPacks",
      AppBskyUnspeccedGetSuggestedStarterPacksSkeleton: "app.bsky.unspecced.getSuggestedStarterPacksSkeleton",
      AppBskyUnspeccedGetSuggestedUsers: "app.bsky.unspecced.getSuggestedUsers",
      AppBskyUnspeccedGetSuggestedUsersSkeleton: "app.bsky.unspecced.getSuggestedUsersSkeleton",
      AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
      AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
      AppBskyUnspeccedGetTrendingTopics: "app.bsky.unspecced.getTrendingTopics",
      AppBskyUnspeccedGetTrends: "app.bsky.unspecced.getTrends",
      AppBskyUnspeccedGetTrendsSkeleton: "app.bsky.unspecced.getTrendsSkeleton",
      AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
      AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
      AppBskyUnspeccedSearchStarterPacksSkeleton: "app.bsky.unspecced.searchStarterPacksSkeleton",
      AppBskyVideoDefs: "app.bsky.video.defs",
      AppBskyVideoGetJobStatus: "app.bsky.video.getJobStatus",
      AppBskyVideoGetUploadLimits: "app.bsky.video.getUploadLimits",
      AppBskyVideoUploadVideo: "app.bsky.video.uploadVideo",
      ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
      ChatBskyActorDefs: "chat.bsky.actor.defs",
      ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
      ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
      ChatBskyConvoAcceptConvo: "chat.bsky.convo.acceptConvo",
      ChatBskyConvoAddReaction: "chat.bsky.convo.addReaction",
      ChatBskyConvoDefs: "chat.bsky.convo.defs",
      ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
      ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
      ChatBskyConvoGetConvoAvailability: "chat.bsky.convo.getConvoAvailability",
      ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
      ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
      ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
      ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
      ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
      ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
      ChatBskyConvoRemoveReaction: "chat.bsky.convo.removeReaction",
      ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
      ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
      ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
      ChatBskyConvoUpdateAllRead: "chat.bsky.convo.updateAllRead",
      ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
      ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
      ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
      ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
      ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
      ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
      ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
      ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
      ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
      ToolsOzoneHostingGetAccountHistory: "tools.ozone.hosting.getAccountHistory",
      ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
      ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
      ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
      ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
      ToolsOzoneModerationGetRecords: "tools.ozone.moderation.getRecords",
      ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
      ToolsOzoneModerationGetReporterStats: "tools.ozone.moderation.getReporterStats",
      ToolsOzoneModerationGetRepos: "tools.ozone.moderation.getRepos",
      ToolsOzoneModerationGetSubjects: "tools.ozone.moderation.getSubjects",
      ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
      ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
      ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
      ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
      ToolsOzoneSetAddValues: "tools.ozone.set.addValues",
      ToolsOzoneSetDefs: "tools.ozone.set.defs",
      ToolsOzoneSetDeleteSet: "tools.ozone.set.deleteSet",
      ToolsOzoneSetDeleteValues: "tools.ozone.set.deleteValues",
      ToolsOzoneSetGetValues: "tools.ozone.set.getValues",
      ToolsOzoneSetQuerySets: "tools.ozone.set.querySets",
      ToolsOzoneSetUpsertSet: "tools.ozone.set.upsertSet",
      ToolsOzoneSettingDefs: "tools.ozone.setting.defs",
      ToolsOzoneSettingListOptions: "tools.ozone.setting.listOptions",
      ToolsOzoneSettingRemoveOptions: "tools.ozone.setting.removeOptions",
      ToolsOzoneSettingUpsertOption: "tools.ozone.setting.upsertOption",
      ToolsOzoneSignatureDefs: "tools.ozone.signature.defs",
      ToolsOzoneSignatureFindCorrelation: "tools.ozone.signature.findCorrelation",
      ToolsOzoneSignatureFindRelatedAccounts: "tools.ozone.signature.findRelatedAccounts",
      ToolsOzoneSignatureSearchAccounts: "tools.ozone.signature.searchAccounts",
      ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
      ToolsOzoneTeamDefs: "tools.ozone.team.defs",
      ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
      ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
      ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
    };
  }(_u)), _u;
}
var Cu = {}, Zc;
function r0() {
  return Zc || (Zc = 1, Object.defineProperty(Cu, "__esModule", { value: !0 })), Cu;
}
var An = {}, Wc;
function Kh() {
  return Wc || (Wc = 1, Object.defineProperty(An, "__esModule", { value: !0 }), An.BSKY_LABELER_DID = void 0, An.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac"), An;
}
var Tu = {}, Jc;
function Ih() {
  return Jc || (Jc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.nuxSchema = r.asDid = r.isDid = void 0, r.sanitizeMutedWordValue = s, r.savedFeedsToUriArrays = o, r.getSavedFeedType = e, r.validateSavedFeed = l, r.validateNux = f;
    const t = /* @__PURE__ */ fi(), i = _r(), n = fn();
    function s(m) {
      return m.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
    }
    function o(m) {
      const g = [], A = [];
      for (const v of m)
        v.pinned && g.push(v.value), A.push(v.value);
      return {
        pinned: g,
        saved: A
      };
    }
    function e(m) {
      switch (new n.AtUri(m).collection) {
        case "app.bsky.feed.generator":
          return "feed";
        case "app.bsky.graph.list":
          return "list";
        default:
          return "unknown";
      }
    }
    function l(m) {
      if (new i.TID(m.id), ["feed", "list"].includes(m.type)) {
        const g = new n.AtUri(m.value), A = g.collection === "app.bsky.feed.generator", v = g.collection === "app.bsky.graph.list";
        if (m.type === "feed" && !A)
          throw new Error(`Saved feed of type 'feed' must be a feed, got ${g.collection}`);
        if (m.type === "list" && !v)
          throw new Error(`Saved feed of type 'list' must be a list, got ${g.collection}`);
      }
    }
    const a = (m) => typeof m == "string" && m.startsWith("did:") && m.includes(":", 4) && m.length > 8 && m.length <= 2048;
    r.isDid = a;
    const u = (m) => {
      if ((0, r.isDid)(m))
        return m;
      throw new TypeError(`Invalid DID: ${m}`);
    };
    r.asDid = u, r.nuxSchema = t.z.object({
      id: t.z.string().max(64),
      completed: t.z.boolean(),
      data: t.z.string().max(300).optional(),
      expiresAt: t.z.string().datetime().optional()
    }).strict();
    function f(m) {
      r.nuxSchema.parse(m);
    }
  }(Tu)), Tu;
}
var y = {}, ei = {}, ti = {}, wt = {}, Su = {}, Qc;
function qu() {
  return Qc || (Qc = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.XRPCInvalidResponseError = r.XRPCError = r.XRPCResponse = r.ResponseTypeStrings = r.ResponseTypeNames = r.ResponseType = r.errorResponseBody = void 0, r.httpResponseCodeToEnum = n, r.httpResponseCodeToName = s, r.httpResponseCodeToString = o;
    const t = /* @__PURE__ */ fi();
    r.errorResponseBody = t.z.object({
      error: t.z.string().optional(),
      message: t.z.string().optional()
    });
    var i;
    (function(u) {
      u[u.Unknown = 1] = "Unknown", u[u.InvalidResponse = 2] = "InvalidResponse", u[u.Success = 200] = "Success", u[u.InvalidRequest = 400] = "InvalidRequest", u[u.AuthRequired = 401] = "AuthRequired", u[u.Forbidden = 403] = "Forbidden", u[u.XRPCNotSupported = 404] = "XRPCNotSupported", u[u.NotAcceptable = 406] = "NotAcceptable", u[u.PayloadTooLarge = 413] = "PayloadTooLarge", u[u.UnsupportedMediaType = 415] = "UnsupportedMediaType", u[u.RateLimitExceeded = 429] = "RateLimitExceeded", u[u.InternalServerError = 500] = "InternalServerError", u[u.MethodNotImplemented = 501] = "MethodNotImplemented", u[u.UpstreamFailure = 502] = "UpstreamFailure", u[u.NotEnoughResources = 503] = "NotEnoughResources", u[u.UpstreamTimeout = 504] = "UpstreamTimeout";
    })(i || (r.ResponseType = i = {}));
    function n(u) {
      return u in i ? u : u >= 100 && u < 200 ? i.XRPCNotSupported : u >= 200 && u < 300 ? i.Success : u >= 300 && u < 400 ? i.XRPCNotSupported : u >= 400 && u < 500 ? i.InvalidRequest : i.InternalServerError;
    }
    r.ResponseTypeNames = {
      [i.Unknown]: "Unknown",
      [i.InvalidResponse]: "InvalidResponse",
      [i.Success]: "Success",
      [i.InvalidRequest]: "InvalidRequest",
      [i.AuthRequired]: "AuthenticationRequired",
      [i.Forbidden]: "Forbidden",
      [i.XRPCNotSupported]: "XRPCNotSupported",
      [i.PayloadTooLarge]: "PayloadTooLarge",
      [i.UnsupportedMediaType]: "UnsupportedMediaType",
      [i.RateLimitExceeded]: "RateLimitExceeded",
      [i.InternalServerError]: "InternalServerError",
      [i.MethodNotImplemented]: "MethodNotImplemented",
      [i.UpstreamFailure]: "UpstreamFailure",
      [i.NotEnoughResources]: "NotEnoughResources",
      [i.UpstreamTimeout]: "UpstreamTimeout"
    };
    function s(u) {
      return r.ResponseTypeNames[n(u)];
    }
    r.ResponseTypeStrings = {
      [i.Unknown]: "Unknown",
      [i.InvalidResponse]: "Invalid Response",
      [i.Success]: "Success",
      [i.InvalidRequest]: "Invalid Request",
      [i.AuthRequired]: "Authentication Required",
      [i.Forbidden]: "Forbidden",
      [i.XRPCNotSupported]: "XRPC Not Supported",
      [i.PayloadTooLarge]: "Payload Too Large",
      [i.UnsupportedMediaType]: "Unsupported Media Type",
      [i.RateLimitExceeded]: "Rate Limit Exceeded",
      [i.InternalServerError]: "Internal Server Error",
      [i.MethodNotImplemented]: "Method Not Implemented",
      [i.UpstreamFailure]: "Upstream Failure",
      [i.NotEnoughResources]: "Not Enough Resources",
      [i.UpstreamTimeout]: "Upstream Timeout"
    };
    function o(u) {
      return r.ResponseTypeStrings[n(u)];
    }
    class e {
      constructor(f, m) {
        Object.defineProperty(this, "data", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: f
        }), Object.defineProperty(this, "headers", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: m
        }), Object.defineProperty(this, "success", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: !0
        });
      }
    }
    r.XRPCResponse = e;
    class l extends Error {
      constructor(f, m = s(f), g, A, v) {
        super(g || m || o(f), v), Object.defineProperty(this, "error", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: m
        }), Object.defineProperty(this, "headers", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: A
        }), Object.defineProperty(this, "success", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: !1
        }), Object.defineProperty(this, "status", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
        }), this.status = n(f);
        const R = v == null ? void 0 : v.cause;
        this.cause === void 0 && R !== void 0 && (this.cause = R);
      }
      static from(f, m) {
        if (f instanceof l)
          return f;
        const g = f instanceof Error ? f : void 0, A = f instanceof Response ? f : (f == null ? void 0 : f.response) instanceof Response ? f.response : void 0, v = (
          // Extract status code from "http-errors" like errors
          (g == null ? void 0 : g.statusCode) ?? (g == null ? void 0 : g.status) ?? // Use the status code from the response object as fallback
          (A == null ? void 0 : A.status)
        ), R = typeof v == "number" ? n(v) : m ?? i.Unknown, E = (g == null ? void 0 : g.message) ?? String(f), h = A ? Object.fromEntries(A.headers.entries()) : void 0;
        return new l(R, void 0, E, h, { cause: f });
      }
    }
    r.XRPCError = l;
    class a extends l {
      constructor(f, m, g) {
        super(i.InvalidResponse, r.ResponseTypeStrings[i.InvalidResponse], "The server gave an invalid response and may be out of date.", void 0, { cause: m }), Object.defineProperty(this, "lexiconNsid", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: f
        }), Object.defineProperty(this, "validationError", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: m
        }), Object.defineProperty(this, "responseBody", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: g
        });
      }
    }
    r.XRPCInvalidResponseError = a;
  }(Su)), Su;
}
var Yc;
function iu() {
  if (Yc) return wt;
  Yc = 1, Object.defineProperty(wt, "__esModule", { value: !0 }), wt.isErrorResponseBody = n, wt.getMethodSchemaHTTPMethod = s, wt.constructMethodCallUri = o, wt.constructMethodCallUrl = e, wt.encodeQueryParam = l, wt.constructMethodCallHeaders = a, wt.combineHeaders = u, wt.isBodyInit = m, wt.isIterable = g, wt.encodeMethodCallBody = A, wt.httpResponseBodyParse = R;
  const r = pn(), t = qu(), i = globalThis.ReadableStream || class {
    constructor() {
      throw new Error("ReadableStream is not supported in this environment");
    }
  };
  function n(E) {
    return t.errorResponseBody.safeParse(E).success;
  }
  function s(E) {
    return E.type === "procedure" ? "post" : "get";
  }
  function o(E, h, C, K) {
    return new URL(e(E, h, K), C).toString();
  }
  function e(E, h, C) {
    var F, Z;
    const K = `/xrpc/${encodeURIComponent(E)}`;
    if (!C)
      return K;
    const k = [];
    for (const [q, J] of Object.entries(C)) {
      const xe = (Z = (F = h.parameters) == null ? void 0 : F.properties) == null ? void 0 : Z[q];
      if (!xe)
        throw new Error(`Invalid query parameter: ${q}`);
      if (J !== void 0)
        if (xe.type === "array") {
          const oe = Array.isArray(J) ? J : [J];
          for (const Y of oe)
            k.push([
              q,
              l(xe.items.type, Y)
            ]);
        } else
          k.push([q, l(xe.type, J)]);
    }
    return k.length ? `${K}?${new URLSearchParams(k).toString()}` : K;
  }
  function l(E, h) {
    if (E === "string" || E === "unknown")
      return String(h);
    if (E === "float")
      return String(Number(h));
    if (E === "integer")
      return String(Number(h) | 0);
    if (E === "boolean")
      return h ? "true" : "false";
    if (E === "datetime")
      return h instanceof Date ? h.toISOString() : String(h);
    throw new Error(`Unsupported query param type: ${E}`);
  }
  function a(E, h, C) {
    const K = new Headers();
    if (C != null && C.headers)
      for (const k in C.headers) {
        if (K.has(k))
          throw new TypeError(`Duplicate header: ${k}`);
        const F = C.headers[k];
        F != null && K.set(k, F);
      }
    if (E.type === "procedure") {
      if (C != null && C.encoding)
        K.set("content-type", C.encoding);
      else if (!K.has("content-type") && typeof h < "u")
        if (h instanceof ArrayBuffer || h instanceof i || ArrayBuffer.isView(h))
          K.set("content-type", "application/octet-stream");
        else if (h instanceof FormData)
          K.set("content-type", "multipart/form-data");
        else if (h instanceof URLSearchParams)
          K.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        else if (f(h))
          K.set("content-type", h.type || "application/octet-stream");
        else if (typeof h == "string")
          K.set("content-type", "text/plain;charset=UTF-8");
        else if (g(h))
          K.set("content-type", "application/octet-stream");
        else if (typeof h == "boolean" || typeof h == "number" || typeof h == "string" || typeof h == "object")
          K.set("content-type", "application/json");
        else
          throw new t.XRPCError(t.ResponseType.InvalidRequest, `Unsupported data type: ${typeof h}`);
    }
    return K;
  }
  function u(E, h) {
    if (!h)
      return E;
    let C;
    for (const [K, k] of h) {
      if (k === void 0 || (C ?? (C = new Headers(E)), C.has(K)))
        continue;
      const F = typeof k == "function" ? k() : k;
      if (typeof F == "string")
        C.set(K, F);
      else if (F === null)
        C.delete(K);
      else
        throw new TypeError(`Invalid "${K}" header value: ${typeof F}`);
    }
    return C ?? E;
  }
  function f(E) {
    if (E == null || typeof E != "object")
      return !1;
    if (typeof Blob == "function" && E instanceof Blob)
      return !0;
    const h = E[Symbol.toStringTag];
    return h === "Blob" || h === "File" ? "stream" in E && typeof E.stream == "function" : !1;
  }
  function m(E) {
    switch (typeof E) {
      case "string":
        return !0;
      case "object":
        return E instanceof ArrayBuffer || E instanceof FormData || E instanceof URLSearchParams || E instanceof i || ArrayBuffer.isView(E) || f(E);
      default:
        return !1;
    }
  }
  function g(E) {
    return E != null && typeof E == "object" && (Symbol.iterator in E || Symbol.asyncIterator in E);
  }
  function A(E, h) {
    var k;
    const C = E.get("content-type");
    if (!C)
      return;
    if (typeof h > "u")
      throw new t.XRPCError(t.ResponseType.InvalidRequest, "A request body is expected but none was provided");
    if (m(h))
      return h instanceof FormData && C === "multipart/form-data" && E.delete("content-type"), h;
    if (g(h))
      return v(h);
    if (C.startsWith("text/"))
      return new TextEncoder().encode(String(h));
    if (C.startsWith("application/json")) {
      const F = (0, r.stringifyLex)(h);
      if (F === void 0)
        throw new t.XRPCError(t.ResponseType.InvalidRequest, "Failed to encode request body as JSON");
      return new TextEncoder().encode(F);
    }
    const K = !h || typeof h != "object" ? typeof h : h.constructor !== Object && typeof h.constructor == "function" && typeof ((k = h.constructor) == null ? void 0 : k.name) == "string" ? h.constructor.name : "object";
    throw new t.XRPCError(t.ResponseType.InvalidRequest, `Unable to encode ${K} as ${C} data`);
  }
  function v(E) {
    if ("from" in i && typeof i.from == "function")
      return i.from(E);
    throw new TypeError("ReadableStream.from() is not supported in this environment. It is required to support using iterables as the request body. Consider using a polyfill or re-write your code to use a different body type.");
  }
  function R(E, h) {
    try {
      if (E) {
        if (E.includes("application/json")) {
          const C = new TextDecoder().decode(h);
          return (0, r.jsonStringToLex)(C);
        }
        if (E.startsWith("text/"))
          return new TextDecoder().decode(h);
      }
      return h instanceof ArrayBuffer ? new Uint8Array(h) : h;
    } catch (C) {
      throw new t.XRPCError(t.ResponseType.InvalidResponse, void 0, `Failed to parse response body: ${String(C)}`, void 0, { cause: C });
    }
  }
  return wt;
}
var _n = {}, ms = {}, el;
function jh() {
  if (el) return ms;
  el = 1, Object.defineProperty(ms, "__esModule", { value: !0 }), ms.buildFetchHandler = t;
  const r = iu();
  function t(i) {
    if (typeof i == "function")
      return i;
    if (typeof i == "object" && "fetchHandler" in i)
      return i.fetchHandler.bind(i);
    const { service: n, headers: s = void 0, fetch: o = globalThis.fetch } = typeof i == "string" || i instanceof URL ? { service: i } : i;
    if (typeof o != "function")
      throw new TypeError("XrpcDispatcher requires fetch() to be available in your environment.");
    const e = s != null ? Object.entries(s) : void 0;
    return async function(l, a) {
      const u = typeof n == "function" ? n() : n, f = new URL(l, u), m = (0, r.combineHeaders)(a.headers, e);
      return o(f, { ...a, headers: m });
    };
  }
  return ms;
}
var tl;
function qh() {
  if (tl) return _n;
  tl = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.XrpcClient = void 0;
  const r = pn(), t = jh(), i = qu(), n = iu();
  class s {
    constructor(e, l) {
      Object.defineProperty(this, "fetchHandler", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /* @__PURE__ */ new Map()
      }), Object.defineProperty(this, "lex", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.fetchHandler = (0, t.buildFetchHandler)(e), this.lex = l instanceof r.Lexicons ? l : new r.Lexicons(l);
    }
    setHeader(e, l) {
      this.headers.set(e.toLowerCase(), l);
    }
    unsetHeader(e) {
      this.headers.delete(e.toLowerCase());
    }
    clearHeaders() {
      this.headers.clear();
    }
    async call(e, l, a, u) {
      const f = this.lex.getDefOrThrow(e);
      if (!f || f.type !== "query" && f.type !== "procedure")
        throw new TypeError(`Invalid lexicon: ${e}. Must be a query or procedure.`);
      const m = (0, n.constructMethodCallUrl)(e, f, l), g = (0, n.getMethodSchemaHTTPMethod)(f), A = (0, n.constructMethodCallHeaders)(f, a, u), v = (0, n.encodeMethodCallBody)(A, a), R = {
        method: g,
        headers: (0, n.combineHeaders)(A, this.headers),
        body: v,
        duplex: "half",
        signal: u == null ? void 0 : u.signal
      };
      try {
        const E = await this.fetchHandler.call(void 0, m, R), h = E.status, C = Object.fromEntries(E.headers.entries()), K = await E.arrayBuffer(), k = (0, n.httpResponseBodyParse)(E.headers.get("content-type"), K), F = (0, i.httpResponseCodeToEnum)(h);
        if (F !== i.ResponseType.Success) {
          const { error: Z = void 0, message: q = void 0 } = k && (0, n.isErrorResponseBody)(k) ? k : {};
          throw new i.XRPCError(F, Z, q, C);
        }
        try {
          this.lex.assertValidXrpcOutput(e, k);
        } catch (Z) {
          throw Z instanceof r.ValidationError ? new i.XRPCInvalidResponseError(e, Z, k) : Z;
        }
        return new i.XRPCResponse(k, C);
      } catch (E) {
        throw i.XRPCError.from(E);
      }
    }
  }
  return _n.XrpcClient = s, _n;
}
var rl;
function il() {
  if (rl) return ti;
  rl = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.ServiceClient = ti.Client = void 0;
  const r = pn(), t = iu(), i = qh();
  class n {
    constructor() {
      Object.defineProperty(this, "lex", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: new r.Lexicons()
      });
    }
    /** @deprecated */
    get fetch() {
      throw new Error("Client.fetch is no longer supported. Use an XrpcClient instead.");
    }
    /** @deprecated */
    set fetch(e) {
      throw new Error("Client.fetch is no longer supported. Use an XrpcClient instead.");
    }
    // method calls
    //
    async call(e, l, a, u, f) {
      return this.service(e).call(l, a, u, f);
    }
    service(e) {
      return new s(this, e);
    }
    // schemas
    // =
    addLexicon(e) {
      this.lex.add(e);
    }
    addLexicons(e) {
      for (const l of e)
        this.addLexicon(l);
    }
    removeLexicon(e) {
      this.lex.remove(e);
    }
  }
  ti.Client = n;
  class s extends i.XrpcClient {
    constructor(e, l) {
      super(async (a, u) => {
        const f = (0, t.combineHeaders)(u.headers, Object.entries(this.headers));
        return fetch(new URL(a, this.uri), { ...u, headers: f });
      }, e.lex), Object.defineProperty(this, "baseClient", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
      }), Object.defineProperty(this, "uri", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.uri = typeof l == "string" ? new URL(l) : l;
    }
  }
  return ti.ServiceClient = s, ti;
}
var nl;
function ce() {
  return nl || (nl = 1, function(r) {
    var t = ei && ei.__createBinding || (Object.create ? function(o, e, l, a) {
      a === void 0 && (a = l);
      var u = Object.getOwnPropertyDescriptor(e, l);
      (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
        return e[l];
      } }), Object.defineProperty(o, a, u);
    } : function(o, e, l, a) {
      a === void 0 && (a = l), o[a] = e[l];
    }), i = ei && ei.__exportStar || function(o, e) {
      for (var l in o) l !== "default" && !Object.prototype.hasOwnProperty.call(e, l) && t(e, o, l);
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), i(il(), r), i(jh(), r), i(qu(), r), i(iu(), r), i(qh(), r);
    const n = il(), s = new n.Client();
    r.default = s;
  }(ei)), ei;
}
var dr = {}, sl;
function ol() {
  if (sl) return dr;
  sl = 1, Object.defineProperty(dr, "__esModule", { value: !0 }), dr.DidDeactivatedError = dr.DidNotFoundError = dr.HandleNotFoundError = void 0, dr.toKnownErr = e;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  dr.HandleNotFoundError = n;
  class s extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  dr.DidNotFoundError = s;
  class o extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  dr.DidDeactivatedError = o;
  function e(l) {
    if (l instanceof r.XRPCError) {
      if (l.error === "HandleNotFound")
        return new n(l);
      if (l.error === "DidNotFound")
        return new s(l);
      if (l.error === "DidDeactivated")
        return new o(l);
    }
    return l;
  }
  return dr;
}
var Lr = {}, al;
function ul() {
  if (al) return Lr;
  al = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.DidDeactivatedError = Lr.DidNotFoundError = void 0, Lr.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Lr.DidNotFoundError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Lr.DidDeactivatedError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "DidNotFound")
        return new n(e);
      if (e.error === "DidDeactivated")
        return new s(e);
    }
    return e;
  }
  return Lr;
}
var vi = {}, cl;
function ll() {
  if (cl) return vi;
  cl = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.HandleNotFoundError = void 0, vi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  vi.HandleNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "HandleNotFound" ? new n(o) : o;
  }
  return vi;
}
var pr = {}, dl;
function pl() {
  if (dl) return pr;
  dl = 1, Object.defineProperty(pr, "__esModule", { value: !0 }), pr.DidDeactivatedError = pr.DidNotFoundError = pr.HandleNotFoundError = void 0, pr.toKnownErr = e;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  pr.HandleNotFoundError = n;
  class s extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  pr.DidNotFoundError = s;
  class o extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  pr.DidDeactivatedError = o;
  function e(l) {
    if (l instanceof r.XRPCError) {
      if (l.error === "HandleNotFound")
        return new n(l);
      if (l.error === "DidNotFound")
        return new s(l);
      if (l.error === "DidDeactivated")
        return new o(l);
    }
    return l;
  }
  return pr;
}
var tt = {}, fl;
function yl() {
  if (fl) return tt;
  fl = 1, Object.defineProperty(tt, "__esModule", { value: !0 }), tt.InvalidSwapError = void 0, tt.toKnownErr = l, tt.isCreate = u, tt.validateCreate = f, tt.isUpdate = g, tt.validateUpdate = A, tt.isDelete = R, tt.validateDelete = E, tt.isCreateResult = C, tt.validateCreateResult = K, tt.isUpdateResult = F, tt.validateUpdateResult = Z, tt.isDeleteResult = J, tt.validateDeleteResult = xe;
  const r = ce(), t = S(), n = w().is$typed, s = t.validate, o = "com.atproto.repo.applyWrites";
  class e extends r.XRPCError {
    constructor(Y) {
      super(Y.status, Y.error, Y.message, Y.headers, { cause: Y });
    }
  }
  tt.InvalidSwapError = e;
  function l(oe) {
    return oe instanceof r.XRPCError && oe.error === "InvalidSwap" ? new e(oe) : oe;
  }
  const a = "create";
  function u(oe) {
    return n(oe, o, a);
  }
  function f(oe) {
    return s(oe, o, a);
  }
  const m = "update";
  function g(oe) {
    return n(oe, o, m);
  }
  function A(oe) {
    return s(oe, o, m);
  }
  const v = "delete";
  function R(oe) {
    return n(oe, o, v);
  }
  function E(oe) {
    return s(oe, o, v);
  }
  const h = "createResult";
  function C(oe) {
    return n(oe, o, h);
  }
  function K(oe) {
    return s(oe, o, h);
  }
  const k = "updateResult";
  function F(oe) {
    return n(oe, o, k);
  }
  function Z(oe) {
    return s(oe, o, k);
  }
  const q = "deleteResult";
  function J(oe) {
    return n(oe, o, q);
  }
  function xe(oe) {
    return s(oe, o, q);
  }
  return tt;
}
var Ri = {}, ml;
function hl() {
  if (ml) return Ri;
  ml = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.InvalidSwapError = void 0, Ri.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ri.InvalidSwapError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "InvalidSwap" ? new n(o) : o;
  }
  return Ri;
}
var Ai = {}, bl;
function gl() {
  if (bl) return Ai;
  bl = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.InvalidSwapError = void 0, Ai.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ai.InvalidSwapError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "InvalidSwap" ? new n(o) : o;
  }
  return Ai;
}
var _i = {}, El;
function xl() {
  if (El) return _i;
  El = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.RecordNotFoundError = void 0, _i.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  _i.RecordNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "RecordNotFound" ? new n(o) : o;
  }
  return _i;
}
var Ci = {}, vl;
function Rl() {
  if (vl) return Ci;
  vl = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.InvalidSwapError = void 0, Ci.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ci.InvalidSwapError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "InvalidSwap" ? new n(o) : o;
  }
  return Ci;
}
var Gt = {}, Al;
function _l() {
  if (Al) return Gt;
  Al = 1, Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.InvalidEmailError = Gt.InvalidTokenError = Gt.ExpiredTokenError = Gt.AccountNotFoundError = void 0, Gt.toKnownErr = l;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Gt.AccountNotFoundError = n;
  class s extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Gt.ExpiredTokenError = s;
  class o extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Gt.InvalidTokenError = o;
  class e extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Gt.InvalidEmailError = e;
  function l(a) {
    if (a instanceof r.XRPCError) {
      if (a.error === "AccountNotFound")
        return new n(a);
      if (a.error === "ExpiredToken")
        return new s(a);
      if (a.error === "InvalidToken")
        return new o(a);
      if (a.error === "InvalidEmail")
        return new e(a);
    }
    return a;
  }
  return Gt;
}
var rt = {}, Cl;
function Tl() {
  if (Cl) return rt;
  Cl = 1, Object.defineProperty(rt, "__esModule", { value: !0 }), rt.IncompatibleDidDocError = rt.UnresolvableDidError = rt.UnsupportedDomainError = rt.HandleNotAvailableError = rt.InvalidInviteCodeError = rt.InvalidPasswordError = rt.InvalidHandleError = void 0, rt.toKnownErr = f;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.InvalidHandleError = n;
  class s extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.InvalidPasswordError = s;
  class o extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.InvalidInviteCodeError = o;
  class e extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.HandleNotAvailableError = e;
  class l extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.UnsupportedDomainError = l;
  class a extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.UnresolvableDidError = a;
  class u extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  rt.IncompatibleDidDocError = u;
  function f(m) {
    if (m instanceof r.XRPCError) {
      if (m.error === "InvalidHandle")
        return new n(m);
      if (m.error === "InvalidPassword")
        return new s(m);
      if (m.error === "InvalidInviteCode")
        return new o(m);
      if (m.error === "HandleNotAvailable")
        return new e(m);
      if (m.error === "UnsupportedDomain")
        return new l(m);
      if (m.error === "UnresolvableDid")
        return new a(m);
      if (m.error === "IncompatibleDidDoc")
        return new u(m);
    }
    return m;
  }
  return rt;
}
var kr = {}, Sl;
function wl() {
  if (Sl) return kr;
  Sl = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.AccountTakedownError = void 0, kr.toKnownErr = l, kr.isAppPassword = u, kr.validateAppPassword = f;
  const r = ce(), t = S(), n = w().is$typed, s = t.validate, o = "com.atproto.server.createAppPassword";
  class e extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  kr.AccountTakedownError = e;
  function l(m) {
    return m instanceof r.XRPCError && m.error === "AccountTakedown" ? new e(m) : m;
  }
  const a = "appPassword";
  function u(m) {
    return n(m, o, a);
  }
  function f(m) {
    return s(m, o, a);
  }
  return kr;
}
var Dr = {}, Ll;
function kl() {
  if (Ll) return Dr;
  Ll = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.AuthFactorTokenRequiredError = Dr.AccountTakedownError = void 0, Dr.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Dr.AccountTakedownError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Dr.AuthFactorTokenRequiredError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "AccountTakedown")
        return new n(e);
      if (e.error === "AuthFactorTokenRequired")
        return new s(e);
    }
    return e;
  }
  return Dr;
}
var Br = {}, Dl;
function Bl() {
  if (Dl) return Br;
  Dl = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.InvalidTokenError = Br.ExpiredTokenError = void 0, Br.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Br.ExpiredTokenError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Br.InvalidTokenError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "ExpiredToken")
        return new n(e);
      if (e.error === "InvalidToken")
        return new s(e);
    }
    return e;
  }
  return Br;
}
var Ti = {}, Pl;
function Ul() {
  if (Pl) return Ti;
  Pl = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.DuplicateCreateError = void 0, Ti.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ti.DuplicateCreateError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "DuplicateCreate" ? new n(o) : o;
  }
  return Ti;
}
var Si = {}, Vl;
function Kl() {
  if (Vl) return Si;
  Vl = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.BadExpirationError = void 0, Si.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Si.BadExpirationError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "BadExpiration" ? new n(o) : o;
  }
  return Si;
}
var Pr = {}, Il;
function jl() {
  if (Il) return Pr;
  Il = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.AccountTakedownError = void 0, Pr.toKnownErr = l, Pr.isAppPassword = u, Pr.validateAppPassword = f;
  const r = ce(), t = S(), n = w().is$typed, s = t.validate, o = "com.atproto.server.listAppPasswords";
  class e extends r.XRPCError {
    constructor(g) {
      super(g.status, g.error, g.message, g.headers, { cause: g });
    }
  }
  Pr.AccountTakedownError = e;
  function l(m) {
    return m instanceof r.XRPCError && m.error === "AccountTakedown" ? new e(m) : m;
  }
  const a = "appPassword";
  function u(m) {
    return n(m, o, a);
  }
  function f(m) {
    return s(m, o, a);
  }
  return Pr;
}
var wi = {}, ql;
function Ol() {
  if (ql) return wi;
  ql = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.AccountTakedownError = void 0, wi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  wi.AccountTakedownError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "AccountTakedown" ? new n(o) : o;
  }
  return wi;
}
var Ur = {}, Ml;
function Nl() {
  if (Ml) return Ur;
  Ml = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.InvalidTokenError = Ur.ExpiredTokenError = void 0, Ur.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Ur.ExpiredTokenError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Ur.InvalidTokenError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "ExpiredToken")
        return new n(e);
      if (e.error === "InvalidToken")
        return new s(e);
    }
    return e;
  }
  return Ur;
}
var fr = {}, Gl;
function Fl() {
  if (Gl) return fr;
  Gl = 1, Object.defineProperty(fr, "__esModule", { value: !0 }), fr.TokenRequiredError = fr.InvalidTokenError = fr.ExpiredTokenError = void 0, fr.toKnownErr = e;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  fr.ExpiredTokenError = n;
  class s extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  fr.InvalidTokenError = s;
  class o extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  fr.TokenRequiredError = o;
  function e(l) {
    if (l instanceof r.XRPCError) {
      if (l.error === "ExpiredToken")
        return new n(l);
      if (l.error === "InvalidToken")
        return new s(l);
      if (l.error === "TokenRequired")
        return new o(l);
    }
    return l;
  }
  return fr;
}
var Lt = {}, $l;
function zl() {
  if ($l) return Lt;
  $l = 1, Object.defineProperty(Lt, "__esModule", { value: !0 }), Lt.RepoDeactivatedError = Lt.RepoSuspendedError = Lt.RepoTakendownError = Lt.RepoNotFoundError = Lt.BlobNotFoundError = void 0, Lt.toKnownErr = a;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Lt.BlobNotFoundError = n;
  class s extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Lt.RepoNotFoundError = s;
  class o extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Lt.RepoTakendownError = o;
  class e extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Lt.RepoSuspendedError = e;
  class l extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Lt.RepoDeactivatedError = l;
  function a(u) {
    if (u instanceof r.XRPCError) {
      if (u.error === "BlobNotFound")
        return new n(u);
      if (u.error === "RepoNotFound")
        return new s(u);
      if (u.error === "RepoTakendown")
        return new o(u);
      if (u.error === "RepoSuspended")
        return new e(u);
      if (u.error === "RepoDeactivated")
        return new l(u);
    }
    return u;
  }
  return Lt;
}
var kt = {}, Xl;
function Hl() {
  if (Xl) return kt;
  Xl = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.RepoDeactivatedError = kt.RepoSuspendedError = kt.RepoTakendownError = kt.RepoNotFoundError = kt.BlockNotFoundError = void 0, kt.toKnownErr = a;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  kt.BlockNotFoundError = n;
  class s extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  kt.RepoNotFoundError = s;
  class o extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  kt.RepoTakendownError = o;
  class e extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  kt.RepoSuspendedError = e;
  class l extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  kt.RepoDeactivatedError = l;
  function a(u) {
    if (u instanceof r.XRPCError) {
      if (u.error === "BlockNotFound")
        return new n(u);
      if (u.error === "RepoNotFound")
        return new s(u);
      if (u.error === "RepoTakendown")
        return new o(u);
      if (u.error === "RepoSuspended")
        return new e(u);
      if (u.error === "RepoDeactivated")
        return new l(u);
    }
    return u;
  }
  return kt;
}
var Li = {}, Zl;
function Wl() {
  if (Zl) return Li;
  Zl = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.HeadNotFoundError = void 0, Li.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Li.HeadNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "HeadNotFound" ? new n(o) : o;
  }
  return Li;
}
var ki = {}, Jl;
function Ql() {
  if (Jl) return ki;
  Jl = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.HostNotFoundError = void 0, ki.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  ki.HostNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "HostNotFound" ? new n(o) : o;
  }
  return ki;
}
var Ft = {}, Yl;
function ed() {
  if (Yl) return Ft;
  Yl = 1, Object.defineProperty(Ft, "__esModule", { value: !0 }), Ft.RepoDeactivatedError = Ft.RepoSuspendedError = Ft.RepoTakendownError = Ft.RepoNotFoundError = void 0, Ft.toKnownErr = l;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Ft.RepoNotFoundError = n;
  class s extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Ft.RepoTakendownError = s;
  class o extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Ft.RepoSuspendedError = o;
  class e extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  Ft.RepoDeactivatedError = e;
  function l(a) {
    if (a instanceof r.XRPCError) {
      if (a.error === "RepoNotFound")
        return new n(a);
      if (a.error === "RepoTakendown")
        return new s(a);
      if (a.error === "RepoSuspended")
        return new o(a);
      if (a.error === "RepoDeactivated")
        return new e(a);
    }
    return a;
  }
  return Ft;
}
var Dt = {}, td;
function rd() {
  if (td) return Dt;
  td = 1, Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.RepoDeactivatedError = Dt.RepoSuspendedError = Dt.RepoTakendownError = Dt.RepoNotFoundError = Dt.RecordNotFoundError = void 0, Dt.toKnownErr = a;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Dt.RecordNotFoundError = n;
  class s extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Dt.RepoNotFoundError = s;
  class o extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Dt.RepoTakendownError = o;
  class e extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Dt.RepoSuspendedError = e;
  class l extends r.XRPCError {
    constructor(f) {
      super(f.status, f.error, f.message, f.headers, { cause: f });
    }
  }
  Dt.RepoDeactivatedError = l;
  function a(u) {
    if (u instanceof r.XRPCError) {
      if (u.error === "RecordNotFound")
        return new n(u);
      if (u.error === "RepoNotFound")
        return new s(u);
      if (u.error === "RepoTakendown")
        return new o(u);
      if (u.error === "RepoSuspended")
        return new e(u);
      if (u.error === "RepoDeactivated")
        return new l(u);
    }
    return u;
  }
  return Dt;
}
var $t = {}, id;
function nd() {
  if (id) return $t;
  id = 1, Object.defineProperty($t, "__esModule", { value: !0 }), $t.RepoDeactivatedError = $t.RepoSuspendedError = $t.RepoTakendownError = $t.RepoNotFoundError = void 0, $t.toKnownErr = l;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  $t.RepoNotFoundError = n;
  class s extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  $t.RepoTakendownError = s;
  class o extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  $t.RepoSuspendedError = o;
  class e extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  $t.RepoDeactivatedError = e;
  function l(a) {
    if (a instanceof r.XRPCError) {
      if (a.error === "RepoNotFound")
        return new n(a);
      if (a.error === "RepoTakendown")
        return new s(a);
      if (a.error === "RepoSuspended")
        return new o(a);
      if (a.error === "RepoDeactivated")
        return new e(a);
    }
    return a;
  }
  return $t;
}
var Di = {}, sd;
function od() {
  if (sd) return Di;
  sd = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.RepoNotFoundError = void 0, Di.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Di.RepoNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "RepoNotFound" ? new n(o) : o;
  }
  return Di;
}
var zt = {}, ad;
function ud() {
  if (ad) return zt;
  ad = 1, Object.defineProperty(zt, "__esModule", { value: !0 }), zt.RepoDeactivatedError = zt.RepoSuspendedError = zt.RepoTakendownError = zt.RepoNotFoundError = void 0, zt.toKnownErr = l;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  zt.RepoNotFoundError = n;
  class s extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  zt.RepoTakendownError = s;
  class o extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  zt.RepoSuspendedError = o;
  class e extends r.XRPCError {
    constructor(u) {
      super(u.status, u.error, u.message, u.headers, { cause: u });
    }
  }
  zt.RepoDeactivatedError = e;
  function l(a) {
    if (a instanceof r.XRPCError) {
      if (a.error === "RepoNotFound")
        return new n(a);
      if (a.error === "RepoTakendown")
        return new s(a);
      if (a.error === "RepoSuspended")
        return new o(a);
      if (a.error === "RepoDeactivated")
        return new e(a);
    }
    return a;
  }
  return zt;
}
var Bi = {}, cd;
function ld() {
  if (cd) return Bi;
  cd = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.HostBannedError = void 0, Bi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Bi.HostBannedError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "HostBanned" ? new n(o) : o;
  }
  return Bi;
}
var Vr = {}, dd;
function pd() {
  if (dd) return Vr;
  dd = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.BlockedByActorError = Vr.BlockedActorError = void 0, Vr.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Vr.BlockedActorError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Vr.BlockedByActorError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "BlockedActor")
        return new n(e);
      if (e.error === "BlockedByActor")
        return new s(e);
    }
    return e;
  }
  return Vr;
}
var Kr = {}, fd;
function yd() {
  if (fd) return Kr;
  fd = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.BlockedByActorError = Kr.BlockedActorError = void 0, Kr.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Kr.BlockedActorError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Kr.BlockedByActorError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "BlockedActor")
        return new n(e);
      if (e.error === "BlockedByActor")
        return new s(e);
    }
    return e;
  }
  return Kr;
}
var Pi = {}, md;
function hd() {
  if (md) return Pi;
  md = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.UnknownFeedError = void 0, Pi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Pi.UnknownFeedError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "UnknownFeed" ? new n(o) : o;
  }
  return Pi;
}
var Ui = {}, bd;
function gd() {
  if (bd) return Ui;
  bd = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.UnknownFeedError = void 0, Ui.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ui.UnknownFeedError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "UnknownFeed" ? new n(o) : o;
  }
  return Ui;
}
var Vi = {}, Ed;
function xd() {
  if (Ed) return Vi;
  Ed = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.UnknownListError = void 0, Vi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Vi.UnknownListError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "UnknownList" ? new n(o) : o;
  }
  return Vi;
}
var Ki = {}, vd;
function Rd() {
  if (vd) return Ki;
  vd = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.NotFoundError = void 0, Ki.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ki.NotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "NotFound" ? new n(o) : o;
  }
  return Ki;
}
var Ii = {}, Ad;
function _d() {
  if (Ad) return Ii;
  Ad = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.BadQueryStringError = void 0, Ii.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ii.BadQueryStringError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "BadQueryString" ? new n(o) : o;
  }
  return Ii;
}
var ji = {}, Cd;
function Td() {
  if (Cd) return ji;
  Cd = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.ActorNotFoundError = void 0, ji.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  ji.ActorNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "ActorNotFound" ? new n(o) : o;
  }
  return ji;
}
var qi = {}, Sd;
function wd() {
  if (Sd) return qi;
  Sd = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.BadQueryStringError = void 0, qi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  qi.BadQueryStringError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "BadQueryString" ? new n(o) : o;
  }
  return qi;
}
var Oi = {}, Ld;
function kd() {
  if (Ld) return Oi;
  Ld = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.BadQueryStringError = void 0, Oi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Oi.BadQueryStringError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "BadQueryString" ? new n(o) : o;
  }
  return Oi;
}
var Mi = {}, Dd;
function Bd() {
  if (Dd) return Mi;
  Dd = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.BadQueryStringError = void 0, Mi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Mi.BadQueryStringError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "BadQueryString" ? new n(o) : o;
  }
  return Mi;
}
var yr = {}, Pd;
function Ud() {
  if (Pd) return yr;
  Pd = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.ReactionInvalidValueError = yr.ReactionLimitReachedError = yr.ReactionMessageDeletedError = void 0, yr.toKnownErr = e;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  yr.ReactionMessageDeletedError = n;
  class s extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  yr.ReactionLimitReachedError = s;
  class o extends r.XRPCError {
    constructor(a) {
      super(a.status, a.error, a.message, a.headers, { cause: a });
    }
  }
  yr.ReactionInvalidValueError = o;
  function e(l) {
    if (l instanceof r.XRPCError) {
      if (l.error === "ReactionMessageDeleted")
        return new n(l);
      if (l.error === "ReactionLimitReached")
        return new s(l);
      if (l.error === "ReactionInvalidValue")
        return new o(l);
    }
    return l;
  }
  return yr;
}
var Ir = {}, Vd;
function Kd() {
  if (Vd) return Ir;
  Vd = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.ReactionInvalidValueError = Ir.ReactionMessageDeletedError = void 0, Ir.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Ir.ReactionMessageDeletedError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  Ir.ReactionInvalidValueError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "ReactionMessageDeleted")
        return new n(e);
      if (e.error === "ReactionInvalidValue")
        return new s(e);
    }
    return e;
  }
  return Ir;
}
var Ni = {}, Id;
function jd() {
  if (Id) return Ni;
  Id = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.DuplicateTemplateNameError = void 0, Ni.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ni.DuplicateTemplateNameError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "DuplicateTemplateName" ? new n(o) : o;
  }
  return Ni;
}
var Gi = {}, qd;
function Od() {
  if (qd) return Gi;
  qd = 1, Object.defineProperty(Gi, "__esModule", { value: !0 }), Gi.DuplicateTemplateNameError = void 0, Gi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Gi.DuplicateTemplateNameError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "DuplicateTemplateName" ? new n(o) : o;
  }
  return Gi;
}
var Fi = {}, Md;
function Nd() {
  if (Md) return Fi;
  Md = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.SubjectHasActionError = void 0, Fi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Fi.SubjectHasActionError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "SubjectHasAction" ? new n(o) : o;
  }
  return Fi;
}
var $i = {}, Gd;
function Fd() {
  if (Gd) return $i;
  Gd = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.RecordNotFoundError = void 0, $i.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  $i.RecordNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "RecordNotFound" ? new n(o) : o;
  }
  return $i;
}
var zi = {}, $d;
function zd() {
  if ($d) return zi;
  $d = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.RepoNotFoundError = void 0, zi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  zi.RepoNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "RepoNotFound" ? new n(o) : o;
  }
  return zi;
}
var Xi = {}, Xd;
function Hd() {
  if (Xd) return Xi;
  Xd = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.SetNotFoundError = void 0, Xi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Xi.SetNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "SetNotFound" ? new n(o) : o;
  }
  return Xi;
}
var Hi = {}, Zd;
function Wd() {
  if (Zd) return Hi;
  Zd = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.SetNotFoundError = void 0, Hi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Hi.SetNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "SetNotFound" ? new n(o) : o;
  }
  return Hi;
}
var Zi = {}, Jd;
function Qd() {
  if (Jd) return Zi;
  Jd = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.SetNotFoundError = void 0, Zi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Zi.SetNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "SetNotFound" ? new n(o) : o;
  }
  return Zi;
}
var Wi = {}, Yd;
function ep() {
  if (Yd) return Wi;
  Yd = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.MemberAlreadyExistsError = void 0, Wi.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Wi.MemberAlreadyExistsError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "MemberAlreadyExists" ? new n(o) : o;
  }
  return Wi;
}
var jr = {}, tp;
function rp() {
  if (tp) return jr;
  tp = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.CannotDeleteSelfError = jr.MemberNotFoundError = void 0, jr.toKnownErr = o;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  jr.MemberNotFoundError = n;
  class s extends r.XRPCError {
    constructor(l) {
      super(l.status, l.error, l.message, l.headers, { cause: l });
    }
  }
  jr.CannotDeleteSelfError = s;
  function o(e) {
    if (e instanceof r.XRPCError) {
      if (e.error === "MemberNotFound")
        return new n(e);
      if (e.error === "CannotDeleteSelf")
        return new s(e);
    }
    return e;
  }
  return jr;
}
var Ji = {}, ip;
function np() {
  if (ip) return Ji;
  ip = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.MemberNotFoundError = void 0, Ji.toKnownErr = s;
  const r = ce(), t = S();
  w().is$typed, t.validate;
  class n extends r.XRPCError {
    constructor(e) {
      super(e.status, e.error, e.message, e.headers, { cause: e });
    }
  }
  Ji.MemberNotFoundError = n;
  function s(o) {
    return o instanceof r.XRPCError && o.error === "MemberNotFound" ? new n(o) : o;
  }
  return Ji;
}
var jt = {}, sp;
function i0() {
  if (sp) return jt;
  sp = 1, Object.defineProperty(jt, "__esModule", { value: !0 }), jt.isStatusAttr = e, jt.validateStatusAttr = l, jt.isAccountView = u, jt.validateAccountView = f, jt.isRepoRef = g, jt.validateRepoRef = A, jt.isRepoBlobRef = R, jt.validateRepoBlobRef = E, jt.isThreatSignature = C, jt.validateThreatSignature = K;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.admin.defs", o = "statusAttr";
  function e(k) {
    return i(k, s, o);
  }
  function l(k) {
    return n(k, s, o);
  }
  const a = "accountView";
  function u(k) {
    return i(k, s, a);
  }
  function f(k) {
    return n(k, s, a);
  }
  const m = "repoRef";
  function g(k) {
    return i(k, s, m);
  }
  function A(k) {
    return n(k, s, m);
  }
  const v = "repoBlobRef";
  function R(k) {
    return i(k, s, v);
  }
  function E(k) {
    return n(k, s, v);
  }
  const h = "threatSignature";
  function C(k) {
    return i(k, s, h);
  }
  function K(k) {
    return n(k, s, h);
  }
  return jt;
}
var hs = {}, op;
function n0() {
  if (op) return hs;
  op = 1, Object.defineProperty(hs, "__esModule", { value: !0 }), hs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return hs;
}
var bs = {}, ap;
function s0() {
  if (ap) return bs;
  ap = 1, Object.defineProperty(bs, "__esModule", { value: !0 }), bs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return bs;
}
var gs = {}, up;
function o0() {
  if (up) return gs;
  up = 1, Object.defineProperty(gs, "__esModule", { value: !0 }), gs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return gs;
}
var Es = {}, cp;
function a0() {
  if (cp) return Es;
  cp = 1, Object.defineProperty(Es, "__esModule", { value: !0 }), Es.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Es;
}
var xs = {}, lp;
function u0() {
  if (lp) return xs;
  lp = 1, Object.defineProperty(xs, "__esModule", { value: !0 }), xs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return xs;
}
var vs = {}, dp;
function c0() {
  if (dp) return vs;
  dp = 1, Object.defineProperty(vs, "__esModule", { value: !0 }), vs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return vs;
}
var Rs = {}, pp;
function l0() {
  if (pp) return Rs;
  pp = 1, Object.defineProperty(Rs, "__esModule", { value: !0 }), Rs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Rs;
}
var As = {}, fp;
function d0() {
  if (fp) return As;
  fp = 1, Object.defineProperty(As, "__esModule", { value: !0 }), As.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return As;
}
var _s = {}, yp;
function p0() {
  if (yp) return _s;
  yp = 1, Object.defineProperty(_s, "__esModule", { value: !0 }), _s.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return _s;
}
var Cs = {}, mp;
function f0() {
  if (mp) return Cs;
  mp = 1, Object.defineProperty(Cs, "__esModule", { value: !0 }), Cs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Cs;
}
var Ts = {}, hp;
function y0() {
  if (hp) return Ts;
  hp = 1, Object.defineProperty(Ts, "__esModule", { value: !0 }), Ts.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ts;
}
var Ss = {}, bp;
function m0() {
  if (bp) return Ss;
  bp = 1, Object.defineProperty(Ss, "__esModule", { value: !0 }), Ss.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ss;
}
var ws = {}, gp;
function h0() {
  if (gp) return ws;
  gp = 1, Object.defineProperty(ws, "__esModule", { value: !0 }), ws.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return ws;
}
var Ls = {}, Ep;
function b0() {
  if (Ep) return Ls;
  Ep = 1, Object.defineProperty(Ls, "__esModule", { value: !0 }), Ls.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ls;
}
var ks = {}, xp;
function g0() {
  if (xp) return ks;
  xp = 1, Object.defineProperty(ks, "__esModule", { value: !0 }), ks.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return ks;
}
var Cn = {}, vp;
function E0() {
  if (vp) return Cn;
  vp = 1, Object.defineProperty(Cn, "__esModule", { value: !0 }), Cn.isIdentityInfo = e, Cn.validateIdentityInfo = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.identity.defs", o = "identityInfo";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o);
  }
  return Cn;
}
var Ds = {}, Rp;
function x0() {
  if (Rp) return Ds;
  Rp = 1, Object.defineProperty(Ds, "__esModule", { value: !0 }), Ds.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ds;
}
var Bs = {}, Ap;
function v0() {
  if (Ap) return Bs;
  Ap = 1, Object.defineProperty(Bs, "__esModule", { value: !0 }), Bs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Bs;
}
var Ps = {}, _p;
function R0() {
  if (_p) return Ps;
  _p = 1, Object.defineProperty(Ps, "__esModule", { value: !0 }), Ps.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ps;
}
var Us = {}, Cp;
function A0() {
  if (Cp) return Us;
  Cp = 1, Object.defineProperty(Us, "__esModule", { value: !0 }), Us.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Us;
}
var Vs = {}, Tp;
function _0() {
  if (Tp) return Vs;
  Tp = 1, Object.defineProperty(Vs, "__esModule", { value: !0 }), Vs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Vs;
}
var qt = {}, Sp;
function C0() {
  if (Sp) return qt;
  Sp = 1, Object.defineProperty(qt, "__esModule", { value: !0 }), qt.isLabel = e, qt.validateLabel = l, qt.isSelfLabels = u, qt.validateSelfLabels = f, qt.isSelfLabel = g, qt.validateSelfLabel = A, qt.isLabelValueDefinition = R, qt.validateLabelValueDefinition = E, qt.isLabelValueDefinitionStrings = C, qt.validateLabelValueDefinitionStrings = K;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.label.defs", o = "label";
  function e(k) {
    return i(k, s, o);
  }
  function l(k) {
    return n(k, s, o);
  }
  const a = "selfLabels";
  function u(k) {
    return i(k, s, a);
  }
  function f(k) {
    return n(k, s, a);
  }
  const m = "selfLabel";
  function g(k) {
    return i(k, s, m);
  }
  function A(k) {
    return n(k, s, m);
  }
  const v = "labelValueDefinition";
  function R(k) {
    return i(k, s, v);
  }
  function E(k) {
    return n(k, s, v);
  }
  const h = "labelValueDefinitionStrings";
  function C(k) {
    return i(k, s, h);
  }
  function K(k) {
    return n(k, s, h);
  }
  return qt;
}
var Ks = {}, wp;
function T0() {
  if (wp) return Ks;
  wp = 1, Object.defineProperty(Ks, "__esModule", { value: !0 }), Ks.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ks;
}
var ri = {}, Lp;
function S0() {
  if (Lp) return ri;
  Lp = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.isLabels = e, ri.validateLabels = l, ri.isInfo = u, ri.validateInfo = f;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.label.subscribeLabels", o = "labels";
  function e(m) {
    return i(m, s, o);
  }
  function l(m) {
    return n(m, s, o);
  }
  const a = "info";
  function u(m) {
    return i(m, s, a);
  }
  function f(m) {
    return n(m, s, a);
  }
  return ri;
}
var Tn = {}, kp;
function w0() {
  if (kp) return Tn;
  kp = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.isRecord = e, Tn.validateRecord = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.lexicon.schema", o = "main";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o, !0);
  }
  return Tn;
}
var Is = {}, Dp;
function L0() {
  if (Dp) return Is;
  Dp = 1, Object.defineProperty(Is, "__esModule", { value: !0 }), Is.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Is;
}
var at = {}, Bp;
function k0() {
  if (Bp) return at;
  Bp = 1, Object.defineProperty(at, "__esModule", { value: !0 }), at.REASONAPPEAL = at.REASONOTHER = at.REASONRUDE = at.REASONSEXUAL = at.REASONMISLEADING = at.REASONVIOLATION = at.REASONSPAM = void 0;
  const r = S();
  w().is$typed, r.validate;
  const i = "com.atproto.moderation.defs";
  return at.REASONSPAM = `${i}#reasonSpam`, at.REASONVIOLATION = `${i}#reasonViolation`, at.REASONMISLEADING = `${i}#reasonMisleading`, at.REASONSEXUAL = `${i}#reasonSexual`, at.REASONRUDE = `${i}#reasonRude`, at.REASONOTHER = `${i}#reasonOther`, at.REASONAPPEAL = `${i}#reasonAppeal`, at;
}
var Sn = {}, Pp;
function D0() {
  if (Pp) return Sn;
  Pp = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.isCommitMeta = e, Sn.validateCommitMeta = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.repo.defs", o = "commitMeta";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o);
  }
  return Sn;
}
var js = {}, Up;
function B0() {
  if (Up) return js;
  Up = 1, Object.defineProperty(js, "__esModule", { value: !0 }), js.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return js;
}
var qs = {}, Vp;
function P0() {
  if (Vp) return qs;
  Vp = 1, Object.defineProperty(qs, "__esModule", { value: !0 }), qs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return qs;
}
var Qi = {}, Kp;
function U0() {
  if (Kp) return Qi;
  Kp = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.toKnownErr = o, Qi.isRecordBlob = l, Qi.validateRecordBlob = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.repo.listMissingBlobs";
  function o(u) {
    return u;
  }
  const e = "recordBlob";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return Qi;
}
var Yi = {}, Ip;
function V0() {
  if (Ip) return Yi;
  Ip = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.toKnownErr = o, Yi.isRecord = l, Yi.validateRecord = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.repo.listRecords";
  function o(u) {
    return u;
  }
  const e = "record";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return Yi;
}
var wn = {}, jp;
function K0() {
  if (jp) return wn;
  jp = 1, Object.defineProperty(wn, "__esModule", { value: !0 }), wn.isMain = e, wn.validateMain = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.repo.strongRef", o = "main";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o);
  }
  return wn;
}
var Os = {}, qp;
function I0() {
  if (qp) return Os;
  qp = 1, Object.defineProperty(Os, "__esModule", { value: !0 }), Os.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Os;
}
var Ms = {}, Op;
function j0() {
  if (Op) return Ms;
  Op = 1, Object.defineProperty(Ms, "__esModule", { value: !0 }), Ms.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ms;
}
var Ns = {}, Mp;
function q0() {
  if (Mp) return Ns;
  Mp = 1, Object.defineProperty(Ns, "__esModule", { value: !0 }), Ns.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ns;
}
var Gs = {}, Np;
function O0() {
  if (Np) return Gs;
  Np = 1, Object.defineProperty(Gs, "__esModule", { value: !0 }), Gs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Gs;
}
var en = {}, Gp;
function M0() {
  if (Gp) return en;
  Gp = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.toKnownErr = o, en.isAccountCodes = l, en.validateAccountCodes = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.server.createInviteCodes";
  function o(u) {
    return u;
  }
  const e = "accountCodes";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return en;
}
var Fs = {}, Fp;
function N0() {
  if (Fp) return Fs;
  Fp = 1, Object.defineProperty(Fs, "__esModule", { value: !0 }), Fs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Fs;
}
var ii = {}, $p;
function G0() {
  if ($p) return ii;
  $p = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.isInviteCode = e, ii.validateInviteCode = l, ii.isInviteCodeUse = u, ii.validateInviteCodeUse = f;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.server.defs", o = "inviteCode";
  function e(m) {
    return i(m, s, o);
  }
  function l(m) {
    return n(m, s, o);
  }
  const a = "inviteCodeUse";
  function u(m) {
    return i(m, s, a);
  }
  function f(m) {
    return n(m, s, a);
  }
  return ii;
}
var $s = {}, zp;
function F0() {
  if (zp) return $s;
  zp = 1, Object.defineProperty($s, "__esModule", { value: !0 }), $s.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return $s;
}
var qr = {}, Xp;
function $0() {
  if (Xp) return qr;
  Xp = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.toKnownErr = o, qr.isLinks = l, qr.validateLinks = a, qr.isContact = f, qr.validateContact = m;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.server.describeServer";
  function o(g) {
    return g;
  }
  const e = "links";
  function l(g) {
    return i(g, s, e);
  }
  function a(g) {
    return n(g, s, e);
  }
  const u = "contact";
  function f(g) {
    return i(g, s, u);
  }
  function m(g) {
    return n(g, s, u);
  }
  return qr;
}
var zs = {}, Hp;
function z0() {
  if (Hp) return zs;
  Hp = 1, Object.defineProperty(zs, "__esModule", { value: !0 }), zs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return zs;
}
var Xs = {}, Zp;
function X0() {
  if (Zp) return Xs;
  Zp = 1, Object.defineProperty(Xs, "__esModule", { value: !0 }), Xs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Xs;
}
var Hs = {}, Wp;
function H0() {
  if (Wp) return Hs;
  Wp = 1, Object.defineProperty(Hs, "__esModule", { value: !0 }), Hs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Hs;
}
var Zs = {}, Jp;
function Z0() {
  if (Jp) return Zs;
  Jp = 1, Object.defineProperty(Zs, "__esModule", { value: !0 }), Zs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Zs;
}
var Ws = {}, Qp;
function W0() {
  if (Qp) return Ws;
  Qp = 1, Object.defineProperty(Ws, "__esModule", { value: !0 }), Ws.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ws;
}
var Js = {}, Yp;
function J0() {
  if (Yp) return Js;
  Yp = 1, Object.defineProperty(Js, "__esModule", { value: !0 }), Js.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Js;
}
var Qs = {}, ef;
function Q0() {
  if (ef) return Qs;
  ef = 1, Object.defineProperty(Qs, "__esModule", { value: !0 }), Qs.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Qs;
}
var wu = {}, tf;
function Y0() {
  if (tf) return wu;
  tf = 1, Object.defineProperty(wu, "__esModule", { value: !0 });
  const r = S();
  return w().is$typed, r.validate, wu;
}
var Ys = {}, rf;
function eE() {
  if (rf) return Ys;
  rf = 1, Object.defineProperty(Ys, "__esModule", { value: !0 }), Ys.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Ys;
}
var tn = {}, nf;
function tE() {
  if (nf) return tn;
  nf = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.toKnownErr = o, tn.isHost = l, tn.validateHost = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.sync.listHosts";
  function o(u) {
    return u;
  }
  const e = "host";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return tn;
}
var rn = {}, sf;
function rE() {
  if (sf) return rn;
  sf = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.toKnownErr = o, rn.isRepo = l, rn.validateRepo = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.sync.listRepos";
  function o(u) {
    return u;
  }
  const e = "repo";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return rn;
}
var nn = {}, of;
function iE() {
  if (of) return nn;
  of = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.toKnownErr = o, nn.isRepo = l, nn.validateRepo = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.sync.listReposByCollection";
  function o(u) {
    return u;
  }
  const e = "repo";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return nn;
}
var eo = {}, af;
function nE() {
  if (af) return eo;
  af = 1, Object.defineProperty(eo, "__esModule", { value: !0 }), eo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return eo;
}
var Et = {}, uf;
function sE() {
  if (uf) return Et;
  uf = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.isCommit = e, Et.validateCommit = l, Et.isSync = u, Et.validateSync = f, Et.isIdentity = g, Et.validateIdentity = A, Et.isAccount = R, Et.validateAccount = E, Et.isInfo = C, Et.validateInfo = K, Et.isRepoOp = F, Et.validateRepoOp = Z;
  const r = S(), i = w().is$typed, n = r.validate, s = "com.atproto.sync.subscribeRepos", o = "commit";
  function e(q) {
    return i(q, s, o);
  }
  function l(q) {
    return n(q, s, o);
  }
  const a = "sync";
  function u(q) {
    return i(q, s, a);
  }
  function f(q) {
    return n(q, s, a);
  }
  const m = "identity";
  function g(q) {
    return i(q, s, m);
  }
  function A(q) {
    return n(q, s, m);
  }
  const v = "account";
  function R(q) {
    return i(q, s, v);
  }
  function E(q) {
    return n(q, s, v);
  }
  const h = "info";
  function C(q) {
    return i(q, s, h);
  }
  function K(q) {
    return n(q, s, h);
  }
  const k = "repoOp";
  function F(q) {
    return i(q, s, k);
  }
  function Z(q) {
    return n(q, s, k);
  }
  return Et;
}
var to = {}, cf;
function oE() {
  if (cf) return to;
  cf = 1, Object.defineProperty(to, "__esModule", { value: !0 }), to.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return to;
}
var ro = {}, lf;
function aE() {
  if (lf) return ro;
  lf = 1, Object.defineProperty(ro, "__esModule", { value: !0 }), ro.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return ro;
}
var io = {}, df;
function uE() {
  if (df) return io;
  df = 1, Object.defineProperty(io, "__esModule", { value: !0 }), io.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return io;
}
var no = {}, pf;
function cE() {
  if (pf) return no;
  pf = 1, Object.defineProperty(no, "__esModule", { value: !0 }), no.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return no;
}
var ue = {}, ff;
function lE() {
  if (ff) return ue;
  ff = 1, Object.defineProperty(ue, "__esModule", { value: !0 }), ue.isProfileViewBasic = e, ue.validateProfileViewBasic = l, ue.isProfileView = u, ue.validateProfileView = f, ue.isProfileViewDetailed = g, ue.validateProfileViewDetailed = A, ue.isProfileAssociated = R, ue.validateProfileAssociated = E, ue.isProfileAssociatedChat = C, ue.validateProfileAssociatedChat = K, ue.isViewerState = F, ue.validateViewerState = Z, ue.isKnownFollowers = J, ue.validateKnownFollowers = xe, ue.isVerificationState = Y, ue.validateVerificationState = T, ue.isVerificationView = U, ue.validateVerificationView = D, ue.isAdultContentPref = ae, ue.validateAdultContentPref = le, ue.isContentLabelPref = ze, ue.validateContentLabelPref = Ce, ue.isSavedFeed = Ie, ue.validateSavedFeed = je, ue.isSavedFeedsPrefV2 = Xe, ue.validateSavedFeedsPrefV2 = Je, ue.isSavedFeedsPref = Ge, ue.validateSavedFeedsPref = Fe, ue.isPersonalDetailsPref = Oe, ue.validatePersonalDetailsPref = it, ue.isFeedViewPref = Qe, ue.validateFeedViewPref = be, ue.isThreadViewPref = Pe, ue.validateThreadViewPref = nt, ue.isInterestsPref = st, ue.validateInterestsPref = Ve, ue.isMutedWord = dt, ue.validateMutedWord = Ye, ue.isMutedWordsPref = pt, ue.validateMutedWordsPref = ft, ue.isHiddenPostsPref = et, ue.validateHiddenPostsPref = yt, ue.isLabelersPref = $e, ue.validateLabelersPref = He, ue.isLabelerPrefItem = _t, ue.validateLabelerPrefItem = Ct, ue.isBskyAppStatePref = Tt, ue.validateBskyAppStatePref = ht, ue.isBskyAppProgressGuide = Pt, ue.validateBskyAppProgressGuide = Ut, ue.isNux = or, ue.validateNux = Nt, ue.isVerificationPrefs = Xt, ue.validateVerificationPrefs = Ht, ue.isPostInteractionSettingsPref = ar, ue.validatePostInteractionSettingsPref = Zt;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.actor.defs", o = "profileViewBasic";
  function e(O) {
    return i(O, s, o);
  }
  function l(O) {
    return n(O, s, o);
  }
  const a = "profileView";
  function u(O) {
    return i(O, s, a);
  }
  function f(O) {
    return n(O, s, a);
  }
  const m = "profileViewDetailed";
  function g(O) {
    return i(O, s, m);
  }
  function A(O) {
    return n(O, s, m);
  }
  const v = "profileAssociated";
  function R(O) {
    return i(O, s, v);
  }
  function E(O) {
    return n(O, s, v);
  }
  const h = "profileAssociatedChat";
  function C(O) {
    return i(O, s, h);
  }
  function K(O) {
    return n(O, s, h);
  }
  const k = "viewerState";
  function F(O) {
    return i(O, s, k);
  }
  function Z(O) {
    return n(O, s, k);
  }
  const q = "knownFollowers";
  function J(O) {
    return i(O, s, q);
  }
  function xe(O) {
    return n(O, s, q);
  }
  const oe = "verificationState";
  function Y(O) {
    return i(O, s, oe);
  }
  function T(O) {
    return n(O, s, oe);
  }
  const V = "verificationView";
  function U(O) {
    return i(O, s, V);
  }
  function D(O) {
    return n(O, s, V);
  }
  const N = "adultContentPref";
  function ae(O) {
    return i(O, s, N);
  }
  function le(O) {
    return n(O, s, N);
  }
  const he = "contentLabelPref";
  function ze(O) {
    return i(O, s, he);
  }
  function Ce(O) {
    return n(O, s, he);
  }
  const Be = "savedFeed";
  function Ie(O) {
    return i(O, s, Be);
  }
  function je(O) {
    return n(O, s, Be);
  }
  const qe = "savedFeedsPrefV2";
  function Xe(O) {
    return i(O, s, qe);
  }
  function Je(O) {
    return n(O, s, qe);
  }
  const ke = "savedFeedsPref";
  function Ge(O) {
    return i(O, s, ke);
  }
  function Fe(O) {
    return n(O, s, ke);
  }
  const Se = "personalDetailsPref";
  function Oe(O) {
    return i(O, s, Se);
  }
  function it(O) {
    return n(O, s, Se);
  }
  const Te = "feedViewPref";
  function Qe(O) {
    return i(O, s, Te);
  }
  function be(O) {
    return n(O, s, Te);
  }
  const we = "threadViewPref";
  function Pe(O) {
    return i(O, s, we);
  }
  function nt(O) {
    return n(O, s, we);
  }
  const Ue = "interestsPref";
  function st(O) {
    return i(O, s, Ue);
  }
  function Ve(O) {
    return n(O, s, Ue);
  }
  const X = "mutedWord";
  function dt(O) {
    return i(O, s, X);
  }
  function Ye(O) {
    return n(O, s, X);
  }
  const z = "mutedWordsPref";
  function pt(O) {
    return i(O, s, z);
  }
  function ft(O) {
    return n(O, s, z);
  }
  const Bt = "hiddenPostsPref";
  function et(O) {
    return i(O, s, Bt);
  }
  function yt(O) {
    return n(O, s, Bt);
  }
  const ot = "labelersPref";
  function $e(O) {
    return i(O, s, ot);
  }
  function He(O) {
    return n(O, s, ot);
  }
  const Ze = "labelerPrefItem";
  function _t(O) {
    return i(O, s, Ze);
  }
  function Ct(O) {
    return n(O, s, Ze);
  }
  const mt = "bskyAppStatePref";
  function Tt(O) {
    return i(O, s, mt);
  }
  function ht(O) {
    return n(O, s, mt);
  }
  const Me = "bskyAppProgressGuide";
  function Pt(O) {
    return i(O, s, Me);
  }
  function Ut(O) {
    return n(O, s, Me);
  }
  const se = "nux";
  function or(O) {
    return i(O, s, se);
  }
  function Nt(O) {
    return n(O, s, se);
  }
  const Vt = "verificationPrefs";
  function Xt(O) {
    return i(O, s, Vt);
  }
  function Ht(O) {
    return n(O, s, Vt);
  }
  const Kt = "postInteractionSettingsPref";
  function ar(O) {
    return i(O, s, Kt);
  }
  function Zt(O) {
    return n(O, s, Kt);
  }
  return ue;
}
var so = {}, yf;
function dE() {
  if (yf) return so;
  yf = 1, Object.defineProperty(so, "__esModule", { value: !0 }), so.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return so;
}
var oo = {}, mf;
function pE() {
  if (mf) return oo;
  mf = 1, Object.defineProperty(oo, "__esModule", { value: !0 }), oo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return oo;
}
var ao = {}, hf;
function fE() {
  if (hf) return ao;
  hf = 1, Object.defineProperty(ao, "__esModule", { value: !0 }), ao.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return ao;
}
var uo = {}, bf;
function yE() {
  if (bf) return uo;
  bf = 1, Object.defineProperty(uo, "__esModule", { value: !0 }), uo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return uo;
}
var Ln = {}, gf;
function mE() {
  if (gf) return Ln;
  gf = 1, Object.defineProperty(Ln, "__esModule", { value: !0 }), Ln.isRecord = e, Ln.validateRecord = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.actor.profile", o = "main";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o, !0);
  }
  return Ln;
}
var co = {}, Ef;
function hE() {
  if (Ef) return co;
  Ef = 1, Object.defineProperty(co, "__esModule", { value: !0 }), co.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return co;
}
var lo = {}, xf;
function bE() {
  if (xf) return lo;
  xf = 1, Object.defineProperty(lo, "__esModule", { value: !0 }), lo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return lo;
}
var po = {}, vf;
function gE() {
  if (vf) return po;
  vf = 1, Object.defineProperty(po, "__esModule", { value: !0 }), po.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return po;
}
var kn = {}, Rf;
function EE() {
  if (Rf) return kn;
  Rf = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.isAspectRatio = e, kn.validateAspectRatio = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.embed.defs", o = "aspectRatio";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o);
  }
  return kn;
}
var er = {}, Af;
function xE() {
  if (Af) return er;
  Af = 1, Object.defineProperty(er, "__esModule", { value: !0 }), er.isMain = e, er.validateMain = l, er.isExternal = u, er.validateExternal = f, er.isView = g, er.validateView = A, er.isViewExternal = R, er.validateViewExternal = E;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.embed.external", o = "main";
  function e(h) {
    return i(h, s, o);
  }
  function l(h) {
    return n(h, s, o);
  }
  const a = "external";
  function u(h) {
    return i(h, s, a);
  }
  function f(h) {
    return n(h, s, a);
  }
  const m = "view";
  function g(h) {
    return i(h, s, m);
  }
  function A(h) {
    return n(h, s, m);
  }
  const v = "viewExternal";
  function R(h) {
    return i(h, s, v);
  }
  function E(h) {
    return n(h, s, v);
  }
  return er;
}
var tr = {}, _f;
function vE() {
  if (_f) return tr;
  _f = 1, Object.defineProperty(tr, "__esModule", { value: !0 }), tr.isMain = e, tr.validateMain = l, tr.isImage = u, tr.validateImage = f, tr.isView = g, tr.validateView = A, tr.isViewImage = R, tr.validateViewImage = E;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.embed.images", o = "main";
  function e(h) {
    return i(h, s, o);
  }
  function l(h) {
    return n(h, s, o);
  }
  const a = "image";
  function u(h) {
    return i(h, s, a);
  }
  function f(h) {
    return n(h, s, a);
  }
  const m = "view";
  function g(h) {
    return i(h, s, m);
  }
  function A(h) {
    return n(h, s, m);
  }
  const v = "viewImage";
  function R(h) {
    return i(h, s, v);
  }
  function E(h) {
    return n(h, s, v);
  }
  return tr;
}
var xt = {}, Cf;
function RE() {
  if (Cf) return xt;
  Cf = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.isMain = e, xt.validateMain = l, xt.isView = u, xt.validateView = f, xt.isViewRecord = g, xt.validateViewRecord = A, xt.isViewNotFound = R, xt.validateViewNotFound = E, xt.isViewBlocked = C, xt.validateViewBlocked = K, xt.isViewDetached = F, xt.validateViewDetached = Z;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.embed.record", o = "main";
  function e(q) {
    return i(q, s, o);
  }
  function l(q) {
    return n(q, s, o);
  }
  const a = "view";
  function u(q) {
    return i(q, s, a);
  }
  function f(q) {
    return n(q, s, a);
  }
  const m = "viewRecord";
  function g(q) {
    return i(q, s, m);
  }
  function A(q) {
    return n(q, s, m);
  }
  const v = "viewNotFound";
  function R(q) {
    return i(q, s, v);
  }
  function E(q) {
    return n(q, s, v);
  }
  const h = "viewBlocked";
  function C(q) {
    return i(q, s, h);
  }
  function K(q) {
    return n(q, s, h);
  }
  const k = "viewDetached";
  function F(q) {
    return i(q, s, k);
  }
  function Z(q) {
    return n(q, s, k);
  }
  return xt;
}
var ni = {}, Tf;
function AE() {
  if (Tf) return ni;
  Tf = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.isMain = e, ni.validateMain = l, ni.isView = u, ni.validateView = f;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.embed.recordWithMedia", o = "main";
  function e(m) {
    return i(m, s, o);
  }
  function l(m) {
    return n(m, s, o);
  }
  const a = "view";
  function u(m) {
    return i(m, s, a);
  }
  function f(m) {
    return n(m, s, a);
  }
  return ni;
}
var Rr = {}, Sf;
function _E() {
  if (Sf) return Rr;
  Sf = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.isMain = e, Rr.validateMain = l, Rr.isCaption = u, Rr.validateCaption = f, Rr.isView = g, Rr.validateView = A;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.embed.video", o = "main";
  function e(v) {
    return i(v, s, o);
  }
  function l(v) {
    return n(v, s, o);
  }
  const a = "caption";
  function u(v) {
    return i(v, s, a);
  }
  function f(v) {
    return n(v, s, a);
  }
  const m = "view";
  function g(v) {
    return i(v, s, m);
  }
  function A(v) {
    return n(v, s, m);
  }
  return Rr;
}
var te = {}, wf;
function CE() {
  if (wf) return te;
  wf = 1, Object.defineProperty(te, "__esModule", { value: !0 }), te.INTERACTIONSHARE = te.INTERACTIONQUOTE = te.INTERACTIONREPLY = te.INTERACTIONREPOST = te.INTERACTIONLIKE = te.INTERACTIONSEEN = te.CONTENTMODEVIDEO = te.CONTENTMODEUNSPECIFIED = te.CLICKTHROUGHEMBED = te.CLICKTHROUGHREPOSTER = te.CLICKTHROUGHAUTHOR = te.CLICKTHROUGHITEM = te.REQUESTMORE = te.REQUESTLESS = void 0, te.isPostView = e, te.validatePostView = l, te.isViewerState = u, te.validateViewerState = f, te.isThreadContext = g, te.validateThreadContext = A, te.isFeedViewPost = R, te.validateFeedViewPost = E, te.isReplyRef = C, te.validateReplyRef = K, te.isReasonRepost = F, te.validateReasonRepost = Z, te.isReasonPin = J, te.validateReasonPin = xe, te.isThreadViewPost = Y, te.validateThreadViewPost = T, te.isNotFoundPost = U, te.validateNotFoundPost = D, te.isBlockedPost = ae, te.validateBlockedPost = le, te.isBlockedAuthor = ze, te.validateBlockedAuthor = Ce, te.isGeneratorView = Ie, te.validateGeneratorView = je, te.isGeneratorViewerState = Xe, te.validateGeneratorViewerState = Je, te.isSkeletonFeedPost = Ge, te.validateSkeletonFeedPost = Fe, te.isSkeletonReasonRepost = Oe, te.validateSkeletonReasonRepost = it, te.isSkeletonReasonPin = Qe, te.validateSkeletonReasonPin = be, te.isThreadgateView = Pe, te.validateThreadgateView = nt, te.isInteraction = st, te.validateInteraction = Ve;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.defs", o = "postView";
  function e(X) {
    return i(X, s, o);
  }
  function l(X) {
    return n(X, s, o);
  }
  const a = "viewerState";
  function u(X) {
    return i(X, s, a);
  }
  function f(X) {
    return n(X, s, a);
  }
  const m = "threadContext";
  function g(X) {
    return i(X, s, m);
  }
  function A(X) {
    return n(X, s, m);
  }
  const v = "feedViewPost";
  function R(X) {
    return i(X, s, v);
  }
  function E(X) {
    return n(X, s, v);
  }
  const h = "replyRef";
  function C(X) {
    return i(X, s, h);
  }
  function K(X) {
    return n(X, s, h);
  }
  const k = "reasonRepost";
  function F(X) {
    return i(X, s, k);
  }
  function Z(X) {
    return n(X, s, k);
  }
  const q = "reasonPin";
  function J(X) {
    return i(X, s, q);
  }
  function xe(X) {
    return n(X, s, q);
  }
  const oe = "threadViewPost";
  function Y(X) {
    return i(X, s, oe);
  }
  function T(X) {
    return n(X, s, oe);
  }
  const V = "notFoundPost";
  function U(X) {
    return i(X, s, V);
  }
  function D(X) {
    return n(X, s, V);
  }
  const N = "blockedPost";
  function ae(X) {
    return i(X, s, N);
  }
  function le(X) {
    return n(X, s, N);
  }
  const he = "blockedAuthor";
  function ze(X) {
    return i(X, s, he);
  }
  function Ce(X) {
    return n(X, s, he);
  }
  const Be = "generatorView";
  function Ie(X) {
    return i(X, s, Be);
  }
  function je(X) {
    return n(X, s, Be);
  }
  const qe = "generatorViewerState";
  function Xe(X) {
    return i(X, s, qe);
  }
  function Je(X) {
    return n(X, s, qe);
  }
  const ke = "skeletonFeedPost";
  function Ge(X) {
    return i(X, s, ke);
  }
  function Fe(X) {
    return n(X, s, ke);
  }
  const Se = "skeletonReasonRepost";
  function Oe(X) {
    return i(X, s, Se);
  }
  function it(X) {
    return n(X, s, Se);
  }
  const Te = "skeletonReasonPin";
  function Qe(X) {
    return i(X, s, Te);
  }
  function be(X) {
    return n(X, s, Te);
  }
  const we = "threadgateView";
  function Pe(X) {
    return i(X, s, we);
  }
  function nt(X) {
    return n(X, s, we);
  }
  const Ue = "interaction";
  function st(X) {
    return i(X, s, Ue);
  }
  function Ve(X) {
    return n(X, s, Ue);
  }
  return te.REQUESTLESS = `${s}#requestLess`, te.REQUESTMORE = `${s}#requestMore`, te.CLICKTHROUGHITEM = `${s}#clickthroughItem`, te.CLICKTHROUGHAUTHOR = `${s}#clickthroughAuthor`, te.CLICKTHROUGHREPOSTER = `${s}#clickthroughReposter`, te.CLICKTHROUGHEMBED = `${s}#clickthroughEmbed`, te.CONTENTMODEUNSPECIFIED = `${s}#contentModeUnspecified`, te.CONTENTMODEVIDEO = `${s}#contentModeVideo`, te.INTERACTIONSEEN = `${s}#interactionSeen`, te.INTERACTIONLIKE = `${s}#interactionLike`, te.INTERACTIONREPOST = `${s}#interactionRepost`, te.INTERACTIONREPLY = `${s}#interactionReply`, te.INTERACTIONQUOTE = `${s}#interactionQuote`, te.INTERACTIONSHARE = `${s}#interactionShare`, te;
}
var Or = {}, Lf;
function TE() {
  if (Lf) return Or;
  Lf = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.toKnownErr = o, Or.isFeed = l, Or.validateFeed = a, Or.isLinks = f, Or.validateLinks = m;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.describeFeedGenerator";
  function o(g) {
    return g;
  }
  const e = "feed";
  function l(g) {
    return i(g, s, e);
  }
  function a(g) {
    return n(g, s, e);
  }
  const u = "links";
  function f(g) {
    return i(g, s, u);
  }
  function m(g) {
    return n(g, s, u);
  }
  return Or;
}
var Dn = {}, kf;
function SE() {
  if (kf) return Dn;
  kf = 1, Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.isRecord = e, Dn.validateRecord = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.generator", o = "main";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o, !0);
  }
  return Dn;
}
var fo = {}, Df;
function wE() {
  if (Df) return fo;
  Df = 1, Object.defineProperty(fo, "__esModule", { value: !0 }), fo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return fo;
}
var yo = {}, Bf;
function LE() {
  if (Bf) return yo;
  Bf = 1, Object.defineProperty(yo, "__esModule", { value: !0 }), yo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return yo;
}
var mo = {}, Pf;
function kE() {
  if (Pf) return mo;
  Pf = 1, Object.defineProperty(mo, "__esModule", { value: !0 }), mo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return mo;
}
var sn = {}, Uf;
function DE() {
  if (Uf) return sn;
  Uf = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.toKnownErr = o, sn.isLike = l, sn.validateLike = a;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.getLikes";
  function o(u) {
    return u;
  }
  const e = "like";
  function l(u) {
    return i(u, s, e);
  }
  function a(u) {
    return n(u, s, e);
  }
  return sn;
}
var ho = {}, Vf;
function BE() {
  if (Vf) return ho;
  Vf = 1, Object.defineProperty(ho, "__esModule", { value: !0 }), ho.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return ho;
}
var bo = {}, Kf;
function PE() {
  if (Kf) return bo;
  Kf = 1, Object.defineProperty(bo, "__esModule", { value: !0 }), bo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return bo;
}
var go = {}, If;
function UE() {
  if (If) return go;
  If = 1, Object.defineProperty(go, "__esModule", { value: !0 }), go.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return go;
}
var Eo = {}, jf;
function VE() {
  if (jf) return Eo;
  jf = 1, Object.defineProperty(Eo, "__esModule", { value: !0 }), Eo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return Eo;
}
var xo = {}, qf;
function KE() {
  if (qf) return xo;
  qf = 1, Object.defineProperty(xo, "__esModule", { value: !0 }), xo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return xo;
}
var Bn = {}, Of;
function IE() {
  if (Of) return Bn;
  Of = 1, Object.defineProperty(Bn, "__esModule", { value: !0 }), Bn.isRecord = e, Bn.validateRecord = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.like", o = "main";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o, !0);
  }
  return Bn;
}
var rr = {}, Mf;
function jE() {
  if (Mf) return rr;
  Mf = 1, Object.defineProperty(rr, "__esModule", { value: !0 }), rr.isRecord = e, rr.validateRecord = l, rr.isReplyRef = u, rr.validateReplyRef = f, rr.isEntity = g, rr.validateEntity = A, rr.isTextSlice = R, rr.validateTextSlice = E;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.post", o = "main";
  function e(h) {
    return i(h, s, o);
  }
  function l(h) {
    return n(h, s, o, !0);
  }
  const a = "replyRef";
  function u(h) {
    return i(h, s, a);
  }
  function f(h) {
    return n(h, s, a);
  }
  const m = "entity";
  function g(h) {
    return i(h, s, m);
  }
  function A(h) {
    return n(h, s, m);
  }
  const v = "textSlice";
  function R(h) {
    return i(h, s, v);
  }
  function E(h) {
    return n(h, s, v);
  }
  return rr;
}
var si = {}, Nf;
function qE() {
  if (Nf) return si;
  Nf = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.isRecord = e, si.validateRecord = l, si.isDisableRule = u, si.validateDisableRule = f;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.postgate", o = "main";
  function e(m) {
    return i(m, s, o);
  }
  function l(m) {
    return n(m, s, o, !0);
  }
  const a = "disableRule";
  function u(m) {
    return i(m, s, a);
  }
  function f(m) {
    return n(m, s, a);
  }
  return si;
}
var Pn = {}, Gf;
function OE() {
  if (Gf) return Pn;
  Gf = 1, Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.isRecord = e, Pn.validateRecord = l;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.repost", o = "main";
  function e(a) {
    return i(a, s, o);
  }
  function l(a) {
    return n(a, s, o, !0);
  }
  return Pn;
}
var vo = {}, Ff;
function ME() {
  if (Ff) return vo;
  Ff = 1, Object.defineProperty(vo, "__esModule", { value: !0 }), vo.toKnownErr = i;
  const r = S();
  w().is$typed, r.validate;
  function i(n) {
    return n;
  }
  return vo;
}
var Ot = {}, $f;
function NE() {
  if ($f) return Ot;
  $f = 1, Object.defineProperty(Ot, "__esModule", { value: !0 }), Ot.isRecord = e, Ot.validateRecord = l, Ot.isMentionRule = u, Ot.validateMentionRule = f, Ot.isFollowerRule = g, Ot.validateFollowerRule = A, Ot.isFollowingRule = R, Ot.validateFollowingRule = E, Ot.isListRule = C, Ot.validateListRule = K;
  const r = S(), i = w().is$typed, n = r.validate, s = "app.bsky.feed.threadgate", o = "main";
  function e(k) {
    return i(k, s, o);
  }
  function l(k) {
    return n(k, s, o, !0);
  }
  const a = "mentionRule";
  function u(k) {
    return i(k, s, a);
  }
  function f(k) {
    return n(k, s, a);
  }
  const m = "fo
