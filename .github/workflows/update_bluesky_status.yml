# .github/workflows/update_bluesky_status.yml

name: Update Bluesky Status

# This workflow will run on a schedule and can also be triggered manually.
on:
  schedule:
    # Runs every 3 hours (e.g., 00:00, 03:00, 06:00 UTC)
    # Adjust the cron schedule to your desired frequency.
    # For example, '0 0 * * *' for once a day at midnight UTC.
    # Note: GitHub Actions schedules can be delayed by a few minutes.
    - cron: '0 */3 * * *'
  workflow_dispatch:
    # This empty entry enables manual triggering from the GitHub Actions tab.
    # You will see a "Run workflow" button for this workflow.

jobs:
  update_data:
    runs-on: ubuntu-latest # The type of runner that the job will execute on

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4 # Action to clone your repository

      - name: Set up Ruby environment
        uses: ruby/setup-ruby@v1 # Action to set up Ruby
        with:
          ruby-version: '3.3' # Use a Ruby version compatible with your Jekyll setup (e.g., 3.2, 3.3)
          bundler-cache: true # Installs gems from Gemfile.lock (fastest way)

      - name: Run Jekyll generator to update data
        # This command triggers Jekyll's build process.
        # Your `_plugins/bluesky_post_fetcher.rb` (a Jekyll Generator) runs during this process.
        # It will fetch the latest Bluesky post and update `_data/bluesky_latest_post.yml`
        # directly in the source directory (your repository's working copy).
        run: |
          bundle exec jekyll build --source . --destination _site_temp # Build to a temporary directory
        env:
          JEKYLL_ENV: production # Ensure plugins run in production mode

      - name: Stage changes for commit
        # This command adds `_data/bluesky_latest_post.yml` to Git's staging area.
        # It handles both new files (first run) and modified files gracefully.
        run: |
          git add _data/bluesky_latest_post.yml
        # `continue-on-error: true` is generally good here if the file might not exist
        # in some edge cases (e.g., plugin failed to create it). The next step will check for actual changes.

      - name: Check if there are changes to commit
        id: git_status_check # This ID is used to reference this step's outputs
        run: |
          # `git diff --cached --quiet` checks if there are staged changes compared to the last commit.
          # If it returns a non-zero exit code (meaning changes exist), then set the output.
          if ! git diff --cached --quiet; then
            echo "file_status=changed" >> $GITHUB_OUTPUT # New method for setting outputs
            echo "Changes detected in _data/bluesky_latest_post.yml, ready to commit."
          else
            echo "file_status=no_change" >> $GITHUB_OUTPUT # New method for setting outputs
            echo "No changes detected in _data/bluesky_latest_post.yml. Skipping commit."
          fi
        shell: bash # Ensures bash is used for `echo ... >> $GITHUB_OUTPUT` syntax

      - name: Commit and push changes
        # This step only runs if the previous step detected 'changed' status.
        if: steps.git_status_check.outputs.file_status == 'changed'
        run: |
          git config --global user.name 'github-actions[bot]' # Identify the committer as a bot
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          # The file is already staged by the "Stage changes for commit" step
          git commit -m "Automated: Update Bluesky status from latest post"
          git push # Pushes the commit to the repository
